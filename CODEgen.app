'From VisualWorks(R), Release 2.5.2 of September 26, 1995 on April 30, 2018 at 8:31:52 pm'!



Application create: #CODEgen with: 
    (#( Kernel)
        collect: [:each | Smalltalk at: each ifAbsent: [
        self error: 'Not all of the prerequisites are loaded']])!

CODEgen becomeDefault!

Object subclass: #CODEElement
	instanceVariableNames: 'name expansions expansionInitialized upperInitialName timestamp dirty isNotPersistentMetaInfo '
	classVariableNames: 'ExpressionBinaryOperators ExpressionOperators ExpressionUnaryOperators ModelElementKindsFactoryCache '
	poolDictionaries: ''!

CODEElement comment: 'No description

Instance Variables:
	name <String> No description
	comments <ISFIdentitySet of: CODEComment> Association implantation
	parameters <ISFIdentitySet of: CODEParameter> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODEElement subclass: #CODEComment
	instanceVariableNames: 'text element '
	classVariableNames: ''
	poolDictionaries: ''!

CODEComment comment: 'No description

Instance Variables:
	text <String> No description
	element <CODEElement> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODEElement subclass: #CODECommentedElement
	instanceVariableNames: 'comments '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODECommentedElement subclass: #CODEParameter
	instanceVariableNames: 'value element '
	classVariableNames: ''
	poolDictionaries: ''!

CODEParameter comment: 'No description

Instance Variables:
	value <String> No description
	element <CODEElement> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODECommentedElement subclass: #CODEParametrizedElement
	instanceVariableNames: 'parameters '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEParametrizedElement subclass: #CODEAspect
	instanceVariableNames: 'aspectDefiner appliedToElements '
	classVariableNames: ''
	poolDictionaries: ''!

CODEAspect comment: 'No description

Instance Variables:
	value <String> No description
	aspectDefiner <CODEElement> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODEParametrizedElement subclass: #CODEAspectuatedElement
	instanceVariableNames: 'definedAspects aspects aspectsRefsTmpValues '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEArgument
	instanceVariableNames: 'operation argumentType minMult maxMult argumentRefinements isChangeable isExclussion isIDArgument orderConstraint candidatesPath candidatesConstraint initializationExpression computationKind isDuplicatesAllowed valueConstraint isInitializationPropagationAllowed isInitializationPropagationOnConnectAllowed argumentTypeRefTmpValues '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEArgument subclass: #CODEArgumentRefinement
	instanceVariableNames: 'refinedArguments refinedArgumentsRefTmpValues '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEComponent
	instanceVariableNames: 'module subTypes superTypes types components ports usedComponents connections eventLivedType interactionLivedType transactionLivedType processLivedType globalLivedType staticLivedType isAbstract isPrimitive storeMethodSelector storeClassName reengineredClassName isExclussion primitiveInitializationString isHomeRooted primitiveBroker observers isUse isJustUsed '
	classVariableNames: ''
	poolDictionaries: ''!

CODEComponent comment: 'No description

Instance Variables:
	subTypes <ISFIdentitySet of: CODEComponent> Association implantation
	superType <CODEComponent> Association implantation
	relatedWith <ISFIdentitySet of: CODERelationship> Association implantation
	attributes <ISFOrderedCollection of: CODEAttribute> Association implantation
	relationships <ISFOrderedCollection of: CODERelationship> Association implantation
	model <CODEModel> Association implantation
	module <CODEModule> Association implantation
	baseOutFileName <String> No description
	implOutFileName <String> No description
	ifcOutFileName <String> No description
	privOutFileName <String> No description
	typeOfValues <ISFIdentitySet of: CODEAttribute> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEElementMap
	instanceVariableNames: 'mapsFolder sourceElements viewElements superElementMap subElementMaps mapLogic sourceElementsRefsTmpValues viewElementsRefsTmpValues '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEMapLogic
	instanceVariableNames: 'elementMap mapMode '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEModule
	instanceVariableNames: 'superModule subModules types prjNdx baseOutPrjNdx implOutPrjNdx ifcOutPrjNdx trxOutPrjNdx privOutPrjNdx skip rootType rootTypeSearched storeMethodSelector storeClassName includedModules includedInModules definitionsHolderClassNameForInstances configurationClassNameForInstances applicationConfiguration '
	classVariableNames: ''
	poolDictionaries: ''!

CODEModule comment: 'No description

Instance Variables:
	superModule <CODEModule> Association implantation
	subModules <ISFIdentitySet of: CODEModule> Association implantation
	types <ISFOrderedCollection of: CODEType> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODEModule subclass: #CODEMapsFolder
	instanceVariableNames: 'elementMaps '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEModule subclass: #CODEModel
	instanceVariableNames: 'aspectToGenerate sourceFileName package templatesDirectory outputDirectory projectDirectory projectName typePrefix relationshipVariablePrefix attributeVariablePrefix enumVariablePrefix expansionDelimiter skipTypes skipModules serialVersionUIDPrefix prjOutStream nativeAttributesMap nativeAttributesSet errorLineKind errorLineName defaultSuperTypeFullBaseClassName defaultSuperTypeFullIfcClassName defaultSuperTypeFullPrivClassName defaultSuperTypeFullTrxClassName defaultSuperTypeFullPubClassName defaultSuperTypeFullImplClassName frameworkPackage metaPackage metaMetaPackage metaVariablePrefix metamodelOutStream browserFrameworkPackage rootTypeName wholeTreeConfigOutFileName wholeTreeConfigOutStream foundIsAbstract isM3 wholeTraversalConfigOutFileName wholeTraversalConfigOutStream m3FactoryName wholeReplicationConfigOutFileName generatingReplicationTraversalConfig metaTraversalPackage generationStyle generateSeparateActions defaultApplicationTranslationStoreClassName defaultApplicationTranslationStoreMethodSelector '
	classVariableNames: ''
	poolDictionaries: ''!

CODEModel comment: 'No description

Instance Variables:
	types <ISFOrderedCollection of: CODEType> Association implantation
	outputDirectory <String> No description
	typePrefix <String> No description
	relationshipVariablePrefix <String> No description
	attributeVariablePrefix <String> No description


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODEModel subclass: #CODEMap
	instanceVariableNames: 'sourceModel viewModel elementMaps sourceModelRefTmpValues viewModelRefTmpValues '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEOperation
	instanceVariableNames: 'type returnType arguments minMult maxMult orderConstraint isAbstract operationRefinements isExclussion enablementConstraint executableExpression returnTypeRefTmpValues '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEOperation subclass: #CODEOperationRefinement
	instanceVariableNames: 'refinedOperations refinedOperationsRefTmpValues '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEPort
	instanceVariableNames: 'subTypes superTypes component ports outerConnections innerConnections direction types isAbstract isPrimitive storeMethodSelector storeClassName reengineredClassName isExclussion primitiveInitializationString primitiveBroker observers isUse isJustUsed '
	classVariableNames: ''
	poolDictionaries: ''!

CODEPort comment: 'No description

Instance Variables:
	subTypes <ISFIdentitySet of: CODEPort> Association implantation
	superType <CODEPort> Association implantation
	relatedWith <ISFIdentitySet of: CODERelationship> Association implantation
	attributes <ISFOrderedCollection of: CODEAttribute> Association implantation
	relationships <ISFOrderedCollection of: CODERelationship> Association implantation
	model <CODEModel> Association implantation
	module <CODEModule> Association implantation
	baseOutFileName <String> No description
	implOutFileName <String> No description
	ifcOutFileName <String> No description
	privOutFileName <String> No description
	typeOfValues <ISFIdentitySet of: CODEAttribute> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODEPort subclass: #CODERootPort
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEPort subclass: #CODESubPort
	instanceVariableNames: 'parentPort '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODESubPort subclass: #CODEFlowPort
	instanceVariableNames: 'flowType '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODESubPort subclass: #CODEProtocolPort
	instanceVariableNames: 'protocolPort '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODESubPort subclass: #CODESemanticPort
	instanceVariableNames: 'semanticParameters '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODESubPort subclass: #CODESemanticPortParameter
	instanceVariableNames: 'semanticPort port '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEStructuralFeature
	instanceVariableNames: 'dependencies '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEStructuralFeature subclass: #CODEAttribute
	instanceVariableNames: 'valueType type valueTypeName minMult maxMult valueTypeRefTmpValues isAbstract reengineredInstVarName attributeRefinements isExclussion isNameAttribute isIDAttribute orderConstraint candidatesPath candidatesConstraint initializationExpression computationKind isChangeable isDuplicatesAllowed valueConstraint isInitializationPropagationAllowed isInitializationPropagationOnConnectAllowed isPropagateUse isJustUsed isRefinementRequired '
	classVariableNames: ''
	poolDictionaries: ''!

CODEAttribute comment: 'No description

Instance Variables:
	valueType <String> No description
	type <CODEType> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODEAttribute subclass: #CODEAttributeRefinement
	instanceVariableNames: 'refinedAttributes refinedAttributesRefTmpValues refinedMetaAttributeNames '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEStructuralFeature subclass: #CODERelationship
	instanceVariableNames: 'kind minMult maxMult relatedType inverse reverse type derived dummy isAbstract reengineredInstVarName bmgrOutFileName bmgrOutStream inverseRelationshipRefTmpValues relationshipRefinements isExclussion orderConstraint candidatesPath candidatesConstraint initializationExpression computationKind isChangeable isDuplicatesAllowed isNameRelationship isInitializationPropagationAllowed isInitializationPropagationOnConnectAllowed isPropagateUse isJustUsed isRefinementRequired '
	classVariableNames: ''
	poolDictionaries: ''!

CODERelationship comment: 'No description

Instance Variables:
	kind <String> No description
	minMult <String> No description
	maxMult <String> No description
	relatedType <CODEType> Association implantation
	inverse <CODERelationship> Association implantation
	reverse <CODERelationship> Association implantation
	type <CODEType> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

CODERelationship subclass: #CODERelationshipRefinement
	instanceVariableNames: 'refinedRelationships refinedRelationshipsRefTmpValues refinedMetaAttributeNames '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEAspectuatedElement subclass: #CODEType
	instanceVariableNames: 'subTypes superTypes types relatedWith attributes relationships baseOutFileName baseOutStream implOutFileName implOutStream ifcOutFileName ifcOutStream trxOutFileName trxOutStream privOutFileName privOutStream custOutFileName custOutStream pubOutFileName pubOutStream skip typeOfValues module baseOutPrjNdx implOutPrjNdx ifcOutPrjNdx trxOutPrjNdx privOutPrjNdx isAbstract isEnumeration isPrimitive attributesToGenerate relationshipsToGenerate derivedRelationshipsToGenerate nmgrOutFileName nmgrOutStream chooserOutFileName chooserOutStream metaOutStream metaOutFileName deleteActionOutStream deleteActionOutFileName storeMethodSelector storeClassName superTypesRefsTmpValues reengineredClassName isExclussion isVirtual primitiveInitializationString isHomeRooted isHomeIDProvider primitiveBroker isRequiredFeaturesType observers typeOfArguments typeOfReturns operations isUse isJustUsed effectiveAttributesCache effectiveRelationshipsCache effectiveStructuralFeaturesCache effectiveOperationsCache effectiveFeaturesCache effectiveIDAttributeCache effectiveNameAttributeCache memberInstanceTypesCache '
	classVariableNames: ''
	poolDictionaries: ''!

CODEType comment: 'No description

Instance Variables:
	subTypes <ISFIdentitySet of: CODEType> Association implantation
	superType <CODEType> Association implantation
	relatedWith <ISFIdentitySet of: CODERelationship> Association implantation
	attributes <ISFOrderedCollection of: CODEAttribute> Association implantation
	relationships <ISFOrderedCollection of: CODERelationship> Association implantation
	model <CODEModel> Association implantation
	module <CODEModule> Association implantation
	baseOutFileName <String> No description
	implOutFileName <String> No description
	ifcOutFileName <String> No description
	privOutFileName <String> No description
	typeOfValues <ISFIdentitySet of: CODEAttribute> Association implantation


Class Variables:


Metaclass Instance Variables:
'!

CODEgen becomeDefault!

Object subclass: #CODEGenInstaller
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

Object subclass: #CODEReengine
	instanceVariableNames: 'name classPrefixes factoryForModel factoryForModule factoryForType factoryForAttribute factoryForRelationship factoryForComment factoryForParameter classesToTypesDict '
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

CODEReengine subclass: #CODEcodeReengine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

Application subclass: #CODEgen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''!

CODEgen becomeDefault!

!CODEArgument class publicMethodsFor: 'accessing'!

kind
	^#argument! !

!CODEArgument class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEArgument class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^super modelEditorMETAPerspectives, self modelEditorMETAPerspectivesArgument, 
			self modelEditorMETAPerspectivesTranslation, self modelEditorMETAPerspectivesConstraints!

modelEditorMETAPerspectivesArgument

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ArgumentType'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'ArgumentType' )))
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Perspectives';
			nlsItem: 'ArgumentType';
			nlsTranslation: 'TipoDelArgumento';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Operation'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Operation' )))
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Perspectives';
			nlsItem: 'Operation';
			nlsTranslation: 'Operacion';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ArgumentRefinements'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'ArgumentRefinements' )))
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Perspectives';
			nlsItem: 'ArgumentRefinements';
			nlsTranslation: 'ArgumentosRefinados';
			yourself);
		yourself!

modelEditorMETAPerspectivesConstraints
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Constraints'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'IsIDArgument' 'IsExclussion'  'IsChangeable' 'IsDuplicatesAllowed' 'IsInitializationPropagationAllowed' 'IsInitializationPropagationOnConnectAllowed'  'ComputationKind' 'OrderConstraint' 'CandidatesPath' 'CandidatesConstraint' 'InitializationExpression' 'ValueConstraint' )))
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Perspectives';
			nlsItem: 'Constraints';
			nlsTranslation: 'Constricciones';
			yourself);
		yourself!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'IsDirty' 'MinMult' 'MaxMult'  'ArgumentType')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesTranslation
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Traducciones'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('NLSName' 'NLSKind' 'NLSNameOne'  'NLSAppName' 'NLSGroupName' 'NLSItemName' 'NLSItemNameOne')))
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Perspectives';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'Traducciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ItemTranslations'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('ItemTranslations')))
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Perspectives';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'ElementosDeTraduccion';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsArgument,
		self modelEditorMETASelectorsTranslation, self modelEditorMETASelectorsMoreTranslation!

modelEditorMETASelectorsArgument

	"METAChildSpecAutoViewEditor openOn: CODEArgument selector: #modelEditorMETASelectorsArgument target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MinMult';
			basicSelector: #minMult;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MinMult';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: '0 1 2 *';
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'MinMult';
			nlsTranslation: 'MinimoDeElementos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MaxMult';
			basicSelector: #maxMult;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MaxMult';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: '0 1 2 *';
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'MaxMult';
			nlsTranslation: 'MaximoDeElementos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsIDArgument';
			basicSelector: #isIDArgument;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsIDArgument';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'IsIDArgument';
			nlsTranslation: 'EsIdentificador';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsChangeable';
			basicSelector: #isChangeable;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsChangeable';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'IsChangeable';
			nlsTranslation: 'EsModificable';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsDuplicatesAllowed';
			basicSelector: #isDuplicatesAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsDuplicatesAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'IsDuplicatesAllowed';
			nlsTranslation: 'PermiteDuplicados';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsInitializationPropagationAllowed';
			basicSelector: #isInitializationPropagationAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsInitializationPropagationAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'IsInitializationPropagationAllowed';
			nlsTranslation: 'PropagacionInitializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsInitializationPropagationOnConnectAllowed';
			basicSelector: #isInitializationPropagationOnConnectAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsInitializationPropagationOnConnectAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'IsInitializationPropagationOnConnectAllowed';
			nlsTranslation: 'PropagacionOnConnectInitializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ComputationKind';
			basicSelector: #computationKind;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ComputationKind';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: 'NOCOMPUTATION ALWAYS  INITIALVALUE INITIALIZEDINCONSTRUCTOR AFTERCONNECTION   FROMHOMEIDCOUNTER';
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'ComputationKind';
			nlsTranslation: 'ClaseDeComputacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'OrderConstraint';
			basicSelector: #orderConstraint;
			type: #String;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'OrderConstraint';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'OrderConstraint';
			nlsTranslation: 'ConstriccionDeOrden';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'CandidatesPath';
			basicSelector: #candidatesPath;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'CandidatesPath';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'CandidatesPath';
			nlsTranslation: 'CaminoACandidatos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'CandidatesConstraint';
			basicSelector: #candidatesConstraint;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'CandidatesConstraint';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'CandidatesConstraint';
			nlsTranslation: 'ConstriccionDeCandidatos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'InitializationExpression';
			basicSelector: #initializationExpression;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'InitializationExpression';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'InitializationExpression';
			nlsTranslation: 'ExpressionDeInicializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ValueConstraint';
			basicSelector: #valueConstraint;
			type: #String;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ValueConstraint';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'ValueConstraint';
			nlsTranslation: 'ConstriccionDeValor';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ArgumentType';
			basicSelector: #argumentType;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'ArgumentType';
			displaySelector: nil;
			objectClassName: #CODEType;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'ArgumentType';
			nlsTranslation: 'TipoDelArgumento';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ArgumentRefinements';
			basicSelector: #argumentRefinements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ArgumentRefinements';
			displaySelector: #name;
			componentsClassName: #CODEArgument;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'ArgumentRefinements';
			nlsTranslation: 'AtributosRefinados';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Operation';
			basicSelector: #operation;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Operation';
			displaySelector: #name;
			objectClassName: #CODEOperation;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Argument_Selectors';
			nlsItem: 'Operation';
			nlsTranslation: 'Operacion';
			yourself);
		yourself!

modelEditorMETASelectorsMoreTranslation

	"METAChildSpecAutoViewEditor openOn: CODEElement selector: #modelEditorMETASelectorsTranslation target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSItemNameOne';
			basicSelector: #nameNLSItemNameOne;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSItemNameOne';
			nlsTranslation: 'NombreItemTraduccionSingular';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSNameOne';
			basicSelector: #nlsNameOne;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSNameOne';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSNameOne';
			nlsTranslation: 'TraduccionSingular';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsArgument.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsArgument

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('ArgumentType' 'ArgumentRefinements' 'Operation')! !

!CODEArgument publicMethodsFor: 'accessing'!

argumentType
	"Generated by ISF/AD. Do not modify"
	^argumentType!

argumentType: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkArgumentType: aValue) ifFalse: [^aValue].
	argumentType == aValue ifTrue: [ ^self].
	self argumentTypeRelease.
	argumentType := aValue.
	aValue == nil ifFalse: [aValue typeOfArgumentsPrivateAdd: self].
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #argumentType!

candidatesConstraint
	candidatesConstraint isNil
		ifTrue: [self initCandidatesConstraint].
	^candidatesConstraint!

candidatesConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkCandidatesConstraint: aValue) ifFalse: [^aValue].
	candidatesConstraint := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #candidatesConstraint!

candidatesPath
	candidatesPath isNil
		ifTrue: [self initCandidatesPath].
	^candidatesPath!

candidatesPath: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkCandidatesPath: aValue) ifFalse: [^aValue].
	candidatesPath := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #candidatesPath!

computationKind
	computationKind isNil
		ifTrue: [self initComputationKind].
	^computationKind!

computationKind: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkComputationKind: aValue) ifFalse: [^aValue].
	computationKind := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #computationKind!

initializationExpression
	"Generated by ISF/AD. Do not modify"
	initializationExpression isNil
		ifTrue: [self initInitializationExpression].
	^initializationExpression!

initializationExpression: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkInitializationExpression: aValue  == true) ifFalse: [^aValue].
	initializationExpression := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #initializationExpression!

isChangeable
	"Generated by ISF/AD. Do not modify"
	isChangeable isNil
		ifTrue: [self initIsChangeable].
	^isChangeable!

isChangeable: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsChangeable: aValue) ifFalse: [^aValue].
	isChangeable := aValue == true.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #isChangeable!

isDuplicatesAllowed
	"Generated by ISF/AD. Do not modify"
	isDuplicatesAllowed isNil
		ifTrue: [self initIsDuplicatesAllowed].
	^isDuplicatesAllowed!

isDuplicatesAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsDuplicatesAllowed: aValue  == true) ifFalse: [^aValue].
	isDuplicatesAllowed := aValue == true.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #isDuplicatesAllowed!

isExclussion
	"Generated by ISF/AD. Do not modify"
	isExclussion isNil
		ifTrue: [self initIsExclussion].
	^isExclussion!

isExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	isExclussion := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #isExclussion!

isIDArgument
	"Generated by ISF/AD. Do not modify"
	isIDArgument isNil
		ifTrue: [self initIsIDArgument].
	^isIDArgument!

isIDArgument: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsIDArgument: aValue  == true) ifFalse: [^aValue].
	isIDArgument := aValue == true.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #isIDArgument!

isInitializationPropagationAllowed
	"Generated by ISF/AD. Do not modify"
	isInitializationPropagationAllowed isNil
		ifTrue: [self initIsInitializationPropagationAllowed].
	^isInitializationPropagationAllowed!

isInitializationPropagationAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsInitializationPropagationAllowed: aValue  == true) ifFalse: [^aValue].
	isInitializationPropagationAllowed := aValue == true.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #isInitializationPropagationAllowed!

isInitializationPropagationOnConnectAllowed
	"Generated by ISF/AD. Do not modify"
	isInitializationPropagationOnConnectAllowed isNil
		ifTrue: [self initIsInitializationPropagationOnConnectAllowed].
	^isInitializationPropagationOnConnectAllowed!

isInitializationPropagationOnConnectAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsInitializationPropagationOnConnectAllowed: aValue  == true) ifFalse: [^aValue].
	isInitializationPropagationOnConnectAllowed := aValue == true.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #isInitializationPropagationOnConnectAllowed!

maxMult
	"Generated by ISF/AD. Do not modify"
	maxMult isNil
		ifTrue: [self initMaxMult].
	^maxMult!

maxMult: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMaxMult: aValue) ifFalse: [^aValue].
	maxMult := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #maxMult!

minMult
	"Generated by ISF/AD. Do not modify"
	minMult isNil
		ifTrue: [self initMinMult].
	^minMult!

minMult: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMinMult: aValue) ifFalse: [^aValue].
	minMult := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #minMult!

orderConstraint
	orderConstraint isNil
		ifTrue: [self initOrderConstraint].
	^orderConstraint!

orderConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOrderConstraint: aValue) ifFalse: [^aValue].
	orderConstraint := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #orderConstraint!

valueConstraint
	valueConstraint isNil
		ifTrue: [self initValueConstraint].
	^valueConstraint!

valueConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkValueConstraint: aValue) ifFalse: [^aValue].
	valueConstraint := aValue.
	self markDirty.
	self invalidateEffectiveOperationsCaches.

	self changed: #valueConstraint! !

!CODEArgument publicMethodsFor: 'accessing-private'!

forzeCandidatesConstraint: aValue
	candidatesConstraint := aValue!

forzeCandidatesPath: aValue
	candidatesPath := aValue!

forzeComputationKind: aValue
	computationKind :=  aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeInitializationExpression: aValue
	initializationExpression := aValue!

forzeIsChangeable: aValue
	isChangeable := aValue == true.!

forzeIsDuplicatesAllowed: aValue
	isDuplicatesAllowed := aValue == true.!

forzeIsExclussion: aValue
	isExclussion := aValue == true.!

forzeIsIDArgument: aValue
	isIDArgument := aValue == true.!

forzeIsInitializationPropagationAllowed: aValue
	isInitializationPropagationAllowed := aValue == true.!

forzeIsInitializationPropagationOnConnectAllowed: aValue
	isInitializationPropagationOnConnectAllowed := aValue == true.!

forzeMaxMult: aValue
	maxMult := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeMinMult: aValue
	minMult := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeOrderConstraint: aValue
	orderConstraint := aValue!

forzeValueConstraint: aValue
	valueConstraint := aValue! !

!CODEArgument publicMethodsFor: 'association initialize-release'!

argumentRefinementsRelease
	"Generated by ISF/AD. Do not modify"
	self argumentRefinements do: [:each | self argumentRefinementsRemove: each]!

argumentTypeRelease
	"Generated by ISF/AD. Do not modify"
	argumentType == nil
		ifFalse:
			[argumentType operationOfValuesPrivateRemove: self.
				argumentType := nil.
				self changed: #argumentType]!

initArgumentRefinements
	"Generated by ISF/AD. Do not modify"
	argumentRefinements := OrderedCollection new.!

operationRelease
	"Generated by ISF/AD. Do not modify"
	operation == nil
		ifFalse:
			[operation argumentsPrivateRemove: self.
				operation := nil.
				self changed: #operation]! !

!CODEArgument publicMethodsFor: 'associations accessing'!

argumentRefinements
	"Generated by ISF/AD. Do not modify"
	^self argumentRefinementsPrivate copy!

argumentRefinementsAsArray
	"Generated by ISF/AD. Do not modify"
	^self argumentRefinements asArray!

operation
	"Generated by ISF/AD. Do not modify"
	^operation!

operation: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkType: aValue) ifFalse: [^aValue].
	operation == aValue ifTrue: [ ^self].
	self operationRelease.
	operation := aValue.
	aValue == nil ifFalse: [aValue argumentsPrivateAdd: self].
	self changed: #operation! !

!CODEArgument publicMethodsFor: 'associations modifying'!

argumentRefinementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkArgumentRefinementsAdd: aValue) ifFalse: [^aValue].
	(self argumentRefinementsIncludes: aValue) ifTrue: [^aValue].
	(self argumentRefinementsPrivateAdd: aValue) refinedArgumentsPrivateAdd: self.
	self changed: #argumentRefinements.
	^aValue!

argumentRefinementsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self argumentRefinementsIncludes: aValue) ifFalse: [^aValue].
	(self argumentRefinements indexOf: aValue) = self argumentRefinementsSize ifTrue: [^aValue].
	self argumentRefinementsPrivate remove: aValue.
	aRes := self argumentRefinementsPrivateAdd: aValue.
	^aRes!

argumentRefinementsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self argumentRefinementsIncludes: aValue) ifFalse: [^aValue].
	(index := self argumentRefinements indexOf: aValue) = self argumentRefinementsSize ifTrue: [^aValue].
	index = (self argumentRefinementsSize -1)
		ifTrue:
			[self argumentRefinementsPrivate remove: aValue.
			aRes := self argumentRefinementsPrivateAdd: aValue.
			self notifyChangeAllArgumentRefinementsChildSpecs.
			^aRes].
	aRes := self argumentRefinementsPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

argumentRefinementsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self argumentRefinementsIncludes: aValue) ifFalse: [^aValue].
	(self argumentRefinements indexOf: aValue) = 1 ifTrue: [^aValue].
	self argumentRefinementsPrivateMove: aValue beforeIndex: 1.!

argumentRefinementsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self argumentRefinementsIncludes: aValue) ifFalse: [^aValue].
	(index := self argumentRefinements indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self argumentRefinementsPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

argumentRefinementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkArgumentRefinementsRemove: aValue) ifFalse: [^aValue].
	(self argumentRefinementsPrivate remove: aValue ifAbsent: [^aValue]) refinedArgumentsPrivateRemove: self.
	self changed: #argumentRefinements.
	^aValue! !

!CODEArgument publicMethodsFor: 'associations private'!

argumentRefinementsPrivate
	"Generated by ISF/AD. Do not modify"
	argumentRefinements isNil
		ifTrue: [self initArgumentRefinements].
	^argumentRefinements!

argumentRefinementsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self argumentRefinementsPrivate add: aValue.
	self changed: #argumentRefinements.
	^aValue!

argumentRefinementsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self argumentRefinements at: anIndex.
	self argumentRefinementsPrivate remove: aValue.
	self argumentRefinementsPrivate add: aValue before: obj.
	self changed: #argumentRefinements.
	^aValue!

argumentRefinementsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self argumentRefinementsPrivate remove: aValue.
	self changed: #argumentRefinements.
	^aValue!

argumentTypePrivate: aValue
	"Generated by ISF/AD. Do not modify"
	argumentType := aValue.
	self markDirty.
	self changed: #argumentType!

forzeArgumentType: aValue
	argumentType := aValue.!

forzeType: aValue
	operation := aValue.!

operationPrivate: aValue
	| aPrevValue |
	(operation isNil and: [ aValue isNil]) ifTrue: [ ^self].
	aPrevValue := operation.
	operation := aValue.
	self changed: #operation.
	(operation isNil and: [ aPrevValue isNil not]) ifTrue: [ self release].! !

!CODEArgument publicMethodsFor: 'associations testing'!

argumentRefinementsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^argumentRefinements isNil
		ifTrue: [false]
		ifFalse: [self argumentRefinements includes: aValue]!

argumentRefinementsSize
	"Generated by ISF/AD. Do not modify"
	^argumentRefinements isNil
		ifTrue: [0]
		 ifFalse: [argumentRefinements size]! !

!CODEArgument publicMethodsFor: 'cache invalidation'!

invalidateEffectiveOperationsCaches
	
	| aOperation |

	aOperation := self type.
	aOperation isNil ifTrue:  [ ^self].

	aOperation invalidateEffectiveOperationsCaches! !

!CODEArgument publicMethodsFor: 'derivation expressions'!

argumentSignatureAttribute
	
	| anArgumentAttribute anArgumentAttributeName anOperationType |

	anArgumentAttributeName := self argumentSignatureAttributeName.
	(anArgumentAttributeName isNil or: [ anArgumentAttributeName isEmpty]) ifTrue: [ ^nil].

	anOperationType := self operationSignatureType.
	anOperationType isNil ifTrue: [ ^nil].

	anArgumentAttribute := anOperationType effectiveFeatureNamed: anArgumentAttributeName.
	^anArgumentAttribute!

argumentSignatureAttributeName
	^self name, self class argumentSignatureAttributeNamePostfix.!

candidateFactoryTypes
	
	| anArgumentSignatureAttribute |

	anArgumentSignatureAttribute := self argumentSignatureAttribute.
	anArgumentSignatureAttribute isNil ifTrue: [ ^nil].

	^anArgumentSignatureAttribute candidateFactoryTypes!

candidatePathAllowsCreate
	
	| anArgumentSignatureAttribute |

	anArgumentSignatureAttribute := self argumentSignatureAttribute.
	anArgumentSignatureAttribute isNil ifTrue: [ ^nil].

	^anArgumentSignatureAttribute candidatePathAllowsCreate!

candidateRelatedObjects: theObject
	
	| anArgumentSignatureAttribute |

	anArgumentSignatureAttribute := self argumentSignatureAttribute.
	anArgumentSignatureAttribute isNil ifTrue: [ ^nil].

	^anArgumentSignatureAttribute candidateRelatedObjects: theObject! !

!CODEArgument publicMethodsFor: 'derived accessing'!

allRefinedArgumentsInto: theSet

	(theSet includes: self) ifTrue: [ ^self].

	theSet add: self.!

configurationClassClassForInstances
	^self operation isNil 
		ifTrue: [ nil]
		ifFalse: [ self operation configurationClassClassForInstances]!

fullyQualifiedName

	| aFullyQualifiedName aOperationFullyQualifiedName |
	self operation isNil ifTrue: [ ^self name].
	
	aOperationFullyQualifiedName := self operation fullyQualifiedName.
	(aOperationFullyQualifiedName isNil or: [ aOperationFullyQualifiedName isEmpty]) ifTrue: [ 
		^self name
	].

	aFullyQualifiedName := aOperationFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

hasIdCounter

	| aNonVirtualType aArgumentType |

	self isExclussion ifTrue: [ ^false].
	self maxMult = self class maxMultNone ifTrue: [ ^false].

	aArgumentType := self argumentType.
	aArgumentType isNil ifTrue: [ ^false].

	aNonVirtualType := aArgumentType nonVirtualType.
	aNonVirtualType isNil  ifTrue: [ ^false].

	^self isIDArgument 
		ifTrue: [ aNonVirtualType isIDCompatible ]
		ifFalse: [ 
			aNonVirtualType isPrimitive not and:  [ 
				aArgumentType hasIdCounter
			]
		]!

hasOrTypeHasAspectNamed: theAspectName

	| aArgumentType |
	(theAspectName isNil or: [ theAspectName]) isEmpty ifTrue: [ ^false].

	(self aspectNamed: theAspectName) isNil ifFalse: [ ^true].
	
	aArgumentType := self argumentType.
	aArgumentType isNil ifTrue: [ ^false].

	(aArgumentType aspectNamed: theAspectName) isNil ifFalse: [ ^true].

	^false!

isVisibleInModules: 		theModules
	andAspects: 			theAspects
	definitionsHolder: 	theDefinitionsHolder

	((theModules isNil or: [ theModules isEmpty]) and: [  
		theAspects isNil or: [ theAspects isEmpty]]) ifTrue: [ 
		^true
	].

	^(  self isVisibleInModules: 	theModules definitionsHolder: 	theDefinitionsHolder) and: [ 
		self isVisibleInAspects: 	theAspects definitionsHolder: 	theDefinitionsHolder
	]!

isVisibleInModules: 		theModules
	definitionsHolder: 	theDefinitionsHolder


	| aThisModule |

	(theModules isNil or: [ theModules isEmpty]) ifTrue: [ ^true ].

	(theModules isNil not and: [ theModules isEmpty not]) ifTrue: [ 
		aThisModule := self module.
		aThisModule isNil ifTrue: [ ^false].
		(theModules includes: aThisModule) ifFalse: [ 
			(theModules detect: [:aModule | aModule includesModule: aModule] ifNone: [ nil]) isNil ifTrue: [ ^false]
		]
	].!

model
	^self operation isNil 
		ifTrue: [ nil]
		ifFalse: [ self operation model]!

module
	^self operation isNil 
		ifTrue: [ nil]
		ifFalse: [ self operation module]!

referencedType
	^self argumentType!

requiresIdCounter

	| aNonVirtualType aArgumentType |

	self isExclussion ifTrue: [ ^false].
	self maxMult = self class maxMultNone ifTrue: [ ^false].

	self computationKind = self  computationKindFromHomeIDCounter ifFalse: [ ^false].

	aArgumentType := self argumentType.
	aArgumentType isNil ifTrue: [ ^false].

	aNonVirtualType := aArgumentType nonVirtualType.
	aNonVirtualType isNil  ifTrue: [ ^false].

	^self isIDArgument 
		ifTrue: [ aNonVirtualType isIDCompatible ]
		ifFalse: [ 
			aNonVirtualType isPrimitive not and:  [ 
				aArgumentType requiresIdCounter
			]
		]!

withAllRefinedArguments
	| someArguments |
	someArguments := IdentitySet new: 13.
	self withAllRefinedArgumentsInto: someArguments.
	
	^someArguments!

withAllRefinedArgumentsInto: theArguments

	theArguments isNil ifTrue: [ ^self].
	(theArguments includes: self) ifTrue: [ ^self]. 
	theArguments add: self.! !

!CODEArgument publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self operation isNil ifFalse: [ self operation markDirtyOwner]
	].!

persistIfDirty
	^self operation isNil ifFalse: [ self operation persistIfDirty] ifTrue: [ nil]! !

!CODEArgument publicMethodsFor: 'initialize-release'!

initCandidatesConstraint
	candidatesConstraint := ''!

initCandidatesPath
	candidatesPath := ''!

initComputationKind
	computationKind := self class computationKindNoComputation!

initInitializationExpression
	initializationExpression := '' copy!

initIsChangeable
	isChangeable := true!

initIsDuplicatesAllowed
	isDuplicatesAllowed := false!

initIsExclussion
	isExclussion := false!

initIsIDArgument
	isIDArgument := false!

initIsInitializationPropagationAllowed
	isInitializationPropagationAllowed := true!

initIsInitializationPropagationOnConnectAllowed
	isInitializationPropagationOnConnectAllowed := true!

initMaxMult
	maxMult := self class maxMultOne!

initMinMult
	"Generated by ISF/AD. Do not modify"
	minMult := self class minMultRequired!

initOrderConstraint
	orderConstraint := '' copy!

initTerminalMetaAttributesFrom: theArgument
	theArgument isNil ifTrue: [ ^self].
	(theArgument isKindOf: CODEArgument) ifFalse: [ ^self].

	self minMult: 						theArgument minMult copy.
	self maxMult: 					theArgument maxMult copy.
	self isExclussion: 				theArgument isExclussion == true.
	self isIDArgument: 				theArgument isIDArgument == true.
	self isChangeable: 				theArgument isChangeable == true.
	self isDuplicatesAllowed: 		theArgument isDuplicatesAllowed == true.
	self computationKind: 			theArgument computationKind copy.
	self orderConstraint: 			theArgument orderConstraint copy.
	self candidatesPath: 			theArgument candidatesPath copy.
	self candidatesConstraint: 	theArgument candidatesConstraint copy.
	self initializationExpression: 	theArgument initializationExpression copy.
	self valueConstraint: 			theArgument valueConstraint copy.!

initValueConstraint
	valueConstraint := ''!

release
	self changed: #objectDisconnectedOfTree.

	self argumentTypeRelease.

	self operationRelease.

	super release! !

!CODEArgument publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aSep anOperation |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	anOperation := self operation.

	anOperation isNil  ifFalse: [  anOperation allQualifiedNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

asReferenceArray

	| anOperation anOperationReferenceArray |

	anOperation := self operation.
	anOperationReferenceArray := anOperation isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ anOperation asReferenceArray].

	^Array with: self class refToArgumentKindSymbol with: self name with: anOperationReferenceArray!

asReferenceAsCodeStringNOCROn: theStream

	| aSep anOperation |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	anOperation := self operation.

	theStream nextPutAll: ' ( ';  nextPutAll: (self pcForV: self class refToArgumentKindSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	anOperation isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [  anOperation asReferenceAsCodeStringNOCROn: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAsCodeStringNOCROn: theStream. 
	theStream cr.!

firstPersistenceIndexArgument
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexArgument.

	self forzeMinMult:						(theValues size < (aFPI + 0) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 0)]). 
	self forzeMaxMult:						(theValues size < (aFPI + 1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 1)]). 
	self forzeIsExclussion:					(theValues size < (aFPI + 2) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 2)]). 
	self forzeIsIDArgument:				(theValues size < (aFPI + 3) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 3)]). 
	self forzeIsChangeable:				(theValues size < (aFPI + 4) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +4)]). 
	self forzeIsDuplicatesAllowed:		(theValues size < (aFPI + 5) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +5)]). 
	self forzeIsInitializationPropagationAllowed:	(theValues size < (aFPI +6) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +6)]). 
	self forzeIsInitializationPropagationOnConnectAllowed:	(theValues size < (aFPI +7) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +7)]). 
	self forzeComputationKind:			(theValues size < (aFPI +8) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +8)]). 
	self forzeOrderConstraint:				(theValues size < (aFPI +9) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 9)]). 
	self forzeCandidatesPath:				(theValues size < (aFPI + 10) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 01)]). 
	self forzeCandidatesConstraint:		(theValues size < (aFPI + 11) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 11)]). 
	self forzeInitializationExpression:		(theValues size < (aFPI + 12) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 12)]). 
	self forzeValueConstraint:				(theValues size < (aFPI + 13) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 13)]). 

	theValues size < (aFPI + 14) ifFalse: [  self initReferencedArgumentTypeFromValues:  (theValues at: (aFPI + 14))  ].!

initReferencedArgumentTypeFromValues: theValues
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refToArgumentTypeKindSymbol ifFalse: [ ^nil].

	argumentTypeRefTmpValues := theValues.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep aArgumentType |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS; nextPutAll: (self pcForV:  self minMult );  nextPutAll: aSep;
		nextPutAll: (self pcForV:  self maxMult ); cr;
		nextPutAll: (self pcForV:  self isExclussion ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isIDArgument );  nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isChangeable ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isDuplicatesAllowed ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isInitializationPropagationAllowed ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isInitializationPropagationOnConnectAllowed ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self computationKind); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self orderConstraint ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self candidatesPath );cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self candidatesConstraint ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self initializationExpression ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self valueConstraint ); cr.

	aArgumentType := self argumentType.
	aArgumentType isNil  
		ifTrue: [ theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil)] 
		ifFalse: [  
			aArgumentType asReferenceAsCodeStringOn:  theStream indent: anIS]. 
	
	theStream cr.!

numberPersistenceEntriesArgument
	^15!

ph2InitFromSolver: theSolver
	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedArgumentTypeFromSolver: theSolver!

ph2InitReferencedArgumentTypeFromSolver: theSolver
	
	| aType |

	(argumentTypeRefTmpValues isNil or: [ argumentTypeRefTmpValues isEmpty]) ifTrue: [ ^nil].

	argumentTypeRefTmpValues first = self class refToArgumentTypeKindSymbol ifFalse: [ ^nil].
	
	aType := CODEElement resolveOrNewReferencedTypeFromPersistenceAsCode:  argumentTypeRefTmpValues  solver: theSolver.
	aType isNil ifFalse: [ 
		self forzeArgumentType: aType.
		aType typeOfArgumentsPrivate add: self].

	argumentTypeRefTmpValues := nil! !

!CODEArgument publicMethodsFor: 'semantic checking'!

checkArgumentRefinementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkArgumentRefinementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkArgumentType: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCandidatesConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCandidatesPath: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkComputationKind: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkInitializationExpression: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsChangeable: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsDuplicatesAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsIDArgument: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsInitializationPropagationAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsInitializationPropagationOnConnectAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMaxMult: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMinMult: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOrderConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkType: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkValueConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEArgument publicMethodsFor: 'semantic links'!

argumentRefinementsCandidates
	"Generated by ISF/AD. Do not modify"
	^self argumentRefinements asArray!

argumentRefinementsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEArgument new!

argumentRefinementsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self argumentRefinementsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self argumentRefinementsAdd: anObject]!

argumentRefinementsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self argumentRefinementsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self argumentRefinementsAdd: anObject.!

argumentRefinementsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self argumentRefinementsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self argumentRefinementsCreate class
		ifUnchanged: [^self].
	self argumentRefinementsAdd: anObject!

argumentRefinementsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

argumentTypeCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

argumentTypeLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self argumentTypeCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self argumentType: anObject]!

argumentTypeLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self argumentTypeCandidates
		initially: self argumentType
		label: 'Select Or Create ...'
		class: self argumentTypeCreate class
		ifUnchanged: [^self].
	self argumentType: anObject!

argumentTypeScope
	"Generated by ISF/AD. Do not modify"
	^nil!

maxMultCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self maxMult!

maxMultCreate
	"Generated by ISF/AD. Do not modify"
	^''!

maxMultLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self maxMult: self maxMultCreate.!

maxMultLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self maxMultCandidates
		initially: self maxMult
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self maxMult: anObject.!

maxMultLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self maxMultCandidates
		initially: self maxMult
		label: 'Select Or Create ...'
		class: self maxMultCreate class
		ifUnchanged: [^self].
	self maxMult: anObject!

maxMultScope
	"Generated by ISF/AD. Do not modify"
	^nil!

minMultCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self minMult!

minMultCreate
	"Generated by ISF/AD. Do not modify"
	^''!

minMultLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self minMult: self minMultCreate.!

minMultLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self minMultCandidates
		initially: self minMult
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self minMult: anObject.!

minMultLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self minMultCandidates
		initially: self minMult
		label: 'Select Or Create ...'
		class: self minMultCreate class
		ifUnchanged: [^self].
	self minMult: anObject!

minMultScope
	"Generated by ISF/AD. Do not modify"
	^nil!

operationCandidates
	"Generated by ISF/AD. Do not modify"
	^self operation isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self operation]!

operationCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

operationLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self operationCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self operation: anObject]!

operationLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self operationCandidates
		initially: self operation
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self operation: anObject.!

operationLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self operationCandidates
		initially: self operation
		label: 'Select Or Create ...'
		class: self operationCreate class
		ifUnchanged: [^self].
	self operation: anObject!

operationScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEArgument publicMethodsFor: 'semantic links-custom'!

argumentTypeCandidates
	self operation isNil ifTrue: [ ^nil].
	^self operation model allTypes!

argumentTypeLinkSelect

	| someTypes aSelectedType anInitialSelection aLowercaseArgumentName aMatchingType aMaxScore aSimilarType |

	someTypes := self argumentTypeCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as ArgumentType of Argument\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	anInitialSelection := self argumentType.
	anInitialSelection isNil ifTrue: [ 
		aLowercaseArgumentName := self name asLowercase.
		aMatchingType := someTypes detect: [:aType | aType name asLowercase = aLowercaseArgumentName] ifNone: [ nil].
		aMatchingType isNil
			ifFalse: [ anInitialSelection := aMatchingType]
			ifTrue: [ 
				aMaxScore := -1.
				aSimilarType := nil.
				someTypes do: [:aType |   | aScore |
					aScore := aType name spellAgainst: aLowercaseArgumentName.
					aScore > aMaxScore ifTrue: [ aSimilarType := aType]
				].
				aSimilarType isNil ifFalse: [  aMatchingType := aSimilarType].
			]
	].
	aSelectedType := Dialog 
		choose: ('	Please, select a Type as ArgumentType of Argument	\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ')']]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil]
		initialSelection: anInitialSelection.
	aSelectedType isNil ifTrue: [ ^nil].

	self argumentType: aSelectedType.

	^aSelectedType! !

!CODEArgument publicMethodsFor: 'testing'!

isMultiplicityMany
	^self maxMult = self class maxMultMany or: [ self maxMult = self class maxMultTwo]!

isMultiplicityNone
	^self maxMult = self class maxMultNone!

isMultiplicityOne
	^self maxMult = self class maxMultOne!

isOrdered
	^self isSorted not!

isSorted
	^self orderConstraint isNil not and:  [  self orderConstraint isEmpty not and: [ self orderConstraint asArrayOfSubstrings isEmpty not]]! !

!CODEArgumentRefinement class publicMethodsFor: 'accessing'!

kind
	^#argumentRefinement! !

!CODEArgumentRefinement class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		 self modelEditorMETAPerspectivesArgumentRefinement, super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesArgumentRefinement
 
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RefinedArguments'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'RefinedArguments' )))
			nlsApp: 'CODE';
			nlsGroup: 'ArgumentRefinement_Perspectives';
			nlsItem: 'RefinedArguments';
			nlsTranslation: 'ArgumentosOriginales';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsArgumentRefinement!

modelEditorMETASelectorsArgumentRefinement

	"METAChildSpecAutoViewEditor openOn: CODEArgument selector: #modelEditorMETASelectorsArgumentRefinement target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 8)
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RefinedArguments';
			basicSelector: #refinedArguments;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'RefinedArguments';
			displaySelector: #name;
			componentsClassName: #CODEArgument;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'ArgumentRefinement_Selectors';
			nlsItem: 'RefinedArguments';
			nlsTranslation: 'ArgumentosOriginales';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsArgumentRefinement.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: super modelEditorPathSelectors metaSelectorsToSelect, aLocalView metaSelectorsToSelect!

modelEditorPathSelectorsArgumentRefinement

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('RefinedArguments' )! !

!CODEArgumentRefinement publicMethodsFor: 'association initialize-release'!

initRefinedArguments
	"Generated by ISF/AD. Do not modify"
	refinedArguments := OrderedCollection new.!

refinedArgumentsRelease
	"Generated by ISF/AD. Do not modify"
	self refinedArguments do: [:each | self refinedArgumentsRemove: each]! !

!CODEArgumentRefinement publicMethodsFor: 'associations accessing'!

refinedArguments
	"Generated by ISF/AD. Do not modify"
	^self refinedArgumentsPrivate copy!

refinedArgumentsAsArray
	"Generated by ISF/AD. Do not modify"
	^self refinedArguments asArray! !

!CODEArgumentRefinement publicMethodsFor: 'associations modifying'!

refinedArgumentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRefinedArgumentsAdd: aValue) ifFalse: [^aValue].
	(self refinedArgumentsIncludes: aValue) ifTrue: [^aValue].
	(self refinedArgumentsPrivateAdd: aValue) argumentRefinementsPrivateAdd: self.
	self invalidateEffectiveOperationsCaches.

	self changed: #refinedArguments.

	^aValue!

refinedArgumentsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self refinedArgumentsIncludes: aValue) ifFalse: [^aValue].
	(self refinedArguments indexOf: aValue) = self refinedArgumentsSize ifTrue: [^aValue].
	self refinedArgumentsPrivate remove: aValue.
	aRes := self refinedArgumentsPrivateAdd: aValue.
	self invalidateEffectiveOperationsCaches.
	^aRes!

refinedArgumentsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self refinedArgumentsIncludes: aValue) ifFalse: [^aValue].
	(index := self refinedArguments indexOf: aValue) = self refinedArgumentsSize ifTrue: [^aValue].
	index = (self refinedArgumentsSize -1)
		ifTrue:
			[self refinedArgumentsPrivate remove: aValue.
			aRes := self refinedArgumentsPrivateAdd: aValue.
			self notifyChangeAllRefinedArgumentsChildSpecs.
			^aRes].
	aRes := self refinedArgumentsPrivateMove: aValue beforeIndex: index + 2.
	self invalidateEffectiveOperationsCaches.
	^aRes!

refinedArgumentsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self refinedArgumentsIncludes: aValue) ifFalse: [^aValue].
	(self refinedArguments indexOf: aValue) = 1 ifTrue: [^aValue].
	self refinedArgumentsPrivateMove: aValue beforeIndex: 1.
	self invalidateEffectiveOperationsCaches.!

refinedArgumentsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self refinedArgumentsIncludes: aValue) ifFalse: [^aValue].
	(index := self refinedArguments indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self refinedArgumentsPrivateMove: aValue beforeIndex: index - 1.
	self invalidateEffectiveOperationsCaches.
	^aRes!

refinedArgumentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRefinedArgumentsRemove: aValue) ifFalse: [^aValue].
	(self refinedArgumentsPrivate remove: aValue ifAbsent: [^aValue]) argumentRefinementsPrivateRemove: self.
	self invalidateEffectiveOperationsCaches.
	self changed: #refinedArguments.

	^aValue! !

!CODEArgumentRefinement publicMethodsFor: 'associations private'!

refinedArgumentsPrivate
	"Generated by ISF/AD. Do not modify"
	refinedArguments isNil
		ifTrue: [self initRefinedArguments].
	^refinedArguments!

refinedArgumentsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self refinedArgumentsPrivate add: aValue.
	self changed: #refinedArguments.
	^aValue!

refinedArgumentsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self refinedArguments at: anIndex.
	self refinedArgumentsPrivate remove: aValue.
	self refinedArgumentsPrivate add: aValue before: obj.
	self changed: #refinedArguments.
	^aValue!

refinedArgumentsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self refinedArgumentsPrivate remove: aValue.
	self changed: #refinedArguments.
	^aValue! !

!CODEArgumentRefinement publicMethodsFor: 'associations testing'!

refinedArgumentsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^refinedArguments isNil
		ifTrue: [false]
		ifFalse: [self refinedArguments includes: aValue]!

refinedArgumentsSize
	"Generated by ISF/AD. Do not modify"
	^refinedArguments isNil
		ifTrue: [0]
		 ifFalse: [refinedArguments size]! !

!CODEArgumentRefinement publicMethodsFor: 'derived accessing'!

allRefinedArguments

	| someArguments |
	someArguments := IdentitySet new: 13.
	self allRefinedArgumentsInto: someArguments.
	^someArguments!

allRefinedArgumentsInto: theSet

	(theSet includes: self) ifTrue: [ ^self].

	theSet add: self.

	self refinedArguments do: [:anArgument |  anArgument allRefinedArgumentsInto: theSet]!

withAllRefinedArgumentsInto: theArguments

	theArguments isNil ifTrue: [ ^self].
	(theArguments includes: self) ifTrue: [ ^self]. 
	theArguments add: self.
	self refinedArgumentsPrivate do: [:aArgument |
		aArgument withAlllRefinedArgumentsInto: theArguments
	].! !

!CODEArgumentRefinement publicMethodsFor: 'initialize-release'!

release
	self changed: #objectDisconnectedOfTree.	
	self refinedArgumentsRelease.

	super release.! !

!CODEArgumentRefinement publicMethodsFor: 'persistence-code'!

firstPersistenceIndexArgumentRefinement
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		self numberPersistenceEntriesArgument  +
		1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexArgumentRefinement.

	theValues size < aFPI ifFalse: [  self initReferencedRefinedArgumentsFromValues:  (theValues at: aFPI) ].!

initReferencedRefinedArgumentsFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refinedArgumentsPersistenceSymbol ifFalse: [ ^nil].

	refinedArgumentsRefTmpValues := theValues.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	self referencedRefinedArgumentAsCodeStringOn: theStream indent: theIS.!

numberPersistenceEntriesArgumentRefinement
	^1!

ph2InitFromSolver: theSolver

	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedRefinedArgumentsValuesFromSolver: theSolver.!

ph2InitReferencedRefinedArgumentsValuesFromSolver: theSolver
	
	| someArguments |

	(refinedArgumentsRefTmpValues isNil or: [ refinedArgumentsRefTmpValues isEmpty]) ifTrue: [ ^self].

	someArguments := 
		CODEElement resolveOrNewReferencedArgumentsCollectionFromPersistenceAsCode: refinedArgumentsRefTmpValues  solver: theSolver.
	self refinedArgumentsPrivate  addAll: someArguments.
	someArguments do: [:aC | aC argumentRefinementsPrivate add: self].

	refinedArgumentsRefTmpValues := nil!

referencedRefinedArgumentAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	theStream isNil ifTrue: [ ^self]. 


	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self refinedArgumentsPrivate isNil not and: [ self refinedArgumentsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class refinedArgumentsPersistenceSymbol); cr
			].
			self refinedArgumentsPrivate do:  [:anArgument |
				anArgument asReferenceAsCodeStringOn: theStream 
					indent: anIS , self indentStringForPersistenceAsCode
			].

			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].! !

!CODEArgumentRefinement publicMethodsFor: 'semantic checking'!

checkRefinedArgumentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRefinedArgumentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEArgumentRefinement publicMethodsFor: 'semantic links'!

refinedArgumentsCandidates
	"Generated by ISF/AD. Do not modify"
	^self refinedArguments asArray!

refinedArgumentScope
	"Generated by ISF/AD. Do not modify"
	^nil!

refinedArgumentsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEArgument new!

refinedArgumentsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self refinedArgumentsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self refinedArgumentsAdd: anObject.!

refinedArgumentsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self refinedArgumentsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self refinedArgumentsCreate class
		ifUnchanged: [^self].
	self refinedArgumentsAdd: anObject!

refinedArgumentsScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEArgumentRefinement publicMethodsFor: 'semantic links-custom'!

refinedArgumentsLinkCreate

	^nil! !

!CODEArgumentRefinement publicMethodsFor: 'testing'!

isRefinement
	^true! !

!CODEAspect class publicMethodsFor: 'accessing'!

kind
	^#aspect! !

!CODEAspect class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEAspect class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^ self modelEditorMETAPerspectivesAspect,  super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesAspect

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AppliedToElements'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'AppliedToElements' )))
			nlsApp: 'CODE';
			nlsGroup: 'Aspect_Perspectives';
			nlsItem: 'AppliedToElements';
			nlsTranslation: 'AplicadoToElementos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AspectDefiner'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'AspectDefiner')))
			nlsApp: 'CODE';
			nlsGroup: 'Aspect_Perspectives';
			nlsItem: 'AspectDefiner';
			nlsTranslation: 'DefinidoEnElemento';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsAspect!

modelEditorMETASelectorsAspect

	"METAChildSpecAutoViewEditor openOn: CODEAspect selector: #modelEditorMETASelectorsAspect target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AppliedToElements';
			basicSelector: #appliedToElements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AppliedToElements';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAspectuatedElement;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Aspect_Selectors';
			nlsItem: 'AppliedToElements';
			nlsTranslation: 'AplicadoAElementos';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AspectDefiner';
			basicSelector: #aspectDefiner;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AspectDefiner';
			displaySelector: #name;
			objectClassName: #CODEAspectuatedElement;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Aspect_Selectors';
			nlsItem: 'AspectDefiner';
			nlsTranslation: 'DefinidoEnElemento';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsAspect.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsAspect

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('AppliedToElements' 'AspectDefiner')! !

!CODEAspect publicMethodsFor: 'association initialize-release'!

appliedToElementsRelease
	"Generated by ISF/AD. Do not modify"
	self appliedToElements do: [:each | self appliedToElementsRemove: each]!

aspectDefinerRelease
	"Generated by ISF/AD. Do not modify"
	aspectDefiner == nil
		ifFalse:
			[aspectDefiner aspectsPrivateRemove: self.
				aspectDefiner := nil.
				self changed: #aspectDefiner]!

initAppliedToElements

   appliedToElements := OrderedCollection new! !

!CODEAspect publicMethodsFor: 'associations accessing'!

appliedToElements
	"Generated by ISF/AD. Do not modify"
	^self appliedToElementsPrivate copy!

appliedToElementsAsArray
	"Generated by ISF/AD. Do not modify"
	^self appliedToElements asArray!

aspectDefiner
	"Generated by ISF/AD. Do not modify"
	^aspectDefiner!

aspectDefiner: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkElement: aValue) ifFalse: [^aValue].
	aspectDefiner == aValue ifTrue: [ ^self].
	self aspectDefinerRelease.
	aspectDefiner := aValue.
	aValue == nil ifFalse: [aValue aspectsPrivateAdd: self].
	self changed: #aspectDefiner! !

!CODEAspect publicMethodsFor: 'associations modifying'!

appliedToElementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAppliedToElementsAdd: aValue) ifFalse: [^aValue].
	(self appliedToElementsIncludes: aValue) ifTrue: [^aValue].
	(self appliedToElementsPrivateAdd: aValue) aspectsPrivateAdd: self.
	self changed: #appliedToElements.

	^aValue!

appliedToElementsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self appliedToElementsIncludes: aValue) ifFalse: [^aValue].
	(self appliedToElements indexOf: aValue) = self appliedToElementsSize ifTrue: [^aValue].
	self appliedToElementsPrivate remove: aValue.
	aRes := self appliedToElementsPrivateAdd: aValue.
	^aRes!

appliedToElementsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self appliedToElementsIncludes: aValue) ifFalse: [^aValue].
	(index := self appliedToElements indexOf: aValue) = self appliedToElementsSize ifTrue: [^aValue].
	index = (self appliedToElementsSize -1)
		ifTrue:
			[self appliedToElementsPrivate remove: aValue.
			aRes := self appliedToElementsPrivateAdd: aValue.
			self notifyChangeAllAppliedToElementsChildSpecs.
			^aRes].
	aRes := self appliedToElementsPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

appliedToElementsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self appliedToElementsIncludes: aValue) ifFalse: [^aValue].
	(self appliedToElements indexOf: aValue) = 1 ifTrue: [^aValue].
	self appliedToElementsPrivateMove: aValue beforeIndex: 1.!

appliedToElementsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self appliedToElementsIncludes: aValue) ifFalse: [^aValue].
	(index := self appliedToElements indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self appliedToElementsPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

appliedToElementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAppliedToElementsRemove: aValue) ifFalse: [^aValue].
	(self appliedToElementsPrivate remove: aValue ifAbsent: [^aValue]) aspectsPrivateRemove: self.
	self changed: #appliedToElements.

	^aValue! !

!CODEAspect publicMethodsFor: 'associations private'!

appliedToElementsPrivate
	"Generated by ISF/AD. Do not modify"
	appliedToElements isNil
		ifTrue: [self initAppliedToElements].
	^appliedToElements!

appliedToElementsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self appliedToElementsPrivate add: aValue.
	self changed: #appliedToElements.
	^aValue!

appliedToElementsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self appliedToElements at: anIndex.
	self appliedToElementsPrivate remove: aValue.
	self appliedToElementsPrivate add: aValue before: obj.
	self changed: #appliedToElements.
	^aValue!

appliedToElementsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self appliedToElementsPrivate remove: aValue.
	self changed: #appliedToElements.
	^aValue!

aspectDefinerPrivate: aValue
	| aPrevValue |
	aPrevValue := aspectDefiner.
	aspectDefiner := aValue.
	self changed: #aspectDefiner.
	(aspectDefiner isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

forzeAppliedToElements: theAppliedToElements
	(theAppliedToElements isNil or: [ theAppliedToElements isEmpty]) ifTrue: [ ^self].
	self appliedToElementsPrivate addAll: theAppliedToElements.! !

!CODEAspect publicMethodsFor: 'associations testing'!

appliedToElementsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^appliedToElements isNil
		ifTrue: [false]
		ifFalse: [self appliedToElements includes: aValue]!

appliedToElementsSize
	"Generated by ISF/AD. Do not modify"
	^appliedToElements isNil
		ifTrue: [0]
		 ifFalse: [appliedToElements size]! !

!CODEAspect publicMethodsFor: 'derived accessing'!

applicationConfiguration
	^self aspectDefiner isNil ifTrue: [ nil] ifFalse: [ self aspectDefiner applicationConfiguration]!

model
	^self aspectDefiner isNil ifTrue: [ nil] ifFalse: [ self aspectDefiner model]! !

!CODEAspect publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self aspectDefiner isNil ifFalse: [ self aspectDefiner markDirtyOwner].
	].!

persistIfDirty
	^self aspectDefiner isNil ifFalse: [ self aspectDefiner persistIfDirty] ifTrue: [ nil].! !

!CODEAspect publicMethodsFor: 'initialize-release'!

release
	self changed: #objectDisconnectedOfTree.

	self aspectDefinerRelease.
	self appliedToElementsRelease.

	super release! !

!CODEAspect publicMethodsFor: 'persistence-code'!

asReferenceAsCodeStringNOCROn: theStream

	| aSep anAspectDefiner |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	anAspectDefiner := self aspectDefiner.

	theStream nextPutAll: ' ( ';  nextPutAll: (self pcForV: self class refToAspectKindSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	anAspectDefiner isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [ anAspectDefiner allQualifiedNamesInto: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAsCodeStringNOCROn: theStream. 
	theStream cr.!

firstPersistenceIndexAspect
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		1!

initFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	
	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.!

numberPersistenceEntriesAspect
	^0! !

!CODEAspect publicMethodsFor: 'semantic checking'!

checkAppliedToElementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkAppliedToElementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkElement: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkValue: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEAspect publicMethodsFor: 'semantic links'!

appliedToElementsCandidates
	"Generated by ISF/AD. Do not modify"
	^self appliedToElements asArray!

appliedToElementsCreate
	"Generated by ISF/AD. Do not modify"
	^CODERelationship new!

appliedToElementsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self appliedToElementsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self appliedToElementsAdd: anObject.!

appliedToElementsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self appliedToElementsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self appliedToElementsCreate class
		ifUnchanged: [^self].
	self appliedToElementsAdd: anObject!

appliedToElementsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

aspectDefinerCandidates
	"Generated by ISF/AD. Do not modify"
	^self aspectDefiner isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self aspectDefiner]!

aspectDefinerCreate
	"Generated by ISF/AD. Do not modify"
	^CODEElement new!

aspectDefinerLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self aspectDefinerCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self aspectDefiner: anObject]!

aspectDefinerLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self aspectDefinerCandidates
		initially: self aspectDefiner
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self aspectDefiner: anObject.!

aspectDefinerLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self aspectDefinerCandidates
		initially: self aspectDefiner
		label: 'Select Or Create ...'
		class: self aspectDefinerCreate class
		ifUnchanged: [^self].
	self aspectDefiner: anObject!

aspectDefinerScope
	"Generated by ISF/AD. Do not modify"
	^nil!

ownerElementCandidates
	"Generated by ISF/AD. Do not modify"
	^self ownerElement isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self ownerElement]!

ownerElementCreate
	"Generated by ISF/AD. Do not modify"
	^CODEElement new!

ownerElementLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self ownerElementCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self ownerElement: anObject]!

ownerElementLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self ownerElementCandidates
		initially: self ownerElement
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self ownerElement: anObject.!

ownerElementLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self ownerElementCandidates
		initially: self ownerElement
		label: 'Select Or Create ...'
		class: self ownerElementCreate class
		ifUnchanged: [^self].
	self ownerElement: anObject!

ownerElementScope
	"Generated by ISF/AD. Do not modify"
	^nil!

refinedRelationshipScope
	"Generated by ISF/AD. Do not modify"
	^nil!

valueCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self value!

valueCreate
	"Generated by ISF/AD. Do not modify"
	^''!

valueLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self value: self valueCreate.!

valueLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self valueCandidates
		initially: self value
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self value: anObject.!

valueLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self valueCandidates
		initially: self value
		label: 'Select Or Create ...'
		class: self valueCreate class
		ifUnchanged: [^self].
	self value: anObject!

valueScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEAspect publicMethodsFor: 'semantic links-custom'!

appliedToElementsLinkCreate

	| someTypes aSelectedType |

	someTypes := self refinedRelationshipCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as RefinedRelationship of Type\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a name < b name].

	aSelectedType := Dialog 
		choose: ('			Please, select a Type as RefinedRelationship of Type			\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType displayName ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	self appliedToElementsAdd: aSelectedType.

	^aSelectedType! !

!CODEAspectuatedElement class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		self modelEditorMETAPerspectivesAspectuatedElement, super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesAspectuatedElement

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'DefinedAspects'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'DefinedAspects' )))
			nlsApp: 'CODE';
			nlsGroup: 'AspectuatedElement_Perspectives';
			nlsItem: 'DefinedAspects';
			nlsTranslation: 'AspectosDefinidos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AppliedAspects'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'AppliedAspects' )))
			nlsApp: 'CODE';
			nlsGroup: 'AspectuatedElement_Perspectives';
			nlsItem: 'AppliedAspects';
			nlsTranslation: 'AspectosAplicados';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsAspectuatedElement!

modelEditorMETASelectorsAspectuatedElement

	"METAChildSpecAutoViewEditor openOn: CODEAttribute selector: #modelEditorMETASelectorsAttribute target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'DefinedAspects';
			basicSelector: #definedAspects;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'DefinedAspects';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAspect;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'AspectuatedElement_Selectors';
			nlsItem: 'DefinedAspects';
			nlsTranslation: 'AspectosDefinidos';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AppliedAspects';
			basicSelector: #aspects;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'AppliedAspects';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAspect;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'AspectuatedElement_Selectors';
			nlsItem: 'AppliedAspects';
			nlsTranslation: 'AspectosAplicados';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsAspectuatedElement.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsAspectuatedElement

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('DefinedAspects' 'AppliedAspects' )! !

!CODEAspectuatedElement publicMethodsFor: 'association initialize-release'!

aspectsRelease
	"Generated by ISF/AD. Do not modify"
	self aspects do: [:each | self aspectsRemove: each]!

definedAspectsRelease
	"Generated by ISF/AD. Do not modify"
	self definedAspects do: [:each | self definedAspectsRemove: each]!

initAspects
	"Generated by ISF/AD. Do not modify"
	aspects := OrderedCollection new.!

initDefinedAspects
	"Generated by ISF/AD. Do not modify"
	definedAspects := OrderedCollection new.! !

!CODEAspectuatedElement publicMethodsFor: 'associations accessing'!

aspects
	"Generated by ISF/AD. Do not modify"
	^self aspectsPrivate copy!

aspectsAsArray
	"Generated by ISF/AD. Do not modify"
	^self aspects asArray!

definedAspects
	"Generated by ISF/AD. Do not modify"
	^self definedAspectsPrivate copy!

definedAspectsAsArray
	"Generated by ISF/AD. Do not modify"
	^self definedAspects asArray! !

!CODEAspectuatedElement publicMethodsFor: 'associations modifying'!

aspectsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAspectsAdd: aValue) ifFalse: [^aValue].
	(self aspectsIncludes: aValue) ifTrue: [^aValue].
	(self aspectsPrivateAdd: aValue) appliedToElementsPrivateAdd: self.
	self changed: #aspects.

	^aValue!

aspectsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self aspectsIncludes: aValue) ifFalse: [^aValue].
	(self aspects indexOf: aValue) = self aspectsSize ifTrue: [^aValue].
	self aspectsPrivate remove: aValue.
	aRes := self aspectsPrivateAdd: aValue.
	^aRes!

aspectsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self aspectsIncludes: aValue) ifFalse: [^aValue].
	(index := self aspects indexOf: aValue) = self aspectsSize ifTrue: [^aValue].
	index = (self aspectsSize -1)
		ifTrue:
			[self aspectsPrivate remove: aValue.
			aRes := self aspectsPrivateAdd: aValue.
			self notifyChangeAllAspectsChildSpecs.
			^aRes].
	aRes := self aspectsPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

aspectsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self aspectsIncludes: aValue) ifFalse: [^aValue].
	(self aspects indexOf: aValue) = 1 ifTrue: [^aValue].
	self aspectsPrivateMove: aValue beforeIndex: 1.!

aspectsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self aspectsIncludes: aValue) ifFalse: [^aValue].
	(index := self aspects indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self aspectsPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

aspectsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAspectsRemove: aValue) ifFalse: [^aValue].
	(self aspectsPrivate remove: aValue ifAbsent: [^aValue]) appliedToElementsPrivateRemove: self.
	self changed: #aspects.

	^aValue!

definedAspectsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDefinedAspectsAdd: aValue) ifFalse: [^aValue].
	(self definedAspectsIncludes: aValue) ifTrue: [^self definedAspectsMoveBottom: aValue].
	(self definedAspectsPrivateAdd: aValue) aspectDefinerPrivate: self.
	self changed: #definedAspects.
	^aValue!

definedAspectsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	(self definedAspectsIncludes: aValue) ifFalse: [^aValue].
	(self definedAspects indexOf: aValue) = self definedAspectsSize ifTrue: [^aValue].
	self definedAspectsPrivate remove: aValue.
	^self definedAspectsPrivateAdd: aValue!

definedAspectsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self definedAspectsIncludes: aValue) ifFalse: [^aValue].
	(index := self definedAspects indexOf: aValue) = self definedAspectsSize ifTrue: [^aValue].
	index = (self definedAspectsSize -1)
		ifTrue:
			[self definedAspectsPrivate remove: aValue.
			^self definedAspectsPrivateAdd: aValue].
	^self definedAspectsPrivateMove: aValue beforeIndex: index + 2!

definedAspectsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self definedAspectsIncludes: aValue) ifFalse: [^aValue].
	(self definedAspects indexOf: aValue) = 1 ifTrue: [^aValue].
	self definedAspectsPrivateMove: aValue beforeIndex: 1!

definedAspectsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self definedAspectsIncludes: aValue) ifFalse: [^aValue].
	(index := self definedAspects indexOf: aValue) = 1 ifTrue: [^aValue].
	^self definedAspectsPrivateMove: aValue beforeIndex: index - 1!

definedAspectsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDefinedAspectsRemove: aValue) ifFalse: [^aValue].
	(self definedAspectsPrivate remove: aValue ifAbsent: [^aValue]) aspectDefinerPrivate: nil.
	self changed: #definedAspects.
	^aValue! !

!CODEAspectuatedElement publicMethodsFor: 'associations private'!

aspectsPrivate
	"Generated by ISF/AD. Do not modify"
	aspects isNil
		ifTrue: [self initAspects].
	^aspects!

aspectsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self aspectsPrivate add: aValue.
	self changed: #aspects.
	^aValue!

aspectsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self aspects at: anIndex.
	self aspectsPrivate remove: aValue.
	self aspectsPrivate add: aValue before: obj.
	self changed: #aspects.
	^aValue!

aspectsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self aspectsPrivate remove: aValue.
	self changed: #aspects.
	^aValue!

definedAspectsPrivate
	"Generated by ISF/AD. Do not modify"
	definedAspects isNil
		ifTrue: [self initDefinedAspects].
	^definedAspects!

definedAspectsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self definedAspectsPrivate add: aValue.
	self markDirty.

	self changed: #definedAspects.
	^aValue!

definedAspectsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self definedAspects at: anIndex.
	self definedAspectsPrivate remove: aValue.
	self definedAspectsPrivate add: aValue before: obj.
	self markDirty.

	self changed: #definedAspects.
	^aValue!

definedAspectsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self definedAspectsPrivate remove: aValue.
	self markDirty.

	self changed: #definedAspects.
	^aValue!

forzeAspects: theAspects
	(theAspects isNil or: [ theAspects isEmpty]) ifTrue: [ ^self].
	self aspectsPrivate addAll: theAspects.! !

!CODEAspectuatedElement publicMethodsFor: 'associations testing'!

aspectsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^aspects isNil
		ifTrue: [false]
		ifFalse: [self aspects includes: aValue]!

aspectsSize
	"Generated by ISF/AD. Do not modify"
	^aspects isNil
		ifTrue: [0]
		 ifFalse: [aspects size]!

definedAspectsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^definedAspects isNil
		ifTrue: [false]
		ifFalse: [self definedAspects includes: aValue]!

definedAspectsSize
	"Generated by ISF/AD. Do not modify"
	^definedAspects isNil
		ifTrue: [0]
		 ifFalse: [definedAspects size]! !

!CODEAspectuatedElement publicMethodsFor: 'derived accessing'!

allDefinedAspects
	| someAspects |
	someAspects := IdentitySet new: 111.
	self allDefinedAspectsInto: someAspects.
	^someAspects asSortedCollection: [:anAspect :otherAspect | anAspect name < otherAspect name]!

allDefinedAspectsInto: theSet
	theSet isNil ifTrue: [ ^self].

	theSet addAll: self definedAspects.!

aspectNamed: theAspectName
	
	| anExistingAspect |
	theAspectName isNil ifTrue: [ ^self].

	anExistingAspect := self aspectsPrivate detect: [:aAspect | aAspect name = theAspectName] ifNone: [ nil].
	^anExistingAspect!

definedAspectNamed: theAspectName
	
	| anExistingAspect |
	theAspectName isNil ifTrue: [ ^self].

	anExistingAspect := self definedAspectsPrivate detect: [:aAspect | aAspect name = theAspectName] ifNone: [ nil].
	^anExistingAspect!

isVisibleInAspects: 		theAspects
	definitionsHolder: 	theDefinitionsHolder

	| someAspects |

	(theAspects isNil or: [ theAspects isEmpty]) ifTrue: [ ^true ].

	someAspects := self aspects.
	^(someAspects detect: [:anAspect | theAspects includes: anAspect] ifNone: [ nil]) isNil not! !

!CODEAspectuatedElement publicMethodsFor: 'dirty'!

cleanDirtyMark
	super cleanDirtyMark.

	self definedAspects do: [:anAspect | anAspect cleanDirtyMark].! !

!CODEAspectuatedElement publicMethodsFor: 'initialize-release'!

release
	self changed: #objectDisconnectedOfTree.

	self definedAspectsRelease.
	self aspectsRelease.
	super release! !

!CODEAspectuatedElement publicMethodsFor: 'persistence-code'!

aspectsPersistenceAsCodeStringOn: theStream indent: theIS
		
	| anIS |
	anIS := theIS , self indentStringForPersistenceAsCode.

	theStream isNil ifFalse: [ 
		theStream 
		    	nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class aspectsPersistenceSymbol); cr; cr
	].
	self aspectsPrivate do:  [:anAspect |
		anAspect persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
	].
	theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr; cr]!

definedAspectsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self definedAspectsPrivate isNil not and: [ self definedAspectsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class definedAspectsPersistenceSymbol); cr
			].
			self definedAspectsPrivate do:  [:anAspect |
				anAspect persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

firstPersistenceIndexAspectuatedElement
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		1!

initAspectsFromValues: theValues 
	
	| someAspects |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someAspects := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someAspects isNil ifFalse: [ 
		self aspectsPrivate addAll: someAspects.
		someAspects do: [:aC | aC appliedToElementsPrivate add: self]]!

initDefinedAspectsFromValues: theValues 
	
	| someAspects |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someAspects := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someAspects isNil ifFalse: [ 
		self definedAspectsPrivate addAll: someAspects.
		someAspects do: [:aC | aC aspectDefinerPrivate: self]]!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexAspectuatedElement.

	theValues size < aFPI ifFalse: [  self initDefinedAspectsFromValues: (theValues at: aFPI) ].
	theValues size < (aFPI + 1) ifFalse: [  self initReferencedAspectsFromValues: (theValues at: (aFPI + 1)) ].!

initReferencedAspectsFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class aspectsPersistenceSymbol ifFalse: [ ^nil].

	aspectsRefsTmpValues := theValues.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	self definedAspectsPersistenceAsCodeStringOn: theStream indent: theIS.
	self referencedAspectsPersistenceAsCodeStringOn: theStream indent: theIS.!

numberPersistenceEntriesAspectuatedElement
	^2!

ph2InitFromSolver: theSolver
	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedAspectsValuesFromSolver: theSolver.!

ph2InitReferencedAspectsValuesFromSolver: theSolver
	
	| someAspects |

	(aspectsRefsTmpValues isNil or: [ aspectsRefsTmpValues isEmpty]) ifTrue: [ ^self].

	someAspects := 
		CODEElement resolveOrNewReferencedAspectsCollectionFromPersistenceAsCode: aspectsRefsTmpValues  solver: theSolver.

	someAspects isNil ifFalse: [ 
		self aspectsPrivate  addAll: someAspects.	
		someAspects do: [:anAspect | anAspect appliedToElementsPrivate add: self].
	].

	aspectsRefsTmpValues := nil!

referencedAspectsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self aspectsPrivate isNil not and: [ self aspectsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil); cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	    	 			nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class aspectsPersistenceSymbol); cr
			].
			self aspectsPrivate do:  [:anAspect |
				anAspect asReferenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

resolveOrNewReferencedAspectName: theName
	| anAspect |

	theName isNil ifTrue: [ ^nil].

	anAspect := self definedAspectNamed: theName.
	anAspect isNil ifFalse: [ ^anAspect].

	anAspect := self preferredAspectClass new name: theName.
	self definedAspectsAdd: anAspect.
	^anAspect! !

!CODEAspectuatedElement publicMethodsFor: 'semantic checking'!

checkAspectsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkAspectsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCommentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCommentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDefinedAspectsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDefinedAspectsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEAspectuatedElement publicMethodsFor: 'semantic links'!

aspectsCreate
	"Generated by ISF/AD. Do not modify"
	^CODERelationship new!

aspectsLinkCreate

	| someTypes aSelectedType |

	someTypes := self refinedRelationshipCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as RefinedRelationship of Type\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a name < b name].

	aSelectedType := Dialog 
		choose: ('			Please, select a Type as RefinedRelationship of Type			\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType displayName ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	self aspectsAdd: aSelectedType.

	^aSelectedType!

aspectsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self aspectsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self aspectsCreate class
		ifUnchanged: [^self].
	self aspectsAdd: anObject!

aspectsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

definedAspectsCandidates
	"Generated by ISF/AD. Do not modify"
	^self definedAspects asArray!

definedAspectsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

definedAspectsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self definedAspectsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self definedAspectsAdd: anObject]!

definedAspectsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self definedAspectsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self definedAspectsAdd: anObject.!

definedAspectsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self definedAspectsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self definedAspectsCreate class
		ifUnchanged: [^self].
	self definedAspectsAdd: anObject!

definedAspectsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

refinedRelationshipScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEAspectuatedElement publicMethodsFor: 'semantic links-custom'!

aspectsCandidates
	self model isNil ifTrue: [ ^nil].
	^(self model allDefinedAspects asSet - self aspects asSet) asSortedCollection: [:aA :aB | aA name < aB name]!

aspectsLinkSelect

	| someAspects aSelectedAspect |

	someAspects := self aspectsCandidates.
	(someAspects isNil or: [ someAspects isEmpty]) ifTrue: [ 
		Dialog warn: 'No Aspects in Model candidate as ValueAspect of Attribute\' withCRs, self name.
		^nil
	].

	someAspects := someAspects asSortedCollection: [:a :b | a name < b name].

	aSelectedAspect := Dialog 
		choose: ('Please, select an Aspect to apply to element	\', self kind, '  ' , self name) withCRs
		fromList: (someAspects collect: [:aAspect | 
			Object errorSignal
				handle: [:anException | anException returnWith: aAspect name]
				do: [ aAspect displayName ]]) 
		values: someAspects 
		lines: (((someAspects size + 1) max: 5) min: 18)
		cancel: [nil]
		initialSelection: nil.
	aSelectedAspect isNil ifTrue: [ ^nil].

	self aspectsAdd: aSelectedAspect.

	^aSelectedAspect! !

!CODEAttribute class publicMethodsFor: 'accessing'!

kind
	^#attribute! !

!CODEAttribute class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEAttribute class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^super modelEditorMETAPerspectives, self modelEditorMETAPerspectivesAttribute, 
			self modelEditorMETAPerspectivesTranslation, self modelEditorMETAPerspectivesConstraints!

modelEditorMETAPerspectivesAttribute

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ValueType'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'ValueType' )))
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Perspectives';
			nlsItem: 'ValueType';
			nlsTranslation: 'TipoDelValor';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Type'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Type' )))
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Perspectives';
			nlsItem: 'Type';
			nlsTranslation: 'Tipo';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AttributeRefinements'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'AttributeRefinements' )))
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Perspectives';
			nlsItem: 'AttributeRefinements';
			nlsTranslation: 'AtributosRefinados';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Dependencies'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Dependencies' )))
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Perspectives';
			nlsItem: 'Dependencies';
			nlsTranslation: 'Dependencias';
			yourself);
		yourself!

modelEditorMETAPerspectivesConstraints
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Constraints'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'IsNameAttribute' 'IsIDAttribute' 'IsExclussion'  'IsChangeable' 'IsDuplicatesAllowed' 'IsInitializationPropagationAllowed' 'IsInitializationPropagationOnConnectAllowed'  'ComputationKind' 'OrderConstraint' 'CandidatesPath' 'CandidatesConstraint' 'InitializationExpression' 'ValueConstraint' 'ReengineredInstVarName')))
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Perspectives';
			nlsItem: 'Constraints';
			nlsTranslation: 'Constricciones';
			yourself);
		yourself!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'IsDirty' 'IsAbstract'  'MinMult' 'MaxMult' 'ValueTypeName' 'ValueType'  'IsPropagateUse' 'IsJustUsed' 'IsRefinementRequired')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesTranslation
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Traducciones'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('NLSName' 'NLSKind' 'NLSNameOne'  'NLSAppName' 'NLSGroupName' 'NLSItemName' 'NLSItemNameOne')))
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Perspectives';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'Traducciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ItemTranslations'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('ItemTranslations')))
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Perspectives';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'ElementosDeTraduccion';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsAttribute,
		self modelEditorMETASelectorsTranslation, self modelEditorMETASelectorsMoreTranslation!

modelEditorMETASelectorsAttribute

	"METAChildSpecAutoViewEditor openOn: CODEAttribute selector: #modelEditorMETASelectorsAttribute target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MinMult';
			basicSelector: #minMult;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MinMult';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: '0 1 2 *';
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'MinMult';
			nlsTranslation: 'MinimoDeElementos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MaxMult';
			basicSelector: #maxMult;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MaxMult';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: '0 1 2 *';
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'MaxMult';
			nlsTranslation: 'MaximoDeElementos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPropagateUse';
			basicSelector: #isPropagateUse;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPropagateUse';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsPropagateUse';
			nlsTranslation: 'EsPropagacionDeUso';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsJustUsed';
			basicSelector: #isJustUsed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsJustUsed';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsJustUsed';
			nlsTranslation: 'EsSoloUsado';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsRefinementRequired';
			basicSelector: #isRefinementRequired;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsRefinementRequired';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsRefinementRequired';
			nlsTranslation: 'Requiere Especializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsNameAttribute';
			basicSelector: #isNameAttribute;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsNameAttribute';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsNameAttribute';
			nlsTranslation: 'EsNombre';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsIDAttribute';
			basicSelector: #isIDAttribute;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsIDAttribute';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsIDAttribute';
			nlsTranslation: 'EsIdentificador';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsChangeable';
			basicSelector: #isChangeable;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsChangeable';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsChangeable';
			nlsTranslation: 'EsModificable';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsDuplicatesAllowed';
			basicSelector: #isDuplicatesAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsDuplicatesAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsDuplicatesAllowed';
			nlsTranslation: 'PermiteDuplicados';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsInitializationPropagationAllowed';
			basicSelector: #isInitializationPropagationAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsInitializationPropagationAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsInitializationPropagationAllowed';
			nlsTranslation: 'PropagacionInitializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsInitializationPropagationOnConnectAllowed';
			basicSelector: #isInitializationPropagationOnConnectAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsInitializationPropagationOnConnectAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'IsInitializationPropagationOnConnectAllowed';
			nlsTranslation: 'PropagacionOnConnectInitializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ComputationKind';
			basicSelector: #computationKind;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ComputationKind';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: 'NOCOMPUTATION ALWAYS  INITIALVALUE INITIALIZEDINCONSTRUCTOR AFTERCONNECTION   FROMHOMEIDCOUNTER';
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'ComputationKind';
			nlsTranslation: 'ClaseDeComputacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'OrderConstraint';
			basicSelector: #orderConstraint;
			type: #String;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'OrderConstraint';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'OrderConstraint';
			nlsTranslation: 'ConstriccionDeOrden';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'CandidatesPath';
			basicSelector: #candidatesPath;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'CandidatesPath';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'CandidatesPath';
			nlsTranslation: 'CaminoACandidatos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'CandidatesConstraint';
			basicSelector: #candidatesConstraint;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'CandidatesConstraint';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'CandidatesConstraint';
			nlsTranslation: 'ConstriccionDeCandidatos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'InitializationExpression';
			basicSelector: #initializationExpression;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'InitializationExpression';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'InitializationExpression';
			nlsTranslation: 'ExpressionDeInicializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ValueConstraint';
			basicSelector: #valueConstraint;
			type: #String;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ValueConstraint';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'ValueConstraint';
			nlsTranslation: 'ConstriccionDeValor';
			yourself);
	add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ValueTypeName';
			basicSelector: #valueTypeName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ValueTypeName';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'ValueTypeName';
			nlsTranslation: 'NombreDelTipoDelValor';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ValueType';
			basicSelector: #valueType;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'ValueType';
			displaySelector: nil;
			objectClassName: #CODEType;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'ValueType';
			nlsTranslation: 'TipoDelValor';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReengineredInstVarName';
			basicSelector: #reengineredInstVarName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ReengineredInstVarName';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'ReengineredInstVarName';
			nlsTranslation: 'NombreDeVariable';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AttributeRefinements';
			basicSelector: #attributeRefinements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AttributeRefinements';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'AttributeRefinements';
			nlsTranslation: 'AtributosRefinados';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Type';
			basicSelector: #type;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'Type';
			displaySelector: #name;
			objectClassName: #CODEType;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'Type';
			nlsTranslation: 'Tipo';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Dependencies';
			basicSelector: #dependencies;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Dependencies';
			displaySelector: #displayName;
			canShowInTree: true;
			componentsClassName: #CMTypeDependency;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Attribute_Selectors';
			nlsItem: 'Dependencies';
			nlsTranslation: 'Dependencias';
			yourself);
		yourself!

modelEditorMETASelectorsMoreTranslation

	"METAChildSpecAutoViewEditor openOn: CODEElement selector: #modelEditorMETASelectorsTranslation target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSItemNameOne';
			basicSelector: #nameNLSItemNameOne;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSItemNameOne';
			nlsTranslation: 'NombreItemTraduccionSingular';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSNameOne';
			basicSelector: #nlsNameOne;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSNameOne';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSNameOne';
			nlsTranslation: 'TraduccionSingular';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsAttribute.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsAttribute

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('ValueType' 'AttributeRefinements' 'Type' 'Dependencies')! !

!CODEAttribute class publicMethodsFor: 'refinements'!

refinableMetaAttributeNames
	^#(
		#valueTypeName:
		#minMult:
		#maxMult:
		#isAbstract:
		#reengineredInstVarName:
		#isExclussion:
		#isNameAttribute:
		#isIDAttribute:
		#orderConstraint:
		#candidatesPath:
		#candidatesConstraint:
		#initializationExpression:
		#computationKind:
		#isChangeable:
		#isDuplicatesAllowed:
		#valueConstraint:
		#isInitializationPropagationAllowed:
		#isInitializationPropagationOnConnectAllowed:
	) copy! !

!CODEAttribute publicMethodsFor: 'accessing'!

candidatesConstraint
	candidatesConstraint isNil
		ifTrue: [self initCandidatesConstraint].
	^candidatesConstraint!

candidatesConstraint: aValue
	
	(self checkCandidatesConstraint: aValue) ifFalse: [^aValue].
	candidatesConstraint := aValue.
	self markDirty.

	self updateRefinements: #candidatesConstraint: value: aValue.

	self changed: #candidatesConstraint!

candidatesPath
	candidatesPath isNil
		ifTrue: [self initCandidatesPath].
	^candidatesPath!

candidatesPath: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkCandidatesPath: aValue) ifFalse: [^aValue].
	candidatesPath := aValue.
	self markDirty.

	self updateRefinements: #candidatesPath: value: aValue.

	self changed: #candidatesPath!

computationKind
	computationKind isNil
		ifTrue: [self initComputationKind].
	^computationKind!

computationKind: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkComputationKind: aValue) ifFalse: [^aValue].
	computationKind := aValue.
	self markDirty.

	self updateRefinements: #computationKind: value: aValue.

	self changed: #computationKind!

initializationExpression
	"Generated by ISF/AD. Do not modify"
	initializationExpression isNil
		ifTrue: [self initInitializationExpression].
	^initializationExpression!

initializationExpression: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkInitializationExpression: aValue  == true) ifFalse: [^aValue].
	initializationExpression := aValue.
	self markDirty.

	self updateRefinements: #initializationExpression: value: aValue.

	self changed: #initializationExpression!

isAbstract
	"Generated by ISF/AD. Do not modify"
	isAbstract isNil
		ifTrue: [self initIsAbstract].
	^isAbstract!

isAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsAbstract: aValue  == true) ifFalse: [^aValue].
	isAbstract := aValue == true.
	self markDirty.

	self updateRefinements: #isAbstract: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isAbstract!

isChangeable
	"Generated by ISF/AD. Do not modify"
	isChangeable isNil
		ifTrue: [self initIsChangeable].
	^isChangeable!

isChangeable: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsChangeable: aValue) ifFalse: [^aValue].
	isChangeable := aValue == true.
	self markDirty.

	self updateRefinements: #isChangeable: value: aValue.

	self changed: #isChangeable!

isDuplicatesAllowed
	"Generated by ISF/AD. Do not modify"
	isDuplicatesAllowed isNil
		ifTrue: [self initIsDuplicatesAllowed].
	^isDuplicatesAllowed!

isDuplicatesAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsDuplicatesAllowed: aValue  == true) ifFalse: [^aValue].
	isDuplicatesAllowed := aValue == true.
	self markDirty.

	self updateRefinements: #isDuplicatesAllowed: value: aValue.

	self changed: #isDuplicatesAllowed!

isExclussion
	"Generated by ISF/AD. Do not modify"
	isExclussion isNil
		ifTrue: [self initIsExclussion].
	^isExclussion!

isExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	isExclussion := aValue.

	self markDirty.

	self updateRefinements: #isExclussion: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isExclussion!

isIDAttribute
	"Generated by ISF/AD. Do not modify"
	isIDAttribute isNil
		ifTrue: [self initIsIDAttribute].
	^isIDAttribute!

isIDAttribute: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsIDAttribute: aValue  == true) ifFalse: [^aValue].
	isIDAttribute := aValue == true.
	self markDirty.

	self updateRefinements: #isIDAttribute: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isIDAttribute!

isInitializationPropagationAllowed
	"Generated by ISF/AD. Do not modify"
	isInitializationPropagationAllowed isNil
		ifTrue: [self initIsInitializationPropagationAllowed].
	^isInitializationPropagationAllowed!

isInitializationPropagationAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsInitializationPropagationAllowed: aValue  == true) ifFalse: [^aValue].
	isInitializationPropagationAllowed := aValue == true.
	self markDirty.

	self updateRefinements: #isInitializationPropagationAllowed: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isInitializationPropagationAllowed!

isInitializationPropagationOnConnectAllowed
	"Generated by ISF/AD. Do not modify"
	isInitializationPropagationOnConnectAllowed isNil
		ifTrue: [self initIsInitializationPropagationOnConnectAllowed].
	^isInitializationPropagationOnConnectAllowed!

isInitializationPropagationOnConnectAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsInitializationPropagationOnConnectAllowed: aValue  == true) ifFalse: [^aValue].
	isInitializationPropagationOnConnectAllowed := aValue == true.
	self markDirty.

	self updateRefinements: #isInitializationPropagationOnConnectAllowed: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isInitializationPropagationOnConnectAllowed!

isJustUsed
	"Generated by ISF/AD. Do not modify"
	isJustUsed isNil
		ifTrue: [self initIsJustUsed].
	^isJustUsed!

isJustUsed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsJustUsed: aValue) ifFalse: [^aValue].
	isJustUsed := aValue == true.

	self changed: #isJustUsed!

isNameAttribute
	"Generated by ISF/AD. Do not modify"
	isNameAttribute isNil
		ifTrue: [self initIsNameAttribute].
	^isNameAttribute!

isNameAttribute: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsNameAttribute: aValue  == true) ifFalse: [^aValue].
	isNameAttribute := aValue == true.
	self markDirty.

	self updateRefinements: #isNameAttribute: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isNameAttribute!

isPropagateUse
	"Generated by ISF/AD. Do not modify"
	isPropagateUse isNil
		ifTrue: [self initIsPropagateUse].
	^isPropagateUse!

isPropagateUse: aValue
	(self checkIsPropagateUse: aValue) ifFalse: [^aValue].
	self isPropagateUse = aValue ifTrue: [ ^aValue].
	isPropagateUse := aValue == true.
	self markDirty.

	self invalidateEffectiveAttributesCaches.

	self updateUses.

	self changed: #isPropagateUse!

isRefinementRequired
	"Generated by ISF/AD. Do not modify"
	isRefinementRequired isNil
		ifTrue: [self initIsRefinementRequired].
	^isRefinementRequired!

isRefinementRequired: aValue
	(self checkIsRefinementRequired: aValue) ifFalse: [^aValue].
	self isRefinementRequired = aValue ifTrue: [^aValue].
	isRefinementRequired := aValue == true.
	self markDirty.

	self updateRefinedFeatures.

	self changed: #isRefinementRequired!

maxMult
	"Generated by ISF/AD. Do not modify"
	maxMult isNil
		ifTrue: [self initMaxMult].
	^maxMult!

maxMult: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMaxMult: aValue) ifFalse: [^aValue].
	maxMult := aValue.

	self markDirty.

	self updateRefinements: #maxMult: value: aValue.

	self changed: #maxMult!

minMult
	"Generated by ISF/AD. Do not modify"
	minMult isNil
		ifTrue: [self initMinMult].
	^minMult!

minMult: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMinMult: aValue) ifFalse: [^aValue].
	minMult := aValue.
	self markDirty.

	self updateRefinements: #minMult: value: aValue.

	self changed: #minMult!

name: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkName: aValue) ifFalse: [^aValue].
	name := aValue.
	self markDirty.

	self invalidateEffectiveAttributesCaches.

	self changed: #name!

orderConstraint
	orderConstraint isNil
		ifTrue: [self initOrderConstraint].
	^orderConstraint!

orderConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOrderConstraint: aValue) ifFalse: [^aValue].
	orderConstraint := aValue.
	self markDirty.

	self updateRefinements: #orderConstraint: value: aValue.

	self changed: #orderConstraint!

reengineredInstVarName
	^reengineredInstVarName!

reengineredInstVarName: theValue
	(self checkReengineredInstVarName: theValue) ifFalse: [^theValue].
	reengineredInstVarName := theValue.
	self markDirty.

	self updateRefinements: #reengineredInstVarName: value: theValue.

	self changed: #reengineredInstVarName!

relatedConstraint
	^self valueConstraint!

valueConstraint
	valueConstraint isNil
		ifTrue: [self initValueConstraint].
	^valueConstraint!

valueConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkValueConstraint: aValue) ifFalse: [^aValue].
	valueConstraint := aValue.
	self markDirty.

	self updateRefinements: #valueConstraint: value: aValue.

	self changed: #valueConstraint!

valueTypeName
	"Generated by ISF/AD. Do not modify"
	valueTypeName isNil
		ifTrue: [self initValueTypeName].
	^valueTypeName!

valueTypeName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkValueTypeName: aValue) ifFalse: [^aValue].
	valueTypeName := aValue.
	self markDirty.

	self updateRefinements: thisContext method selector value: aValue.

	self changed: #valueTypeName! !

!CODEAttribute publicMethodsFor: 'accessing-private'!

forzeCandidatesConstraint: aValue
	candidatesConstraint := aValue!

forzeCandidatesPath: aValue
	candidatesPath := aValue!

forzeComputationKind: aValue
	computationKind :=  aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeInitializationExpression: aValue
	initializationExpression := aValue!

forzeIsAbstract: aValue
	isAbstract := aValue == true.!

forzeIsChangeable: aValue
	isChangeable := aValue == true.!

forzeIsDuplicatesAllowed: aValue
	isDuplicatesAllowed := aValue == true.!

forzeIsExclussion: aValue
	isExclussion := aValue == true.!

forzeIsIDAttribute: aValue
	isIDAttribute := aValue == true.!

forzeIsInitializationPropagationAllowed: aValue
	isInitializationPropagationAllowed := aValue == true.!

forzeIsInitializationPropagationOnConnectAllowed: aValue
	isInitializationPropagationOnConnectAllowed := aValue == true.!

forzeIsJustUsed: aValue
	isJustUsed := aValue == true.!

forzeIsNameAttribute: aValue
	isNameAttribute := aValue == true.!

forzeIsPropagateUse: aValue
	isPropagateUse := aValue == true.!

forzeIsRefinementRequired: aValue
	isRefinementRequired := aValue == true.!

forzeMaxMult: aValue
	maxMult := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeMinMult: aValue
	minMult := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeOrderConstraint: aValue
	orderConstraint := aValue!

forzeReengineredInstVarName: aValue
	reengineredInstVarName := aValue.!

forzeValueConstraint: aValue
	valueConstraint := aValue!

forzeValueTypeName: aValue
	valueTypeName := aValue.! !

!CODEAttribute publicMethodsFor: 'association initialize-release'!

attributeRefinementsRelease
	"Generated by ISF/AD. Do not modify"
	self attributeRefinements do: [:each | self attributeRefinementsRemove: each]!

initAttributeRefinements
	"Generated by ISF/AD. Do not modify"
	attributeRefinements := OrderedCollection new.!

typeRelease
	"Generated by ISF/AD. Do not modify"
	type == nil
		ifFalse:
			[type attributesPrivateRemove: self.
				type := nil.
				self changed: #type]!

valueTypeRelease
	"Generated by ISF/AD. Do not modify"
	valueType == nil
		ifFalse:
			[valueType typeOfValuesPrivateRemove: self.
				valueType := nil.
				self changed: #valueType]! !

!CODEAttribute publicMethodsFor: 'associations accessing'!

attributeRefinements
	"Generated by ISF/AD. Do not modify"
	^self attributeRefinementsPrivate copy!

attributeRefinementsAsArray
	"Generated by ISF/AD. Do not modify"
	^self attributeRefinements asArray!

type
	"Generated by ISF/AD. Do not modify"
	^type!

type: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkType: aValue) ifFalse: [^aValue].
	type == aValue ifTrue: [ ^self].
	self typeRelease.
	type := aValue.
	aValue == nil ifFalse: [aValue attributesPrivateAdd: self].
	self changed: #type!

valueType
	"Generated by ISF/AD. Do not modify"
	^valueType!

valueType: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkValueType: aValue) ifFalse: [^aValue].
	valueType == aValue ifTrue: [ ^self].
	self valueTypeRelease.
	valueType := aValue.
	aValue == nil ifFalse: [aValue typeOfValuesPrivateAdd: self].
	self markDirty.
	self invalidateEffectiveAttributesCaches.

	self changed: #valueType! !

!CODEAttribute publicMethodsFor: 'associations modifying'!

attributeRefinementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAttributeRefinementsAdd: aValue) ifFalse: [^aValue].
	(self attributeRefinementsIncludes: aValue) ifTrue: [^aValue].
	(self attributeRefinementsPrivateAdd: aValue) refinedAttributesPrivateAdd: self.
	self changed: #attributeRefinements.
	^aValue!

attributeRefinementsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self attributeRefinementsIncludes: aValue) ifFalse: [^aValue].
	(self attributeRefinements indexOf: aValue) = self attributeRefinementsSize ifTrue: [^aValue].
	self attributeRefinementsPrivate remove: aValue.
	aRes := self attributeRefinementsPrivateAdd: aValue.
	^aRes!

attributeRefinementsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self attributeRefinementsIncludes: aValue) ifFalse: [^aValue].
	(index := self attributeRefinements indexOf: aValue) = self attributeRefinementsSize ifTrue: [^aValue].
	index = (self attributeRefinementsSize -1)
		ifTrue:
			[self attributeRefinementsPrivate remove: aValue.
			aRes := self attributeRefinementsPrivateAdd: aValue.
			self notifyChangeAllAttributeRefinementsChildSpecs.
			^aRes].
	aRes := self attributeRefinementsPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

attributeRefinementsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self attributeRefinementsIncludes: aValue) ifFalse: [^aValue].
	(self attributeRefinements indexOf: aValue) = 1 ifTrue: [^aValue].
	self attributeRefinementsPrivateMove: aValue beforeIndex: 1.!

attributeRefinementsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self attributeRefinementsIncludes: aValue) ifFalse: [^aValue].
	(index := self attributeRefinements indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self attributeRefinementsPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

attributeRefinementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAttributeRefinementsRemove: aValue) ifFalse: [^aValue].
	(self attributeRefinementsPrivate remove: aValue ifAbsent: [^aValue]) refinedAttributesPrivateRemove: self.
	self changed: #attributeRefinements.
	^aValue! !

!CODEAttribute publicMethodsFor: 'associations private'!

attributeRefinementsPrivate
	"Generated by ISF/AD. Do not modify"
	attributeRefinements isNil
		ifTrue: [self initAttributeRefinements].
	^attributeRefinements!

attributeRefinementsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self attributeRefinementsPrivate add: aValue.
	self changed: #attributeRefinements.
	^aValue!

attributeRefinementsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self attributeRefinements at: anIndex.
	self attributeRefinementsPrivate remove: aValue.
	self attributeRefinementsPrivate add: aValue before: obj.
	self changed: #attributeRefinements.
	^aValue!

attributeRefinementsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self attributeRefinementsPrivate remove: aValue.
	self changed: #attributeRefinements.
	^aValue!

forzeType: aValue
	type := aValue.!

forzeValueType: aValue
	valueType := aValue.!

typePrivate: aValue
	| aPrevValue |
	(type isNil and: [ aValue isNil]) ifTrue: [ ^self].
	aPrevValue := type.
	type := aValue.
	self changed: #type.
	(type isNil and: [ aPrevValue isNil not]) ifTrue: [ self release].!

valueTypePrivate: aValue
	"Generated by ISF/AD. Do not modify"
	valueType := aValue.
	self markDirty.
	self changed: #valueType! !

!CODEAttribute publicMethodsFor: 'associations testing'!

attributeRefinementsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^attributeRefinements isNil
		ifTrue: [false]
		ifFalse: [self attributeRefinements includes: aValue]!

attributeRefinementsSize
	"Generated by ISF/AD. Do not modify"
	^attributeRefinements isNil
		ifTrue: [0]
		 ifFalse: [attributeRefinements size]! !

!CODEAttribute publicMethodsFor: 'derivation expressions'!

candidateFactoryTypes
	
	| aValueType someCandidateFactoryTypes |

	self candidatePathAllowsCreate ifFalse: [ ^nil].

	aValueType := self valueType.
	aValueType isNil ifTrue: [ ^nil].
	
	someCandidateFactoryTypes := aValueType withAllNonAbstractSubtypes.
	^someCandidateFactoryTypes!

candidatePathAllowsCreate
	
	| aCandidatesPath someStrings |

	aCandidatesPath := self candidatesPath.
	(aCandidatesPath isNil or: [ aCandidatesPath isEmpty]) ifTrue:  [ ^true].

	someStrings := aCandidatesPath asArrayOfSubstrings.
	someStrings size < 2 ifTrue: [ ^true].

	^someStrings first asSymbol = self class candidatesPathCreate!

candidateReferencedObjects: theObject
	^self candidateValueObjects: theObject!

candidateValueObjects: theObject
	
	| aCandidatesPath aDerivationPath aMetaInfo someCandidates someStrings somePotentialCandidates aFirstIndex aCandidatesConstraint someConstrainedCandidates |
	theObject isNil ifTrue: [ ^nil].

	aCandidatesPath := self candidatesPath.
	(aCandidatesPath isNil or: [ aCandidatesPath isEmpty]) ifTrue:  [ ^nil].

	someStrings := aCandidatesPath asArrayOfSubstrings.
	someStrings size < 2 ifTrue: [ ^nil].

	aFirstIndex := someStrings first = '$self' ifTrue: [ 3] ifFalse: [ 2].

	aDerivationPath := someStrings copyFrom: aFirstIndex to: someStrings size.
	aDerivationPath isEmpty ifTrue: [ ^nil].

	aMetaInfo := theObject metaInfo.
	aMetaInfo isNil ifTrue: [ ^nil].

	somePotentialCandidates := aMetaInfo object: theObject derive: aDerivationPath clone: false. 
	(somePotentialCandidates isNil or: [ somePotentialCandidates isEmpty]) ifTrue:  [ ^nil].

	someCandidates := somePotentialCandidates select: [:anObject | 
		self  relatedIsTypeOfObjectInstance: anObject
	].
	(someCandidates isNil or: [ someCandidates isEmpty]) ifTrue:  [ ^nil].

	aCandidatesConstraint := self candidatesConstraint.
	(aCandidatesConstraint isNil or: [ aCandidatesConstraint isEmpty]) ifTrue:  [ ^someCandidates].

	someConstrainedCandidates := someCandidates select: [:anObject | | aConstraintResult |
		aConstraintResult  := anObject metaInfo computeDerivedValueFrom: anObject expression: aCandidatesConstraint.
		aConstraintResult isNil not and: [ (aConstraintResult isKindOf: Collection) and: [  
			(aConstraintResult isKindOf: String) not and: [ aConstraintResult isEmpty not and: [ aConstraintResult first == true]]]]
	].
	(someConstrainedCandidates isNil or: [ someConstrainedCandidates isEmpty]) ifTrue:  [ ^nil].

	^someConstrainedCandidates!

cloneObject: theObject into: theNewObject
	self isMultiplicityMany
		ifTrue:  [ self cloneObjectMany: theObject into: theNewObject]
		ifFalse: [ self cloneObjectOne: theObject into: theNewObject]!

cloneObjectMany: theObject into: theNewObject

	|  aValueType aNonVirtualType aNewValue aValueMetaInfo someValues |

	theObject isNil ifTrue: [ ^self].
	theNewObject isNil ifTrue: [ ^self].

	someValues := self getObjectFeatureValueTC: theObject.
	(someValues isNil or: [ someValues isEmpty]) ifTrue: [ ^self].

	aValueType := self valueType.
	aValueType isNil ifTrue: [ ^self].

	aNonVirtualType := aValueType nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^self].
	
	(aNonVirtualType isPrimitive or: [ aNonVirtualType isEnumeration])  ifTrue: [ 
		someValues do: [:aValue | 
			aNewValue := aNonVirtualType cloneObject: aValue.
			aNewValue isNil ifFalse: [ 
				self object: theNewObject addTC: aNewValue.
			]
		].
		^self
	].

	someValues do: [:aValue | 
		aValueMetaInfo := aValue metaInfo.
		aValueMetaInfo  isNil ifFalse: [ 
	
			aNewValue := aValueMetaInfo cloneObject: aValue.
			aNewValue isNil ifFalse: [ 
				self object: theNewObject addTC: aNewValue.
			]
		]
	]!

cloneObjectOne: theObject into: theNewObject

	| aValue aValueType aNonVirtualType aNewValue aValueMetaInfo |

	theObject isNil ifTrue: [ ^self].
	theNewObject isNil ifTrue: [ ^self].

	aValue := self getObjectFeatureValueTC: theObject.
	aValue isNil ifTrue: [ ^self].

	aValueType := self valueType.
	aValueType isNil ifTrue: [ ^self].

	aNonVirtualType := aValueType nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^self].
	
	(aNonVirtualType isPrimitive or: [ aNonVirtualType isEnumeration])  ifTrue: [ 
		aNewValue := aNonVirtualType cloneObject: aValue.
		aNewValue isNil ifFalse: [ 
			self object: theNewObject setTC: aNewValue.
		].
		^self
	].

	aValueMetaInfo := aValue metaInfo.
	aValueMetaInfo  isNil ifTrue: [ ^self]. 
	
	aNewValue := aValueMetaInfo cloneObject: aValue.
	aNewValue isNil ifFalse: [ 
		self object: theNewObject setTC: aNewValue.
	]! !

!CODEAttribute publicMethodsFor: 'derivations cache'!

invalidateEffectiveAttributesCaches
	
	| aType |

	aType := self type.
	aType isNil ifTrue:  [ ^self].

	aType invalidateEffectiveAttributesCaches! !

!CODEAttribute publicMethodsFor: 'derived accessing'!

allRefinedAttributesInto: theSet

	(theSet includes: self) ifTrue: [ ^self].

	theSet add: self.!

applicationConfiguration
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type applicationConfiguration]!

fullyQualifiedName

	| aFullyQualifiedName aTypeFullyQualifiedName |
	self type isNil ifTrue: [ ^self name].
	
	aTypeFullyQualifiedName := self type fullyQualifiedName.
	(aTypeFullyQualifiedName isNil or: [ aTypeFullyQualifiedName isEmpty]) ifTrue: [ 
		^self name
	].

	aFullyQualifiedName := aTypeFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

hasIdCounter

	| aNonVirtualType aValueType |

	self isExclussion ifTrue: [ ^false].
	self maxMult = self class maxMultNone ifTrue: [ ^false].

	aValueType := self valueType.
	aValueType isNil ifTrue: [ ^false].

	aNonVirtualType := aValueType nonVirtualType.
	aNonVirtualType isNil  ifTrue: [ ^false].

	^self isIDAttribute 
		ifTrue: [ aNonVirtualType isIDCompatible ]
		ifFalse: [ 
			aNonVirtualType isPrimitive not and:  [ 
				aValueType hasIdCounter
			]
		]!

hasOrTypeHasAspectNamed: theAspectName

	| aValueType |
	(theAspectName isNil or: [ theAspectName]) isEmpty ifTrue: [ ^false].

	(self aspectNamed: theAspectName) isNil ifFalse: [ ^true].
	
	aValueType := self valueType.
	aValueType isNil ifTrue: [ ^false].

	(aValueType aspectNamed: theAspectName) isNil ifFalse: [ ^true].

	^false!

isAggregated
	^false!

isAggregation
	^true!

isEnumerationValue

	| aType |
	aType := self type.
	aType isNil ifTrue: [ ^false].
	aType isEnumeration ifFalse: [ ^false].

	^self valueType isNil!

isVisibleInModules: 		theModules
	andAspects: 			theAspects
	definitionsHolder: 	theDefinitionsHolder

	((theModules isNil or: [ theModules isEmpty]) and: [  
		theAspects isNil or: [ theAspects isEmpty]]) ifTrue: [ 
		^true
	].

	^(  self isVisibleInModules: 	theModules definitionsHolder: 	theDefinitionsHolder) and: [ 
		self isVisibleInAspects: 	theAspects definitionsHolder: 	theDefinitionsHolder
	]!

isVisibleInModules: 		theModules
	definitionsHolder: 	theDefinitionsHolder


	| aThisModule |

	(theModules isNil or: [ theModules isEmpty]) ifTrue: [ ^true ].

	(theModules isNil not and: [ theModules isEmpty not]) ifTrue: [ 
		aThisModule := self module.
		aThisModule isNil ifTrue: [ ^false].
		(theModules includes: aThisModule) ifFalse: [ 
			(theModules detect: [:aModule | aModule includesModule: aModule] ifNone: [ nil]) isNil ifTrue: [ ^false]
		]
	].!

model
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type model]!

module
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type module]!

referencedType
	^self valueType!

requiresIdCounter

	| aNonVirtualType aValueType |

	self isExclussion ifTrue: [ ^false].
	self maxMult = self class maxMultNone ifTrue: [ ^false].

	self computationKind = self class computationKindFromHomeIDCounter ifFalse: [ ^false].

	aValueType := self valueType.
	aValueType isNil ifTrue: [ ^false].

	aNonVirtualType := aValueType nonVirtualType.
	aNonVirtualType isNil  ifTrue: [ ^false].

	^self isIDAttribute 
		ifTrue: [ aNonVirtualType isIDCompatible ]
		ifFalse: [ 
			aNonVirtualType isPrimitive not and:  [ 
				aValueType requiresIdCounter
			]
		]!

withAllRefinedAttributes
	| someAttributes |
	someAttributes := IdentitySet new: 13.
	self withAllRefinedAttributesInto: someAttributes.
	
	^someAttributes!

withAllRefinedAttributesInto: theAttributes

	theAttributes isNil ifTrue: [ ^self].
	(theAttributes includes: self) ifTrue: [ ^self]. 
	theAttributes add: self.! !

!CODEAttribute publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self type isNil ifFalse: [ self type markDirtyOwner]
	].!

persistIfDirty
	^self type isNil ifFalse: [ self type persistIfDirty] ifTrue: [ nil]! !

!CODEAttribute publicMethodsFor: 'generate'!

generateAttributeDeleteForType: theType

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	(self type isNil not and: [ self type isEnumeration]) ifTrue: [ ^self].
	(self type isNil not and: [ self type isPrimitive]) ifTrue: [ ^self].

	aTemplateFileName := self templateFileNameForDelete.
	aTemplateFileName isNil ifTrue: [ ^self].

	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType baseOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType baseOutStream nextPutAll: anExpansion]]
	]!

generateBaseImplementationForType: theType
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	(self type isNil not and: [ self type isEnumeration]) ifTrue: [ ^self].
	(self type isNil not and: [ self type isPrimitive]) ifTrue: [ ^self].

	aTemplateFileName := self templateFileNameFor: 'base'.
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType baseOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType baseOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateBaseStorageDefinitionForType: theType
	(self type isNil not and: [ self type isEnumeration]) ifTrue: [ ^self].
	(self type isNil not and: [ self type isPrimitive]) ifTrue: [ ^self].

	theType  baseOutStream 
		tab;
		nextPutAll: 'protected ';
		nextPutAll: (self expand:  'AttributeTypeClassFullyQualifiedName');
		nextPutAll: ' ';
		nextPutAll: (self expand: 'AttributeVariableName');
		nextPutAll: ';'; 
		cr; cr!

generateEnumerationDeclarationForType: theType

	theType  ifcOutStream 
		tab;
		nextPutAll: 'public static final String ';
		nextPutAll: (self expand: 'AttributeVariableName');
		nextPutAll: ' = new String("';
		nextPutAll: self name;
		nextPutAll: '");'; 
		cr; cr!

generateEnumerationPropertyInitializationForType: theType

"     setProperty( 'MANY',    'MANY');
"
	(self type isNil not and: [ self type isEnumeration]) ifFalse: [ ^self].

	theType  baseOutStream 
		nextPutAll: '    setProperty("'; nextPutAll: (self expand: 'UpperAttributeName'); nextPutAll: '", "'; 
		nextPutAll: (self expand: 'UpperAttributeName'); nextPutAll: ');'; cr.!

generateIfcDeclarationForType: theType
| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	(self type isNil not and: [ self type isEnumeration]) ifTrue: [ 
		^self generateEnumerationDeclarationForType: theType].

	(self type isNil not and: [ self type isPrimitive]) ifTrue: [ ^self].

	aTemplateFileName := self templateFileNameFor: 'ifc'.
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType ifcOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType ifcOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateM3Phase1InitializationForType: theType

		| aStream |
	aStream := theType  metaOutStream.

	aStream 
		tab; tab;
		nextPutAll: (self expand: 'MetaAttributeVariableName');
		nextPutAll: ' = (',
			self metaAttributeFullIfcPrefixedClassName,') theCtxt.getMMFactory("', self type model m3FactoryName, 
			'").createMMElementOfType( theCtxt, "Attribute", "core",',
			'"', self name, '");';cr;
		tab; tab; nextPutAll: 'vm3Type.addAttributes( theCtxt, '; nextPutAll: (self expand: 'MetaAttributeVariableName');
			nextPutAll: ');'; cr; cr.


   " vm3AttrMinMultiplicity = new com.d_a_t.eai.studio.m3.impl.EAIAttributeImpl( new EAIMMName( 'MinMultiplicity'));"!

generateM3Phase2InitializationForType: theType

	| aStream |
	self valueType isNil ifTrue: [ ^self].

	aStream := theType  metaOutStream.

	aStream 
		tab; tab; nextPutAll: (self expand: 'MetaAttributeVariableName'); nextPutAll: '.setValueType( theCtxt, ';
		nextPutAll: (self valueType expand: 'FullMetaPrefixedClassName');
		nextPutAll: '.vm3Type);'; 
		cr; cr

   " vm3AttrMinMultiplicity.setValueType( theCtxt, null);;"!

generateM3Phase2LocalStorageInitializationForType: theType

	| aStream |
	self valueType isNil ifTrue: [ ^self].

	aStream := theType  metaOutStream.

	aStream 
		tab; tab; nextPutAll: (self expand: 'MetaAttributeVariableName'); nextPutAll: '.setValueType( theCtxt, ';
		nextPutAll: (self valueType expand: 'FullMetaPrefixedClassName');
		nextPutAll: '.vm3Type);'; 
		cr; cr

   " vm3AttrMinMultiplicity.setValueType( theCtxt, null);;"!

generateM3Phase2MultiInheritedInitializationForType: theType

		| aStream |
	aStream := theType  metaOutStream.

	aStream 
		tab; tab; nextPutAll: (self expand: 'MetaAttributeVariableName'); 
		nextPutAll: ' = ';
		nextPutAll: (self type expand: 'FullMetaPrefixedClassName'); 
		nextPutAll: '.' , (self expand: 'MetaAttributeVariableName');
		nextPutAll: ';'; cr; cr.


   " vm3AttrMinMultiplicity = .;"!

generateM3StorageDefinitionForType: theType

		| aStream |
	aStream := theType  metaOutStream.

	aStream 
		tab; tab;
		nextPutAll: 'public static ';
		nextPutAll: self metaAttributeFullIfcPrefixedClassName;
		nextPutAll: ' ';
		nextPutAll: (self expand: 'MetaAttributeVariableName');
		nextPutAll: ';'; 
		cr; cr!

generatePrivDeclarationForType: theType
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	(self type isNil not and: [ self type isEnumeration]) ifTrue: [ ^self].
	(self type isNil not and: [ self type isPrimitive]) ifTrue: [ ^self].

	aTemplateFileName := self templateFileNameFor: 'priv'.
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType privOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType privOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generatePropertyInitializationForType: theType

"     setProperty( 'Name',    null);
"
	(self type isNil not and: [ self type isEnumeration]) ifTrue: [ 
		^self generateEnumerationPropertyInitialization].

	(self type isNil not and: [ self type isPrimitive]) ifTrue: [ ^self].

	theType  baseOutStream 
		nextPutAll: '    setProperty("'; nextPutAll: (self expand: 'UpperAttributeName'); nextPutAll: '", null);'; cr.!

generatePropertySynchChangeDetectionForType: theType

"    if( theRole.equals( 'Project')) {
	  syncProperty( theCtxt, 'Name',           toObject( getName( theCtxt)));
	  return;
	}
"
	theType  baseOutStream 
		nextPutAll: '    if( theRole.equals( "'; nextPutAll: (self expand: 'UpperAttributeName'); nextPutAll: '")) {';cr;
	 		nextPutAll: '      syncProperty( theCtxt, "'; nextPutAll: (self expand: 'UpperAttributeName'); 
			nextPutAll: '", toObject( get'; nextPutAll: (self expand: 'UpperAttributeName'); 
			nextPutAll: '( theCtxt)));'; cr;
			nextPutAll: '      return;'; cr;
   			nextPutAll: '    }'; cr!

generateTrxDeclarationForType: theType
| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'trx'.
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			 theType trxOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType trxOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]! !

!CODEAttribute publicMethodsFor: 'generate-streams'!

baseOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type baseOutStream]!

ifcOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type ifcOutStream]!

implOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type implOutStream]!

privOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type privOutStream]!

trxOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type trxOutStream]!

wholeTraversalConfigOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type wholeTraversalConfigOutStream]! !

!CODEAttribute publicMethodsFor: 'generate-support'!

attributeNullValue
	| aValueTypeName |


	aValueTypeName := self attributeTypeName.
	^aValueTypeName = 'int' ifTrue: [ '0'] ifFalse: [
	aValueTypeName = 'boolean' ifTrue: [ 'true'] ifFalse: [
	aValueTypeName = 'float' ifTrue: [ '0.0'] ifFalse: [
	aValueTypeName = 'double' ifTrue: [ '0.0'] ifFalse: [
		'null'
	]]]]!

attributeTypeName
	| anAttributeTypeName aType |
	anAttributeTypeName := self valueTypeName.
	anAttributeTypeName = 'any' 
		ifTrue: [ anAttributeTypeName := 'Object']
		ifFalse: [ 
			anAttributeTypeName := self model nativeAttributeName: self valueTypeName.
			aType := self valueType.
			aType isNil ifFalse: [ 
				anAttributeTypeName := self model nativeAttributeName: aType name.
				(anAttributeTypeName isNil or: [ anAttributeTypeName isEmpty]) ifTrue: [ 
					anAttributeTypeName := aType asAttributeTypeFullyQualifiedName.	
				]
			]
		].
	anAttributeTypeName isNil ifTrue: [ anAttributeTypeName := self valueTypeName].

	^anAttributeTypeName!

expand: theKey
	expansionInitialized == true ifFalse: [ self initializeExpansions].

	^self expansions at: theKey ifAbsent: [ self type model expand: theKey]!

initializeExpansions

	| anAttributeTypeName aConverterMethodName aValueTypeName anAttributeNullValue |
	self expansion: 'UpperAttributeName' value: self upperInitialName.
	(self type isNil not and: [ self type isEnumeration]) 
		ifTrue: [ 
			self expansion: 'AttributeVariableName' value: self type model enumVariablePrefix , 	
				(self type model enumVariablePrefix isEmpty ifTrue: [ self name] ifFalse: [ self upperInitialName])]
		ifFalse: [
			self expansion: 'AttributeVariableName' value: self type model attributeVariablePrefix , 
				(self type model attributeVariablePrefix isEmpty ifTrue: [ self name] ifFalse: [ self upperInitialName])].


	self expansion: 'MetaAttributeVariableName' value: self type model metaVariablePrefix , 'Attr', 
		(self type model metaVariablePrefix isEmpty ifTrue: [ self name] ifFalse: [ self upperInitialName]).

	anAttributeTypeName := self attributeTypeName.
	anAttributeNullValue := self attributeNullValue.

Transcript show: 'A  '; show: self name; show: ' : '; show: anAttributeTypeName; show: ' = ' ; show: anAttributeNullValue; cr.

	self expansion: 'AttributeTypeClassFullyQualifiedName' value: anAttributeTypeName.
	self expansion: 'AttributeNullValue' value: anAttributeNullValue.

	aConverterMethodName := 'toObject'.
	aValueTypeName := self valueTypeName.
	(self model isNativeAttributeName: aValueTypeName) ifTrue: [ 
		aConverterMethodName := 'to' , (self toUpperInitial: aValueTypeName).	
	].
	self expansion: 'ObjectToAttributeValueConverterMethodName' value: aConverterMethodName.
	self expansion: 'FullMetaPrefixedClassName' value: ( self type module fullPackageName), '.meta.', (self type model typePrefix , self type upperInitialName) , 'Meta'.

	expansionInitialized := true!

metaAttributeFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaAttributeFullIfcPrefixedClassName!

metaAttributeFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaAttributeFullImplPrefixedClassName!

metaModelFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModelFullIfcPrefixedClassName!

metaModuleFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModuleFullIfcPrefixedClassName!

metaRelationshipFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaRelationshipFullIfcPrefixedClassName!

metaTypeFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaTypeFullIfcPrefixedClassName!

templateFileNameFor: theAspect
	
	| aTemplateDirectory aFileName anAttributeTemplateName |

	aTemplateDirectory := self model templatesDirectory.
	aTemplateDirectory isNil ifTrue: [ ^nil].

	anAttributeTemplateName := 'AttributeOne' copy.
	anAttributeTemplateName isNil ifTrue: [ ^nil].

	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'relationships', (String with: Filename separator) ,
		theAspect, (String with: Filename separator) ,
		anAttributeTemplateName ,  (self toUpperInitial: theAspect) , '.java'.
	^aFileName!

templateFileNameForDelete
	
	| aTemplateDirectory aFileName anAttributeTemplateName |

	aTemplateDirectory := self model templatesDirectory.
	aTemplateDirectory isNil ifTrue: [ ^nil].

	anAttributeTemplateName := 'AttributeOneDelete' copy.
	anAttributeTemplateName isNil ifTrue: [ ^nil].

	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'relationships', (String with: Filename separator) ,
		'base', (String with: Filename separator) ,
		anAttributeTemplateName , '.java'.
	^aFileName! !

!CODEAttribute publicMethodsFor: 'generate-traversals'!

generateTraversalAttributeCfgsStaticDeclarations!

generateTraversalAttributeCfgsStaticInstantiations!

generateTraversalFieldMgrsStaticDeclarations!

generateTraversalFieldMgrsStaticInstantiations! !

!CODEAttribute publicMethodsFor: 'initialize-release'!

dependenciesRelease
	dependencies isNil ifTrue: [ ^self].
	dependencies do: [:aDependency | aDependency release].
	dependencies := nil!

initCandidatesConstraint
	candidatesConstraint := ''!

initCandidatesPath
	candidatesPath := ''!

initComputationKind
	computationKind := self class computationKindNoComputation!

initInitializationExpression
	initializationExpression := '' copy!

initIsAbstract
	isAbstract := false!

initIsChangeable
	isChangeable := true!

initIsDuplicatesAllowed
	isDuplicatesAllowed := false!

initIsExclussion
	isExclussion := false!

initIsIDAttribute
	isIDAttribute := false!

initIsInitializationPropagationAllowed
	isInitializationPropagationAllowed := false!

initIsInitializationPropagationOnConnectAllowed
	isInitializationPropagationOnConnectAllowed := false!

initIsJustUsed
	isJustUsed := true!

initIsNameAttribute
	isNameAttribute := false!

initIsPropagateUse
	isPropagateUse := false!

initIsRefinementRequired
	isRefinementRequired := false!

initMaxMult
	maxMult := self class maxMultOne!

initMinMult
	"Generated by ISF/AD. Do not modify"
	minMult := self class minMultOptional!

initOrderConstraint
	orderConstraint := ''!

initTerminalMetaAttributesFrom: theAttribute
	theAttribute isNil ifTrue: [ ^self].
	(theAttribute isKindOf: CODEAttribute) ifFalse: [ ^self].

	self minMult: 					theAttribute minMult copy.
	self maxMult: 					theAttribute maxMult copy.
	self isAbstract: 					theAttribute isAbstract == true.
	self reengineredInstVarName:	theAttribute reengineredInstVarName copy.
	self isExclussion: 				theAttribute isExclussion == true.
	self isNameAttribute: 			theAttribute isNameAttribute == true.
	self isIDAttribute: 				theAttribute isIDAttribute == true.
	self isChangeable: 				theAttribute isChangeable == true.
	self isDuplicatesAllowed: 		theAttribute isDuplicatesAllowed == true.
	self computationKind: 			theAttribute computationKind copy.
	self orderConstraint: 			theAttribute orderConstraint copy.
	self candidatesPath: 			theAttribute candidatesPath copy.
	self candidatesConstraint: 		theAttribute candidatesConstraint copy.
	self initializationExpression: 		theAttribute initializationExpression copy.
	self valueConstraint: 			theAttribute valueConstraint copy.
	"self isPropagateUse:  			theAttribute isPropagateUse == true.
	self isJustUsed:					theAttribute isJustUsed == true."!

initValueConstraint
	valueConstraint := ''!

initValueTypeName
	"Generated by ISF/AD. Do not modify"
	valueTypeName := ''.!

release
	self changed: #objectDisconnectedOfTree.

	self valueTypeRelease.

	self typeRelease.
	
	self attributeRefinements do: [:anAtributeRefinement | anAtributeRefinement release].

	self attributeRefinementsRelease.
	
	self dependenciesRelease.

	super release! !

!CODEAttribute publicMethodsFor: 'parse'!

fromLineStream: theLineStream andStream: theStream valueType: theValueType

	| aType aModule |
	self valueTypeName: theValueType.
	aModule := self module.
	aType := aModule findTypeNamed: theValueType.
	aType isNil ifFalse: [ self valueType: aType].! !

!CODEAttribute publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aSep aType |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aType := self type.

	aType isNil  ifFalse: [  aType allQualifiedNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

asReferenceArray

	| aType aTypeReferenceArray |

	aType := self type.
	aTypeReferenceArray := aType isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aType asReferenceArray].

	^Array with: self class refToAttributeKindSymbol with: self name with: aTypeReferenceArray!

asReferenceAsCodeStringNOCROn: theStream

	| aSep aType |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	aType := self type.

	theStream nextPutAll: ' ( ';  nextPutAll: (self pcForV: self class refToAttributeKindSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	aType isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [  aType asReferenceAsCodeStringNOCROn: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAsCodeStringNOCROn: theStream. 
	theStream cr.!

firstPersistenceIndexAttribute
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexAttribute.

	self forzeValueTypeName:	 			(theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]).
	self forzeReengineredInstVarName:		(theValues size < (aFPI + 1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 1)]). 
	self forzeMinMult:						(theValues size < (aFPI + 2) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 2)]). 
	self forzeMaxMult:						(theValues size < (aFPI + 3) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 3)]). 
	self forzeIsAbstract:						(theValues size < (aFPI + 4) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 4)]). 
	self forzeIsExclussion:					(theValues size < (aFPI + 5) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 5)]). 
	self forzeIsNameAttribute:				(theValues size < (aFPI + 6) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 6)]). 
	self forzeIsIDAttribute:					(theValues size < (aFPI + 7) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 7)]). 
	self forzeIsChangeable:					(theValues size < (aFPI +8) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +8)]). 
	self forzeIsDuplicatesAllowed:			(theValues size < (aFPI +9) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +9)]). 
	self forzeIsInitializationPropagationAllowed:		(theValues size < (aFPI +10) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +10)]). 
	self forzeIsInitializationPropagationOnConnectAllowed:		(theValues size < (aFPI +11) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +11)]). 
	self forzeComputationKind:				(theValues size < (aFPI +12) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +12)]). 
	self forzeOrderConstraint:				(theValues size < (aFPI + 13) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 13)]). 
	self forzeCandidatesPath:				(theValues size < (aFPI + 14) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 14)]). 
	self forzeCandidatesConstraint:			(theValues size < (aFPI + 15) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 15)]). 
	self forzeInitializationExpression:			(theValues size < (aFPI + 16) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 16)]). 
	self forzeValueConstraint:				(theValues size < (aFPI + 17) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 17)]). 

	theValues size < (aFPI + 18) ifFalse: [  self initReferencedValueTypeFromValues:  (theValues at: (aFPI + 18))  ].

	self forzeIsPropagateUse:				(theValues size < (aFPI + 19) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 19)]).!

initReferencedValueTypeFromValues: theValues
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refToValueTypeKindSymbol ifFalse: [ ^nil].

	valueTypeRefTmpValues := theValues.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep aValueType |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  valueTypeName ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self reengineredInstVarName );  cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self minMult );  nextPutAll: aSep;
		nextPutAll: (self pcForV:  self maxMult ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self isAbstract ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isExclussion ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isNameAttribute ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isIDAttribute );  nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isChangeable ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isDuplicatesAllowed ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isInitializationPropagationAllowed ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isInitializationPropagationOnConnectAllowed ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self computationKind); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self orderConstraint ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self candidatesPath );cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self candidatesConstraint ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self initializationExpression ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self valueConstraint ); cr.

	aValueType := self valueType.
	aValueType isNil  
		ifTrue: [ theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil)] 
		ifFalse: [  
			aValueType asReferenceAsCodeStringOn:  theStream indent: anIS]. 
	
	theStream cr.

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  isPropagateUse ); cr!

numberPersistenceEntriesAttribute
	^20!

ph2InitFromSolver: theSolver
	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedValueTypeFromSolver: theSolver!

ph2InitReferencedValueTypeFromSolver: theSolver
	
	| aType |

	(valueTypeRefTmpValues isNil or: [ valueTypeRefTmpValues isEmpty]) ifTrue: [ ^nil].

	valueTypeRefTmpValues first = self class refToValueTypeKindSymbol ifFalse: [ ^nil].
	
	aType := CODEElement resolveOrNewReferencedTypeFromPersistenceAsCode:  valueTypeRefTmpValues  solver: theSolver.
	aType isNil ifFalse: [ 
		self forzeValueType: aType.
		aType typeOfValuesPrivate add: self].

	valueTypeRefTmpValues := nil!

xnumberPersistenceEntriesAttribute
	^20! !

!CODEAttribute publicMethodsFor: 'semantic checking'!

checkAttributeRefinementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkAttributeRefinementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCandidatesConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCandidatesPath: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkComputationKind: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkInitializationExpression: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsChangeable: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsDuplicatesAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsIDAttribute: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsInitializationPropagationAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsInitializationPropagationOnConnectAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsJustUsed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsNameAttribute: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsPropagateUse: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsRefinementRequired: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMaxMult: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMinMult: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOrderConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkReengineredInstVarName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkType: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkValueConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkValueType: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkValueTypeName: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEAttribute publicMethodsFor: 'semantic links'!

attributeRefinementsCandidates
	"Generated by ISF/AD. Do not modify"
	^self attributeRefinements asArray!

attributeRefinementsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEAttribute new!

attributeRefinementsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self attributeRefinementsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self attributeRefinementsAdd: anObject]!

attributeRefinementsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self attributeRefinementsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self attributeRefinementsAdd: anObject.!

attributeRefinementsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self attributeRefinementsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self attributeRefinementsCreate class
		ifUnchanged: [^self].
	self attributeRefinementsAdd: anObject!

attributeRefinementsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

maxMultCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self maxMult!

maxMultCreate
	"Generated by ISF/AD. Do not modify"
	^''!

maxMultLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self maxMult: self maxMultCreate.!

maxMultLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self maxMultCandidates
		initially: self maxMult
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self maxMult: anObject.!

maxMultLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self maxMultCandidates
		initially: self maxMult
		label: 'Select Or Create ...'
		class: self maxMultCreate class
		ifUnchanged: [^self].
	self maxMult: anObject!

maxMultScope
	"Generated by ISF/AD. Do not modify"
	^nil!

minMultCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self minMult!

minMultCreate
	"Generated by ISF/AD. Do not modify"
	^''!

minMultLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self minMult: self minMultCreate.!

minMultLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self minMultCandidates
		initially: self minMult
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self minMult: anObject.!

minMultLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self minMultCandidates
		initially: self minMult
		label: 'Select Or Create ...'
		class: self minMultCreate class
		ifUnchanged: [^self].
	self minMult: anObject!

minMultScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typeCandidates
	| aCurrentType someTypes |
	aCurrentType := self type.
	someTypes := self type model allTypes select: [:aType | 
		aType isPrimitive not and: [ aType isEnumeration not or: [ aCurrentType isNil or: [ aCurrentType isEnumeration]]]].
	^someTypes!

typeCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

typeLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typeCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self type: anObject]!

typeLinkSelect

	| someTypes aSelectedType anInitialSelection aLowercaseAttributeName aMatchingType aMaxScore aSimilarType |

	someTypes := self typeCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as Type of Attribute\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	anInitialSelection := self type.
	anInitialSelection isNil ifTrue: [ 
		aLowercaseAttributeName := self name asLowercase.
		aMatchingType := someTypes detect: [:aType | aType name asLowercase = aLowercaseAttributeName] ifNone: [ nil].
		aMatchingType isNil
			ifFalse: [ anInitialSelection := aMatchingType]
			ifTrue: [ 
				aMaxScore := -1.
				aSimilarType := nil.
				someTypes do: [:aType |   | aScore |
					aScore := aType name spellAgainst: aLowercaseAttributeName.
					aScore > aMaxScore ifTrue: [ aSimilarType := aType]
				].
				aSimilarType isNil ifFalse: [  aMatchingType := aSimilarType].
			]
	].
	aSelectedType := Dialog 
		choose: ('	Please, select a Type as Type of Attribute	\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ')']]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil]
		initialSelection: anInitialSelection.
	aSelectedType isNil ifTrue: [ ^nil].

	self type: aSelectedType.

	^aSelectedType!

typeLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typeCandidates
		initially: self type
		label: 'Select Or Create ...'
		class: self typeCreate class
		ifUnchanged: [^self].
	self type: anObject!

typeScope
	"Generated by ISF/AD. Do not modify"
	^nil!

valueTypeCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

valueTypeLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self valueTypeCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self valueType: anObject]!

valueTypeLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self valueTypeCandidates
		initially: self valueType
		label: 'Select Or Create ...'
		class: self valueTypeCreate class
		ifUnchanged: [^self].
	self valueType: anObject!

valueTypeNameCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self valueTypeName!

valueTypeNameCreate
	"Generated by ISF/AD. Do not modify"
	^''!

valueTypeNameLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self valueTypeName: self valueTypeNameCreate.!

valueTypeNameLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self valueTypeNameCandidates
		initially: self valueTypeName
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self valueTypeName: anObject.!

valueTypeNameLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self valueTypeNameCandidates
		initially: self valueTypeName
		label: 'Select Or Create ...'
		class: self valueTypeNameCreate class
		ifUnchanged: [^self].
	self valueTypeName: anObject!

valueTypeNameScope
	"Generated by ISF/AD. Do not modify"
	^nil!

valueTypeScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEAttribute publicMethodsFor: 'semantic links-custom'!

valueTypeCandidates
	self type isNil ifTrue: [ ^nil].
	^self type model allTypes!

valueTypeLinkSelect

	| someTypes aSelectedType anInitialSelection aLowercaseAttributeName aMatchingType aMaxScore aSimilarType |

	someTypes := self valueTypeCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as ValueType of Attribute\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	anInitialSelection := self valueType.
	anInitialSelection isNil ifTrue: [ 
		aLowercaseAttributeName := self name asLowercase.
		aMatchingType := someTypes detect: [:aType | aType name asLowercase = aLowercaseAttributeName] ifNone: [ nil].
		aMatchingType isNil
			ifFalse: [ anInitialSelection := aMatchingType]
			ifTrue: [ 
				aMaxScore := -1.
				aSimilarType := nil.
				someTypes do: [:aType |   | aScore |
					aScore := aType name spellAgainst: aLowercaseAttributeName.
					aScore > aMaxScore ifTrue: [ aSimilarType := aType]
				].
				aSimilarType isNil ifFalse: [  aMatchingType := aSimilarType].
			]
	].
	aSelectedType := Dialog 
		choose: ('				Please, select a Type as ValueType of Attribute				\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ') ' , aType allContainerNamespaceNames ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil]
		initialSelection: anInitialSelection.
	aSelectedType isNil ifTrue: [ ^nil].

	self valueType: aSelectedType.

	^aSelectedType! !

!CODEAttribute publicMethodsFor: 'testing'!

isAttribute
	^true!

isFeature
	^true!

isMultiplicityMany
	^self maxMult = self class maxMultMany or: [ self maxMult = self class maxMultTwo]!

isMultiplicityNone
	^self maxMult = self class maxMultNone!

isMultiplicityOne
	^self maxMult = self class maxMultOne!

isOrdered
	^self isSorted not!

isSorted
	^self orderConstraint isNil not and:  [  self orderConstraint isEmpty not and: [ self orderConstraint asArrayOfSubstrings isEmpty not]]! !

!CODEAttribute publicMethodsFor: 'updating refinements'!

updateRefinedFeatures

	| aType |

	aType := self type.
	aType isNil ifTrue:  [ ^self].

	aType updateRefinedFeatures!

updateRefinements: theMetaAttributeName value: theValue

	| someRefinements |
	someRefinements := self attributeRefinements.
	(someRefinements isNil not and: [someRefinements  isEmpty not]) ifTrue: [ 
		someRefinements do: [:aRefinement | 
			aRefinement updateFromRefined: theMetaAttributeName value: theValue
		]
	].! !

!CODEAttribute publicMethodsFor: 'updating uses'!

updateUses

	| aType |

	aType := self type.
	aType isNil ifTrue:  [ ^self].

	aType updateUses! !

!CODEAttributeRefinement class publicMethodsFor: 'accessing'!

kind
	^#attributeRefinement! !

!CODEAttributeRefinement class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		 self modelEditorMETAPerspectivesAttributeRefinement, super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesAttributeRefinement
 
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RefinedAttributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'RefinedAttributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'AttributeRefinement_Perspectives';
			nlsItem: 'RefinedAttributes';
			nlsTranslation: 'AtributosOriginales';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsAttributeRefinement!

modelEditorMETASelectorsAttributeRefinement

	"METAChildSpecAutoViewEditor openOn: CODEAttribute selector: #modelEditorMETASelectorsAttributeRefinement target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 8)
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RefinedAttributes';
			basicSelector: #refinedAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'RefinedAttributes';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'AttributeRefinement_Selectors';
			nlsItem: 'RefinedAttributes';
			nlsTranslation: 'AtributosOriginales';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsAttributeRefinement.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: super modelEditorPathSelectors metaSelectorsToSelect, aLocalView metaSelectorsToSelect!

modelEditorPathSelectorsAttributeRefinement

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('RefinedAttributes' )! !

!CODEAttributeRefinement publicMethodsFor: 'accessing'!

candidatesConstraint: aValue
	
	(self checkCandidatesConstraint: aValue) ifFalse: [^aValue].
	(self candidatesConstraint = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #candidatesConstraint:) = aValue 
		ifTrue: [ self clearAsRefined: #candidatesConstraint:]
		ifFalse: [  self setAsRefined: #candidatesConstraint:].

	candidatesConstraint := aValue.
	self markDirty.

	self updateRefinements: #candidatesConstraint: value: aValue.

	self changed: #candidatesConstraint!

candidatesPath: aValue
	
	(self checkCandidatesPath: aValue) ifFalse: [^aValue].
	(self candidatesPath = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #candidatesPath:) = aValue 
		ifTrue: [ self clearAsRefined: #candidatesPath:]
		ifFalse: [  self setAsRefined: #candidatesPath:].

	candidatesPath := aValue.
	self markDirty.

	self updateRefinements: #candidatesPath: value: aValue.

	self changed: #candidatesPath!

computationKind: aValue
	
	(self checkComputationKind: aValue) ifFalse: [^aValue].
	(self computationKind = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #computationKind:) = aValue 
		ifTrue: [ self clearAsRefined: #computationKind:]
		ifFalse: [  self setAsRefined: #computationKind:].

	computationKind := aValue.
	self markDirty.

	self updateRefinements: #computationKind: value: aValue.

	self changed: #computationKind!

initializationExpression: aValue
	
	(self checkInitializationExpression: aValue) ifFalse: [^aValue].
	(self initializationExpression = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #initializationExpression:) = aValue 
		ifTrue: [ self clearAsRefined: #initializationExpression:]
		ifFalse: [  self setAsRefined: #initializationExpression:].

	initializationExpression := aValue.
	self markDirty.

	self updateRefinements: #initializationExpression: value: aValue.

	self changed: #initializationExpression!

isAbstract: aValue
	
	(self checkIsAbstract: aValue) ifFalse: [^aValue].
	(self isAbstract = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isAbstract:) = aValue 
		ifTrue: [ self clearAsRefined: #isAbstract:]
		ifFalse: [  self setAsRefined: #isAbstract:].

	isAbstract := aValue.
	self markDirty.

	self updateRefinements: #isAbstract: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isAbstract!

isChangeable: aValue
	
	(self checkIsChangeable: aValue) ifFalse: [^aValue].
	(self isChangeable = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isChangeable:) = aValue 
		ifTrue: [ self clearAsRefined: #isChangeable:]
		ifFalse: [  self setAsRefined: #isChangeable:].

	isChangeable := aValue.
	self markDirty.

	self updateRefinements: #isChangeable: value: aValue.

	self changed: #isChangeable!

isDuplicatesAllowed: aValue
	
	(self checkIsDuplicatesAllowed: aValue) ifFalse: [^aValue].
	(self isDuplicatesAllowed = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isDuplicatesAllowed:) = aValue 
		ifTrue: [ self clearAsRefined: #isDuplicatesAllowed:]
		ifFalse: [  self setAsRefined: #isDuplicatesAllowed:].

	isDuplicatesAllowed := aValue.
	self markDirty.

	self updateRefinements: #isDuplicatesAllowed: value: aValue.

	self changed: #isDuplicatesAllowed!

isExclussion: aValue
	
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	(self isExclussion = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isExclussion:) = aValue 
		ifTrue: [ self clearAsRefined: #isExclussion:]
		ifFalse: [  self setAsRefined: #isExclussion:].

	isExclussion := aValue.
	self markDirty.

	self updateRefinements: #isExclussion: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isExclussion!

isIDAttribute: aValue
	
	(self checkIsIDAttribute: aValue) ifFalse: [^aValue].
	(self isIDAttribute = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isIDAttribute:) = aValue 
		ifTrue: [ self clearAsRefined: #isIDAttribute:]
		ifFalse: [  self setAsRefined: #isIDAttribute:].

	isIDAttribute := aValue.
	self markDirty.

	self updateRefinements: #isIDAttribute: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isIDAttribute!

isInitializationPropagationAllowed: aValue
	
	(self checkIsInitializationPropagationAllowed: aValue) ifFalse: [^aValue].
	(self isInitializationPropagationAllowed = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isInitializationPropagationAllowed:) = aValue 
		ifTrue: [ self clearAsRefined: #isInitializationPropagationAllowed:]
		ifFalse: [  self setAsRefined: #isInitializationPropagationAllowed:].

	isInitializationPropagationAllowed := aValue.
	self markDirty.

	self updateRefinements: #isInitializationPropagationAllowed: value: aValue.

	self changed: #isInitializationPropagationAllowed!

isInitializationPropagationOnConnectAllowed: aValue
	
	(self checkIsInitializationPropagationOnConnectAllowed: aValue) ifFalse: [^aValue].
	(self isInitializationPropagationOnConnectAllowed = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isInitializationPropagationOnConnectAllowed:) = aValue 
		ifTrue: [ self clearAsRefined: #isInitializationPropagationOnConnectAllowed:]
		ifFalse: [  self setAsRefined: #isInitializationPropagationOnConnectAllowed:].

	isInitializationPropagationOnConnectAllowed := aValue.
	self markDirty.

	self updateRefinements: #isInitializationPropagationOnConnectAllowed: value: aValue.

	self changed: #isInitializationPropagationOnConnectAllowed!

isNameAttribute: aValue
	
	(self checkIsNameAttribute: aValue) ifFalse: [^aValue].
	(self isNameAttribute = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isNameAttribute:) = aValue 
		ifTrue: [ self clearAsRefined: #isNameAttribute:]
		ifFalse: [  self setAsRefined: #isNameAttribute:].

	isNameAttribute := aValue.
	self markDirty.

	self updateRefinements: #isNameAttribute: value: aValue.

	self invalidateEffectiveAttributesCaches.

	self changed: #isNameAttribute!

maxMult: aValue

	(self checkMaxMult: aValue) ifFalse: [^aValue].
	(self maxMult = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #maxMult:) = aValue 
		ifTrue: [ self clearAsRefined: #maxMult:]
		ifFalse: [  self setAsRefined: #maxMult:].

	maxMult := aValue.
	self markDirty.

	self updateRefinements: #maxMult: value: aValue.

	self changed: #maxMult!

minMult: aValue
	
	(self checkMinMult: aValue) ifFalse: [^aValue].
	(self minMult = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #minMult:) = aValue 
		ifTrue: [ self clearAsRefined: #minMult:]
		ifFalse: [  self setAsRefined: #minMult:].

	minMult := aValue.
	self markDirty.

	self updateRefinements: #minMult: value: aValue.

	self changed: #minMult!

orderConstraint: aValue
	
	(self checkOrderConstraint: aValue) ifFalse: [^aValue].
	(self orderConstraint = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #orderConstraint:) = aValue 
		ifTrue: [ self clearAsRefined: #orderConstraint:]
		ifFalse: [  self setAsRefined: #orderConstraint:].

	orderConstraint := aValue.
	self markDirty.

	self updateRefinements: #orderConstraint: value: aValue.

	self changed: #orderConstraint!

reengineredInstVarName: aValue
	
	(self checkReengineredInstVarName: aValue) ifFalse: [^aValue].
	(self reengineredInstVarName = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #reengineredInstVarName:) = aValue 
		ifTrue: [ self clearAsRefined: #reengineredInstVarName:]
		ifFalse: [  self setAsRefined: #reengineredInstVarName:].

	reengineredInstVarName := aValue.
	self markDirty.

	self updateRefinements: #reengineredInstVarName: value: aValue.

	self changed: #reengineredInstVarName!

valueConstraint: aValue
	
	(self checkValueConstraint: aValue) ifFalse: [^aValue].
	(self valueConstraint = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #valueConstraint:) = aValue 
		ifTrue: [ self clearAsRefined: #valueConstraint:]
		ifFalse: [  self setAsRefined: #valueConstraint:].

	valueConstraint := aValue.
	self markDirty.

	self updateRefinements: #valueConstraint: value: aValue.

	self changed: #valueConstraint!

valueTypeName: aValue
	
	(self checkValueTypeName: aValue) ifFalse: [^aValue].
	(self valueTypeName = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #valueTypeName:) = aValue 
		ifTrue: [ self clearAsRefined: #valueTypeName:]
		ifFalse: [  self setAsRefined: #valueTypeName:].

	valueTypeName := aValue.
	self markDirty.

	self updateRefinements: #valueTypeName: value: aValue.

	self changed: #valueTypeName! !

!CODEAttributeRefinement publicMethodsFor: 'association initialize-release'!

initRefinedAttributes
	"Generated by ISF/AD. Do not modify"
	refinedAttributes := OrderedCollection new.!

refinedAttributesRelease
	"Generated by ISF/AD. Do not modify"
	self refinedAttributes do: [:each | self refinedAttributesRemove: each]! !

!CODEAttributeRefinement publicMethodsFor: 'associations accessing'!

refinedAttributes
	"Generated by ISF/AD. Do not modify"
	^self refinedAttributesPrivate copy!

refinedAttributesAsArray
	"Generated by ISF/AD. Do not modify"
	^self refinedAttributes asArray! !

!CODEAttributeRefinement publicMethodsFor: 'associations modifying'!

refinedAttributesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRefinedAttributesAdd: aValue) ifFalse: [^aValue].
	(self refinedAttributesIncludes: aValue) ifTrue: [^aValue].
	(self refinedAttributesPrivateAdd: aValue) attributeRefinementsPrivateAdd: self.

	self invalidateEffectiveAttributesCaches.

	self changed: #refinedAttributes.

	^aValue!

refinedAttributesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self refinedAttributesIncludes: aValue) ifFalse: [^aValue].
	(self refinedAttributes indexOf: aValue) = self refinedAttributesSize ifTrue: [^aValue].
	self refinedAttributesPrivate remove: aValue.
	aRes := self refinedAttributesPrivateAdd: aValue.
	self invalidateEffectiveAttributesCaches.
	^aRes!

refinedAttributesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self refinedAttributesIncludes: aValue) ifFalse: [^aValue].
	(index := self refinedAttributes indexOf: aValue) = self refinedAttributesSize ifTrue: [^aValue].
	index = (self refinedAttributesSize -1)
		ifTrue:
			[self refinedAttributesPrivate remove: aValue.
			aRes := self refinedAttributesPrivateAdd: aValue.
			self notifyChangeAllRefinedAttributesChildSpecs.
			^aRes].
	aRes := self refinedAttributesPrivateMove: aValue beforeIndex: index + 2.
	self invalidateEffectiveAttributesCaches.

	^aRes!

refinedAttributesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self refinedAttributesIncludes: aValue) ifFalse: [^aValue].
	(self refinedAttributes indexOf: aValue) = 1 ifTrue: [^aValue].
	self refinedAttributesPrivateMove: aValue beforeIndex: 1.
	self invalidateEffectiveAttributesCaches.!

refinedAttributesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self refinedAttributesIncludes: aValue) ifFalse: [^aValue].
	(index := self refinedAttributes indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self refinedAttributesPrivateMove: aValue beforeIndex: index - 1.
	self invalidateEffectiveAttributesCaches.

	^aRes!

refinedAttributesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRefinedAttributesRemove: aValue) ifFalse: [^aValue].
	(self refinedAttributesPrivate remove: aValue ifAbsent: [^aValue]) attributeRefinementsPrivateRemove: self.
	self invalidateEffectiveAttributesCaches.

	self changed: #refinedAttributes.

	^aValue! !

!CODEAttributeRefinement publicMethodsFor: 'associations private'!

refinedAttributesPrivate
	"Generated by ISF/AD. Do not modify"
	refinedAttributes isNil
		ifTrue: [self initRefinedAttributes].
	^refinedAttributes!

refinedAttributesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self refinedAttributesPrivate add: aValue.
	self changed: #refinedAttributes.
	^aValue!

refinedAttributesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self refinedAttributes at: anIndex.
	self refinedAttributesPrivate remove: aValue.
	self refinedAttributesPrivate add: aValue before: obj.
	self changed: #refinedAttributes.
	^aValue!

refinedAttributesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self refinedAttributesPrivate remove: aValue.
	self changed: #refinedAttributes.
	^aValue! !

!CODEAttributeRefinement publicMethodsFor: 'associations testing'!

refinedAttributesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^refinedAttributes isNil
		ifTrue: [false]
		ifFalse: [self refinedAttributes includes: aValue]!

refinedAttributesSize
	"Generated by ISF/AD. Do not modify"
	^refinedAttributes isNil
		ifTrue: [0]
		 ifFalse: [refinedAttributes size]! !

!CODEAttributeRefinement publicMethodsFor: 'derived accessing'!

allRefinedAttributes

	| someAttributes |
	someAttributes := IdentitySet new: 13.
	self allRefinedAttributesInto: someAttributes.
	^someAttributes!

allRefinedAttributesInto: theSet

	(theSet includes: self) ifTrue: [ ^self].

	theSet add: self.

	self refinedAttributes do: [:anAttribute |  anAttribute allRefinedAttributesInto: theSet]!

allRefinedFeatures

	^self allRefinedAttributes!

refinedFeatures

	^self refinedAttributes!

withAllRefinedAttributesInto: theAttributes

	theAttributes isNil ifTrue: [ ^self].
	(theAttributes includes: self) ifTrue: [ ^self]. 
	theAttributes add: self.
	self refinedAttributesPrivate do: [:aAttribute |
		aAttribute withAlllRefinedAttributesInto: theAttributes
	].! !

!CODEAttributeRefinement publicMethodsFor: 'initialize-release'!

initTerminalMetaAttributesNotRefinedFrom: theAttribute
	theAttribute isNil ifTrue: [ ^self].
	(theAttribute isKindOf: CODEAttribute) ifFalse: [ ^self].

	self minMult: 					self class notRefinedMetaAttributeValue.
	self maxMult: 					self class notRefinedMetaAttributeValue.
	self isAbstract: 					self class notRefinedMetaAttributeValue.
	self reengineredInstVarName:	self class notRefinedMetaAttributeValue.
	self isExclussion: 				self class notRefinedMetaAttributeValue.
	self isNameAttribute: 			self class notRefinedMetaAttributeValue.
	self isIDAttribute: 				self class notRefinedMetaAttributeValue.
	self isChangeable: 				self class notRefinedMetaAttributeValue.
	self isDuplicatesAllowed: 		self class notRefinedMetaAttributeValue.
	self computationKind: 			self class notRefinedMetaAttributeValue.
	self orderConstraint: 			self class notRefinedMetaAttributeValue.
	self candidatesPath: 			self class notRefinedMetaAttributeValue.
	self candidatesConstraint: 		self class notRefinedMetaAttributeValue.
	self initializationExpression:  	self class notRefinedMetaAttributeValue.
	self valueConstraint: 			self class notRefinedMetaAttributeValue.
	self isPropagateUse:  			self class notRefinedMetaAttributeValue.
	self isJustUsed:					self class notRefinedMetaAttributeValue.!

release
	self changed: #objectDisconnectedOfTree.	
	self refinedAttributesRelease.

	super release.! !

!CODEAttributeRefinement publicMethodsFor: 'persistence-code'!

firstPersistenceIndexAttributeRefinement
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		self numberPersistenceEntriesAttribute  +
		1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexAttributeRefinement.

	theValues size < aFPI ifFalse: [  self initReferencedRefinedAttributesFromValues:  (theValues at: aFPI) ].

	theValues size < (aFPI + 1) ifFalse: [  self initRefinedMetaAttributeNamesFromValues:  (theValues at: (aFPI + 1)) ].!

initReferencedRefinedAttributesFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refinedAttributesPersistenceSymbol ifFalse: [ ^nil].

	refinedAttributesRefTmpValues := theValues.!

initRefinedMetaAttributeNamesFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	refinedMetaAttributeNames := IdentitySet new: (theValues size * 1.5) floor.
	theValues do: [:aValue |  | aValueAsSymbol | 
		aValueAsSymbol := aValue asSymbol.
		refinedMetaAttributeNames add: aValueAsSymbol 
	]!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	self referencedRefinedAttributeAsCodeStringOn: theStream indent: theIS.

	self refinedMetaAttributeNamesPersistenceAsCodeStringOn: theStream indent: theIS!

numberPersistenceEntriesAttributeRefinement
	^1!

ph2InitFromSolver: theSolver

	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedRefinedAttributesValuesFromSolver: theSolver.!

ph2InitReferencedRefinedAttributesValuesFromSolver: theSolver
	
	| someAttributes |

	(refinedAttributesRefTmpValues isNil or: [ refinedAttributesRefTmpValues isEmpty]) ifTrue: [ ^self halt].

	someAttributes := 
		CODEElement resolveOrNewReferencedAttributesCollectionFromPersistenceAsCode: refinedAttributesRefTmpValues  solver: theSolver.
	self refinedAttributesPrivate  addAll: someAttributes.
	someAttributes do: [:aC | aC attributeRefinementsPrivate add: self].

	refinedAttributesRefTmpValues := nil.!

referencedRefinedAttributeAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	theStream isNil ifTrue: [ ^self]. 


	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self refinedAttributesPrivate isNil not and: [ self refinedAttributesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class refinedAttributesPersistenceSymbol); cr
			].
			self refinedAttributesPrivate do:  [:anAttribute |
				anAttribute asReferenceAsCodeStringOn: theStream 
					indent: anIS , self indentStringForPersistenceAsCode
			].

			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

refinedMetaAttributeNamesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep someRefinedMetaAttributeNames |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.

	(someRefinedMetaAttributeNames isNil not and: [ someRefinedMetaAttributeNames isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream  nextPutAll: anIS;  nextPutAll: '('; nextPutAll: aSep.
				someRefinedMetaAttributeNames do: [:aMetaAttributeName | 
					theStream nextPutAll: (self pcForV: aMetaAttributeName) ; nextPutAll: aSep
				].
			 	theStream nextPutAll: ' )' ; cr
			].
		].! !

!CODEAttributeRefinement publicMethodsFor: 'semantic checking'!

checkRefinedAttributesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRefinedAttributesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEAttributeRefinement publicMethodsFor: 'semantic links'!

refinedAttributesCandidates
	"Generated by ISF/AD. Do not modify"
	^self refinedAttributes asArray!

refinedAttributeScope
	"Generated by ISF/AD. Do not modify"
	^nil!

refinedAttributesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEAttribute new!

refinedAttributesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self refinedAttributesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self refinedAttributesAdd: anObject.!

refinedAttributesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self refinedAttributesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self refinedAttributesCreate class
		ifUnchanged: [^self].
	self refinedAttributesAdd: anObject!

refinedAttributesScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEAttributeRefinement publicMethodsFor: 'semantic links-custom'!

refinedAttributesLinkCreate

	^nil! !

!CODEAttributeRefinement publicMethodsFor: 'testing'!

isRefinement
	^true! !

!CODEAttributeRefinement publicMethodsFor: 'updating refinements'!

clearAsRefined: theMetaAttributeName 
	
	| someRefinableMetaAttributeNames someRefinedMetaAttributeNames |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^self].

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.
	someRefinedMetaAttributeNames isNil  ifTrue: [ ^self].

	someRefinedMetaAttributeNames remove: theMetaAttributeName ifAbsent: [ nil].!

determineIfRefiningMetaAttributeNamed: theMetaAttributeName
	| anOwnValue aValueFromRefined |

	anOwnValue := self ownValue: theMetaAttributeName.
	aValueFromRefined := self valueFromRefined: theMetaAttributeName.

	(((anOwnValue isNil or: [ (anOwnValue isKindOf: Collection) and: [ anOwnValue isEmpty]]) and: [ 
		aValueFromRefined isNil or: [ (aValueFromRefined isKindOf: Collection) and: [ aValueFromRefined isEmpty]]]) or: [ anOwnValue = aValueFromRefined]) 
		ifTrue: [ self clearAsRefined: theMetaAttributeName]
		ifFalse: [  self setAsRefined: theMetaAttributeName].!

determineIfRefiningMetaAttributes

	| someRefinableMetaAttributeNames |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	someRefinableMetaAttributeNames do: [:aRefinableMetaAttributeName |
		self determineIfRefiningMetaAttributeNamed: aRefinableMetaAttributeName
	]!

ownValue: theMetaAttributeName 
	
	| someRefinableMetaAttributeNames aMetaAttributeName aValue |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [ ^nil].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^nil].

	aMetaAttributeName := (theMetaAttributeName copyWithout: $:) asSymbol.

	aValue := self perform: aMetaAttributeName.
	 ^aValue!

refinedMetaAttributeNames
	refinedMetaAttributeNames isNil ifTrue: [ refinedMetaAttributeNames := IdentitySet new: 29].
	^refinedMetaAttributeNames!

resetRefinedValueToInheritedValue: theMetaAttributeName 
	
	| someRefinableMetaAttributeNames someRefinedMetaAttributeNames anInheritedValue |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^self].

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.
	someRefinedMetaAttributeNames isNil  ifTrue: [ ^self].

	self clearAsRefined: theMetaAttributeName.

	anInheritedValue := self valueFromRefined: theMetaAttributeName.
	self perform: theMetaAttributeName with: anInheritedValue!

setAsRefined: theMetaAttributeName
	
	| someRefinableMetaAttributeNames someRefinedMetaAttributeNames |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^self].

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.
	someRefinedMetaAttributeNames isNil  ifTrue: [ ^self].

	someRefinedMetaAttributeNames add: theMetaAttributeName.!

updateFromRefined: theMetaAttributeName value: theValue
	
	| someRefinableMetaAttributeNames someRefinedMetaAttributeNames |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^self].

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.
	someRefinedMetaAttributeNames isNil ifTrue: [ ^self].

	(someRefinedMetaAttributeNames includes: theMetaAttributeName) ifTrue: [ ^self].

	self perform: theMetaAttributeName asSymbol with: theValue!

valueFromRefined: theMetaAttributeName 
	
	| someRefinableMetaAttributeNames someRefinedAttributes aMetaAttributeName |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [ ^nil].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^nil].

	aMetaAttributeName := (theMetaAttributeName copyWithout: $:) asSymbol.

	someRefinedAttributes := self refinedAttributes.
	someRefinedAttributes isNil  ifTrue: [ ^nil].

	someRefinedAttributes do: [:anAttribute | | aValue |
		aValue := anAttribute perform: aMetaAttributeName .
		aValue isNil ifFalse: [ ^aValue]
	].
	^nil! !

!CODEAttributeRefinement publicMethodsFor: 'utilities'!

becomeNotARefinement
	| aNewAttribute |
	aNewAttribute := self preferredAttributeClass new name: self name copy.
	aNewAttribute initTerminalMetaAttributesFrom: self.
	aNewAttribute typePrivate: self type.
	aNewAttribute valueTypePrivate: self valueType.
	self attributeRefinements do: [:anAttributeRefinement |
		aNewAttribute attributeRefinementsPrivateAdd: anAttributeRefinement
	].
	aNewAttribute become: self! !

!CODEcodeReengine class publicMethodsFor: 'examples'!

initialModelForCODEcore

	"CODEcoreReengine  initialModelForCODEcore"
	"CODEcoreReengine initialModelForCODEcore browsePath"

	| unModel unModule_core |
	unModel := CODEModel new name: 'CODEcore'.
	unModel storeClassName: #CODEModel.
	unModel storeMethodSelector: #codeModelStorage.

	unModule_core := CODEModule new name: 'Core'.
	unModel subModulesAdd: unModule_core.

	^unModel!

reengineCODEcore
	"CODEcodeReengine reengineCODEcore browsePath"

	^self reengineCODEcoreWith: self reengineForCODEcore.!

reengineCODEcoreWith: theReengine

	| aModel aModule |

	theReengine isNil ifTrue: [ ^nil].

	aModel := self  initialModelForCODEcore.
	aModel isNil ifTrue: [ ^nil].

	aModule := aModel moduleNamed: 'Core'.
	aModule isNil ifTrue: [ ^nil].
 
	theReengine reengineClassAndSubClasses: CODEElement 
		onModule: aModule  including: CODEgen publicClasses.

	^aModel!

reengineForCODEcore

	| aReengine |
	aReengine := self new name: 'ForCODEcore' copy.
	aReengine classPrefixes: #('CODE') copy.

	aReengine factoryForModel: 			CODEModel.
	aReengine factoryForModule: 		CODEModule.
	aReengine factoryForType: 			CODEType.
	aReengine factoryForAttribute: 		CODEAttribute.
	aReengine factoryForRelationship: 	CODERelationship.
	aReengine factoryForComment: 		CODEComment.
	aReengine factoryForParameter: 	CODEParameter.

	^aReengine! !

!CODEComment class publicMethodsFor: 'accessing'!

kind
	^#comment! !

!CODEComment class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEComment class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesComment, self modelEditorMETAPerspectivesGeneral, 
		super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesComment

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Text'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Text' )))
			nlsApp: 'CODE';
			nlsGroup: 'Comment_Perspectives';
			nlsItem: 'Text';
			nlsTranslation: 'Texto';
			yourself);
		yourself!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'IsDirty')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsComment!

modelEditorMETASelectorsComment

	"METAChildSpecAutoViewEditor openOn: CODEComment selector: #modelEditorMETASelectorsComment target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATextChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Text';
			basicSelector: #text;
			type: #Text;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Text';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Comment_Selectors';
			nlsItem: 'Text';
			nlsTranslation: 'Texto';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Element';
			basicSelector: #element;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Element';
			displaySelector: #name;
			objectClassName: #CODEElement;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Comment_Selectors';
			nlsItem: 'Text';
			nlsTranslation: 'Texto';
			yourself);

		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsComment.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsComment

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #()! !

!CODEComment publicMethodsFor: 'accessing'!

text
	"Generated by ISF/AD. Do not modify"
	text isNil
		ifTrue: [self initText].
	^text!

text: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkText: aValue) ifFalse: [^aValue].
	text := aValue asString.
	self markDirty.
	self changed: #text! !

!CODEComment publicMethodsFor: 'accessing-private'!

forceElement: theEement
	element := theEement.!

forzeText: aValue
	text := aValue.! !

!CODEComment publicMethodsFor: 'association initialize-release'!

elementRelease
	"Generated by ISF/AD. Do not modify"
	element == nil
		ifFalse:
			[element commentsPrivateRemove: self.
				element := nil.
				self changed: #element]! !

!CODEComment publicMethodsFor: 'associations accessing'!

element
	"Generated by ISF/AD. Do not modify"
	^element!

element: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkElement: aValue) ifFalse: [^aValue].
	element == aValue ifTrue: [ ^self].
	self elementRelease.
	element := aValue.
	aValue == nil ifFalse: [aValue commentsPrivateAdd: self].
	self changed: #element! !

!CODEComment publicMethodsFor: 'associations private'!

elementPrivate: aValue
	| aPrevValue |
	aPrevValue := element.
	element := aValue.
	self changed: #element.
	(element isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

forzeElement: aValue
	element := aValue.! !

!CODEComment publicMethodsFor: 'derived accessing'!

applicationConfiguration
	^self element isNil ifTrue: [ nil] ifFalse: [ self element applicationConfiguration]!

model
	^self element isNil ifTrue: [ nil] ifFalse: [ self element model]! !

!CODEComment publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self element isNil ifFalse: [ self element markDirtyOwner]
	].!

persistIfDirty
	^self element isNil ifFalse: [ self element persistIfDirty] ifTrue: [ nil]! !

!CODEComment publicMethodsFor: 'initialize-release'!

initText
	"Generated by ISF/AD. Do not modify"
	text := ''.!

release
	self changed: #objectDisconnectedOfTree.

	text := nil.
	self elementRelease.

	super release! !

!CODEComment publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aSep anElement |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	anElement := self element.

	anElement isNil  ifFalse: [  anElement allQualifiedNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

firstPersistenceIndexComment
	^self numberPersistenceEntriesElement + 1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.
	aFPI := self firstPersistenceIndexComment.

	self forzeText:	 (theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]).!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  text ); cr.!

numberPersistenceEntriesComment
	^1! !

!CODEComment publicMethodsFor: 'semantic checking'!

checkElement: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkText: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEComment publicMethodsFor: 'semantic links'!

elementCandidates
	"Generated by ISF/AD. Do not modify"
	^self element isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self element]!

elementCreate
	"Generated by ISF/AD. Do not modify"
	^CODEElement new!

elementLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self elementCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self element: anObject]!

elementLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self elementCandidates
		initially: self element
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self element: anObject.!

elementLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self elementCandidates
		initially: self element
		label: 'Select Or Create ...'
		class: self elementCreate class
		ifUnchanged: [^self].
	self element: anObject!

elementScope
	"Generated by ISF/AD. Do not modify"
	^nil!

textCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self text!

textCreate
	"Generated by ISF/AD. Do not modify"
	^''!

textLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self text: self textCreate.!

textLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self textCandidates
		initially: self text
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self text: anObject.!

textLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self textCandidates
		initially: self text
		label: 'Select Or Create ...'
		class: self textCreate class
		ifUnchanged: [^self].
	self text: anObject!

textScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODECommentedElement class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		self modelEditorMETAPerspectivesCommentedElement, super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesCommentedElement

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'FirstComment'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'FirstComment' )))
			nlsApp: 'CODE';
			nlsGroup: 'CommentedElement_Perspectives';
			nlsItem: 'FirstComment';
			nlsTranslation: 'PrimerComentario';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Comments'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Comments' )))
			nlsApp: 'CODE';
			nlsGroup: 'CommentedElement_Perspectives';
			nlsItem: 'Comments';
			nlsTranslation: 'Comentarios';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsCommentedElement!

modelEditorMETASelectorsCommentedElement

	"METAChildSpecAutoViewEditor openOn: CODEAttribute selector: #modelEditorMETASelectorsAttribute target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'FirstComment';
			basicSelector: #firstComment;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'FirstComment';
			displaySelector: nil;
			objectClassName: #CODEType;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'CommentedElement_Selectors';
			nlsItem: 'FirstComment';
			nlsTranslation: 'PrimerComentario';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Comments';
			basicSelector: #comments;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Comments';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComment;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'CommentedElement_Selectors';
			nlsItem: 'Comments';
			nlsTranslation: 'Comentarios';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsCommentedElement.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsCommentedElement

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('FirstComment' 'Comments' )! !

!CODECommentedElement publicMethodsFor: 'association initialize-release'!

commentsRelease
	"Generated by ISF/AD. Do not modify"
	self comments do: [:each | self commentsRemove: each]!

initComments
	"Generated by ISF/AD. Do not modify"
	comments := OrderedCollection new.!

populateComments
	"Generated by ISF/AD. Do not modify"
	| aComment aIsDirty someComments |
	someComments := self commentsPrivate.
	someComments isNil ifTrue: [ ^self].
	someComments isEmpty ifFalse: [ ^self].

	aIsDirty := self isDirty.
	aComment := self preferredCommentClass new name: 'Description'.

	aComment forzeElement: self.
	self commentsPrivate add: aComment.
	aIsDirty ifFalse: [ self cleanDirtyMark].
	aComment cleanDirtyMark.! !

!CODECommentedElement publicMethodsFor: 'associations accessing'!

comments
	"Generated by ISF/AD. Do not modify"
	| someComments |
	someComments := self commentsPrivate copy.
	someComments isEmpty ifTrue: [  
		self populateComments.
		someComments := self commentsPrivate copy
	].
	
	^someComments!

commentsAsArray
	"Generated by ISF/AD. Do not modify"
	^self comments asArray! !

!CODECommentedElement publicMethodsFor: 'associations modifying'!

commentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkCommentsAdd: aValue) ifFalse: [^aValue].
	(self commentsIncludes: aValue) ifTrue: [^aValue].
	(self commentsPrivateAdd: aValue) elementPrivate: self.
	self changed: #comments.
	^aValue!

commentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkCommentsRemove: aValue) ifFalse: [^aValue].
	(self commentsPrivate remove: aValue ifAbsent: [^aValue]) elementPrivate: nil.
	self changed: #comments.
	^aValue! !

!CODECommentedElement publicMethodsFor: 'associations private'!

commentsPrivate
	"Generated by ISF/AD. Do not modify"
	comments isNil
		ifTrue: [self initComments].
	^comments!

commentsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self commentsPrivate add: aValue.
	self markDirty.
	self changed: #comments.
	^aValue!

commentsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self commentsPrivate remove: aValue.
	self markDirty.
	self changed: #comments.
	^aValue!

forzeComments: theComments
	(theComments isNil or: [ theComments isEmpty]) ifTrue: [ ^self].
	self commentsPrivate addAll: theComments.
	theComments do: [:aP | aP forceElement: self].! !

!CODECommentedElement publicMethodsFor: 'associations testing'!

commentsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^comments isNil
		ifTrue: [false]
		ifFalse: [self comments includes: aValue]!

commentsSize
	"Generated by ISF/AD. Do not modify"
	^comments isNil
		ifTrue: [0]
		 ifFalse: [comments size]! !

!CODECommentedElement publicMethodsFor: 'derived accessing'!

allQualifiedNames
	| aCollection |
	aCollection := OrderedCollection new: 8.
	self allQualifiedNamesInto: aCollection.
	^aCollection!

firstComment
	| someComments |
	someComments := self comments.
	(someComments isNil or: [ someComments isEmpty]) ifTrue: [ ^nil].
	^someComments first! !

!CODECommentedElement publicMethodsFor: 'dirty'!

cleanDirtyMark
	super cleanDirtyMark.

	self commentsPrivate isNil ifFalse: [ self commentsPrivate do: [:aComment | aComment cleanDirtyMark]]! !

!CODECommentedElement publicMethodsFor: 'initialize-release'!

release
	self changed: #objectDisconnectedOfTree.

	self commentsRelease.
	super release! !

!CODECommentedElement publicMethodsFor: 'persistence-code'!

commentsPersistenceAsCodeStringOn: theStream indent: theIS
		

	| anIS aSep |
	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self commentsPrivate isNil not and: [ self commentsPrivate isEmpty not and:  [ 
		self commentsPrivate size > 1 or: [ self commentsPrivate first text isEmpty not]]]) 
		ifFalse: [  
			theStream isNil ifFalse: [  
				theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil).
				self hasParametersPersistence ifTrue: [ theStream cr] ifFalse: [ theStream space]]
		]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
			     	nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class commentsPersistenceSymbol); cr; cr
			].
			self commentsPrivate do:  [:aComment |
				aComment persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr; cr]
		].!

firstPersistenceIndexCommentedElement
	^self numberPersistenceEntriesElement +
   		 1!

hasCommentsPersistence
		
	^(self commentsPrivate isNil not and: [ self commentsPrivate isEmpty not and:  [ 
		self commentsPrivate size > 1 or: [ self commentsPrivate first text isEmpty not]]])!

initCommentsFromValues: theValues 
	
	| someComments |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someComments := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someComments isNil ifFalse: [ 
		self commentsPrivate addAll: someComments.
		someComments do: [:aC | aC elementPrivate: self]]!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.
	aFPI := self firstPersistenceIndexCommentedElement.

	theValues size < aFPI ifFalse: [  self initCommentsFromValues: (theValues at: aFPI) ].!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	self commentsPersistenceAsCodeStringOn: theStream indent: theIS.!

numberPersistenceEntriesCommentedElement
	^1! !

!CODECommentedElement publicMethodsFor: 'semantic checking'!

checkCommentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCommentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODECommentedElement publicMethodsFor: 'semantic links'!

commentsCandidates
	"Generated by ISF/AD. Do not modify"
	^self comments asArray!

commentsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEComment new!

commentsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self commentsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self commentsAdd: anObject]!

commentsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self commentsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self commentsAdd: anObject.!

commentsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self commentsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self commentsCreate class
		ifUnchanged: [^self].
	self commentsAdd: anObject!

commentsScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEComponent class publicMethodsFor: 'accessing'!

kind
	^#component! !

!CODEComponent class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEComponent class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		self modelEditorMETAPerspectivesType, super modelEditorMETAPerspectives, 
		self modelEditorMETAPerspectivesTranslation!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'AllContainerNamespaceNames' 'IsDirty' 'IsUse' 'IsAbstract' 'IsEnumeration' 'IsPrimitive' 'IsExclussion' 'IsVirtual'  'IsHomeRooted' 'IsHomeIDProvider' 'PrimitiveInitializationString' 'ReengineredClassName' 'StoreClassName' 'StoreMethodSelector')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesType
 	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Relationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Relationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Attributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Attributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Operations'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Operations' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'SuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllSuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllSuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllNonAbstractSuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllNonAbstractSuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTiposNoAbstractos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'SubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllSubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllSubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllNonAbstractSubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllNonAbstractSubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllNonAbstractSubTypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);

		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAggregatedRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAggregatedRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAggregatedRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAggregatedRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAggregatedRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAttributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAttributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfAttributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfAttributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfAttributes';
			nlsTranslation: 'TipoDeAtributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfArguments'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfArguments' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfArguments';
			nlsTranslation: 'TipoDeArgumentosDeOperacion';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfReturns'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfReturns' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfReturns';
			nlsTranslation: 'TipoDeResultadosDeOperacion';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllRelationships';
			nlsTranslation: 'TodasLasRelaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonRefinedRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonRefinedRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonRefinedRelationships';
			nlsTranslation: 'TodasLasRelacionesNoRefinadas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionados';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllPolymorphicallyRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllPolymorphicallyRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllPolymorphicallyRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionadosPolimorficamente';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllEffectiveFeatures'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllEffectiveFeatures' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllEffectiveFeatures';
			nlsTranslation: 'TodasLasCaracteristicasEfectivas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Module'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Module' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Module';
			nlsTranslation: 'Modulo';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Observers'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Observers' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Observers';
			nlsTranslation: 'Observadores';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Types'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Types' )))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'Types';
			nlsTranslation: 'Tipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RootTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('RootTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'RootTypes';
			nlsTranslation: 'TodosLosTiposSinSuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'AllTypes';
			nlsTranslation: 'TodosLosTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllNonAbstractTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'AllNonAbstractTypes';
			nlsTranslation: 'TodosLosTiposNoAbstractos';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsType,
		self modelEditorMETASelectorsTranslation!

modelEditorMETASelectorsType

	"METAChildSpecAutoViewEditor openOn: CODEComponent selector: #modelEditorMETASelectorsType target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsUse';
			basicSelector: #isUse;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsUse';
			displaySelector: nil;
			canShowInTree: false;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsUse';
			nlsTranslation: 'EsUso';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsEnumeration';
			nlsTranslation: 'EsEnumeracion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsPrimitive';
			nlsTranslation: 'EsPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsVirtual';
			basicSelector: #isVirtual;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsVirtual';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsVirtual';
			nlsTranslation: 'EsVirtual';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeRooted';
			basicSelector: #isHomeRooted;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeRooted';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeRooted';
			nlsTranslation: 'EsArraigadoEnOrigen';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeIDProvider';
			basicSelector: #isHomeIDProvider;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeIDProvider';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeIDProvider';
			nlsTranslation: 'OrigenProveeIDs';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrimitiveInitializationString';
			basicSelector: #primitiveInitializationString;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrimitiveInitializationString';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'PrimitiveInitializationString';
			nlsTranslation: 'InicializacionValorPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReengineredClassName';
			basicSelector: #reengineredClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ReengineredClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'ReengineredClassName';
			nlsTranslation: 'NombreDeClasePrograma';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreClassName';
			basicSelector: #storeClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreClassName';
			nlsTranslation: 'ClaseDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreMethodSelector';
			basicSelector: #storeMethodSelector;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreMethodSelector';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreMethodSelector';
			nlsTranslation: 'SelectorDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Operations';
			basicSelector: #operations;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Operations';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSuperTypes';
			basicSelector: #withAllSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSuperTypes';
			basicSelector: #withAllNonAbstractSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'COnTodosLosSuperTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSubTypes';
			basicSelector: #withAllSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSubTypes';
			basicSelector: #withAllNonAbstractSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSubtypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSubtypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregationRelationships';
			basicSelector: #allAggregationRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregationRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregationRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);

		addAll: self modelEditorMETASelectorsType2;
		addAll: self modelEditorMETASelectorsType3;

		yourself!

modelEditorMETASelectorsType2

	"METAChildSpecAutoViewEditor openOn: CODEComponent selector: #modelEditorMETASelectorsType2 target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelationships';
			basicSelector: #allNonDummyRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonDummyRelationships';
			nlsTranslation: 'AllNonDummyRelationships';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelationships';
			basicSelector: #allRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllRelationships';
			nlsTranslation: 'TodasLasRelaciones';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonRefinedRelationships';
			basicSelector: #allNonRefinedRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonRefinedRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonRefinedRelationships';
			nlsTranslation: 'TodasLasRelacionesNoRefinadas';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelatedTypes';
			basicSelector: #allNonDummyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelatedTypes';
			basicSelector: #allRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllPolymorphicallyRelatedTypes';
			basicSelector: #allPolymorphicallyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllPolymorphicallyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllPolymorphicallyRelatedTypes';
			nlsTranslation: 'TodosLosTiposPolimorficamenteRelacionados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyAggregationRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Module';
			basicSelector: #module;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Module';
			displaySelector: #name;
			canShowInTree: true;
			objectClassName: #CODEModule;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Module';
			nlsTranslation: 'Modulo';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfAttributes';
			basicSelector: #typeOfValues;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfAttributes';
			nlsTranslation: 'TipoDeAtributos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfArguments';
			basicSelector: #typeOfArguments;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfArguments';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEArgument;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfArguments';
			nlsTranslation: 'TipoDeArgumentosDeOperacion';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfOperationReturns';
			basicSelector: #typeOfReturns;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfOperationReturns';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfOperationReturns';
			nlsTranslation: 'TipoDeResultadosDeOperacion';
			yourself);

		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllEffectiveFeatures';
			basicSelector: #allEffectiveFeatures;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllEffectiveFeatures';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEElement;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllEffectiveFeatures';
			nlsTranslation: 'TodasLasCaracteristicasEfectivas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Observers';
			basicSelector: #observers;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Observers';
			displaySelector: #displayName;
			canShowInTree: true;
			componentsClassName: #CMTypeObserver;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Observers';
			nlsTranslation: 'Observadores';
			yourself);
		yourself!

modelEditorMETASelectorsType3

	"METAChildSpecAutoViewEditor openOn: CODEComponent selector: #modelEditorMETASelectorsType3 target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Types';
			basicSelector: #types;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types';
			displaySelector: #name;
			componentsClassName: #CODEComponent;
			sortSelector: #nlsName;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Types';
			nlsTranslation: 'Tipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RootTypes';
			basicSelector: #rootTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types without Supertypes';
			displaySelector: #name;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'RootTypes';
			nlsTranslation: 'TiposRaiz';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllTypes';
			basicSelector: #allTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'All the Types in the Module and subModules';
			displaySelector: #name;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllTypes';
			nlsTranslation: 'TodosLosTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractTypes';
			basicSelector: #allNonAbstractTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractTypes';
			displaySelector: #name;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractTypes';
			nlsTranslation: 'TodosLosTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllContainerNamespaceNames';
			basicSelector: #allContainerNamespaceNames;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllContainerNamespaceNames';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllContainerNamespaceNames';
			nlsTranslation: 'Namespace contenedor completamente cualificado';
			yourself);

		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsType.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsType

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('Relationships' 'Attributes' 'Operations' 'SuperTypes' 'SubTypes'  'TypeOfAttributes' 'TypeOfArguments' 'TypeOfReturns' 'AllEffectiveFeatures' 'WithAllSuperTypes'  'WithAllNonAbstractSuperTypes'  'WithAllSubTypes'  'WithAllNonAbstractSubTypes' 
			'AllAggregatedRelatedTypes' 'AllAggregatedRelationships' 'AllAttributes' 'AllRelationships' 'AllNonRefinedRelationships' 'AllRelatedTypes' 
			'AllPolymorphicallyRelatedTypes'  'AllNonAbstractPolymorphicallyRelatedTypes' 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes' 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes' 'Observers'  'Types'  'RootTypes' 'AllTypes' 'AllNonAbstractTypes')!

xmetaSelectors

	"METAChildSpecAutoViewEditor openOn: CODEComponent selector: #metaSelectors target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 27)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Name';
			basicSelector: #name;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Name';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelationships';
			basicSelector: #allAggregatedRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelationships';
			basicSelector: #allNonDummyRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelationships';
			basicSelector: #allRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelatedTypes';
			basicSelector: #allNonDummyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODEComponent;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelatedTypes';
			basicSelector: #allRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODEComponent;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: #superType;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelationshipsToGenerate';
			basicSelector: #relationshipsToGenerate;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelationshipsToGenerate';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: #superType;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AttributesToGenerate';
			basicSelector: #attributesToGenerate;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AttributesToGenerate';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			componentsClassName: #CODEComponent;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelatedWith';
			basicSelector: #relatedWith;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelatedWith';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Module';
			basicSelector: #module;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Module';
			displaySelector: #name;
			objectClassName: #CODEModule;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Model';
			basicSelector: #model;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Model';
			displaySelector: #name;
			objectClassName: #CODEModel;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'BaseOutFileName';
			basicSelector: #baseOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'BaseOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ImplOutFileName';
			basicSelector: #implOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ImplOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IfcOutFileName';
			basicSelector: #ifcOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IfcOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TrxOutFileName';
			basicSelector: #trxOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TrxOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrivOutFileName';
			basicSelector: #privOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrivOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Skip';
			basicSelector: #skip;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Skip';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsRootType';
			basicSelector: #isRootType;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsRootType';
			displaySelector: nil;
			yourself);
		yourself!

xmodelEditorMETASelectorsType

	"METAChildSpecAutoViewEditor openOn: CODEComponent selector: #modelEditorMETASelectorsType target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsUse';
			basicSelector: #isUse;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsUse';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsUse';
			nlsTranslation: 'EsUso';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsEnumeration';
			nlsTranslation: 'EsEnumeracion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsPrimitive';
			nlsTranslation: 'EsPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsVirtual';
			basicSelector: #isVirtual;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsVirtual';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsVirtual';
			nlsTranslation: 'EsVirtual';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeRooted';
			basicSelector: #isHomeRooted;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeRooted';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeRooted';
			nlsTranslation: 'EsArraigadoEnOrigen';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeIDProvider';
			basicSelector: #isHomeIDProvider;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeIDProvider';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeIDProvider';
			nlsTranslation: 'OrigenProveeIDs';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrimitiveInitializationString';
			basicSelector: #primitiveInitializationString;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrimitiveInitializationString';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'PrimitiveInitializationString';
			nlsTranslation: 'InicializacionValorPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReengineredClassName';
			basicSelector: #reengineredClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ReengineredClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'ReengineredClassName';
			nlsTranslation: 'NombreDeClasePrograma';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreClassName';
			basicSelector: #storeClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreClassName';
			nlsTranslation: 'ClaseDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreMethodSelector';
			basicSelector: #storeMethodSelector;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreMethodSelector';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreMethodSelector';
			nlsTranslation: 'SelectorDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Operations';
			basicSelector: #operations;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Operations';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSuperTypes';
			basicSelector: #withAllSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSuperTypes';
			basicSelector: #withAllNonAbstractSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'COnTodosLosSuperTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSubTypes';
			basicSelector: #withAllSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSubTypes';
			basicSelector: #withAllNonAbstractSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSubtypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEComponent;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSubtypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregationRelationships';
			basicSelector: #allAggregationRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregationRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregationRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);

		addAll: self modelEditorMETASelectorsType2;
		addAll: self modelEditorMETASelectorsType3;

		yourself! !

!CODEComponent class publicMethodsFor: 'persistence-code'!

attributesPersistenceSymbol	
	^#attributes!

refToSuperTypeKindSymbol
	^self refToTypeKindSymbol!

relationshipsPersistenceSymbol	
	^#relationships!

superTypesPersistenceSymbol	
	^#supertypes! !

!CODEComponent publicMethodsFor: 'accessing'!

isAbstract
	"Generated by ISF/AD. Do not modify"
	isAbstract isNil
		ifTrue: [self initIsAbstract].
	^isAbstract!

isAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsAbstract: aValue  == true) ifFalse: [^aValue].
	isAbstract := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isAbstract.
	self allPolymorphicallyRelatedTypes do: [:aT | 
		aT changed: #allNonAbstractPolymorphicallyRelatedTypes].!

isEnumeration
	"Generated by ISF/AD. Do not modify"
	isEnumeration isNil
		ifTrue: [self initIsEnumeration].
	^isEnumeration!

isEnumeration: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsEnumeration: aValue  == true) ifFalse: [^aValue].
	isEnumeration := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isEnumeration!

isExclussion
	"Generated by ISF/AD. Do not modify"
	isExclussion isNil
		ifTrue: [self initIsExclussion].
	^isExclussion!

isExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	isExclussion := aValue.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isExclussion!

isHomeRooted
	isHomeRooted isNil
		ifTrue: [self initIsHomeRooted].
	^isHomeRooted!

isHomeRooted: aValue
	(self checkIsHomeRooted: aValue  == true) ifFalse: [^aValue].
	isHomeRooted := aValue == true.
	self markDirty.
	self changed: #isHomeRooted!

isJustUsed
	"Generated by ISF/AD. Do not modify"
	isJustUsed isNil
		ifTrue: [self initIsJustUsed].
	^isJustUsed!

isJustUsed: aValue
	self isJustUsed = aValue ifTrue: [ ^aValue].
	isJustUsed := aValue == true.

	self changed: #isJustUsed.!

isPrimitive
	"Generated by ISF/AD. Do not modify"
	isPrimitive isNil
		ifTrue: [self initIsPrimitive].
	^isPrimitive!

isPrimitive: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsPrimitive: aValue  == true) ifFalse: [^aValue].
	isPrimitive := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.
	self changed: #isPrimitive!

isUse
	"Generated by ISF/AD. Do not modify"
	isUse isNil
		ifTrue: [self initIsUse].
	^isUse!

isUse: aValue
	(self checkIsUse: aValue  == true) ifFalse: [^aValue].
	self isUse = aValue ifTrue: [ ^aValue].
	isUse := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self updateUses.

	self changed: #isUse.!

name: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkName: aValue) ifFalse: [^aValue].
	name := aValue.
	self markDirty.
	self changed: #name.

	self notifyFullyQualifiedNameChanged!

observers
	^observers!

primitiveInitializationString
	^primitiveInitializationString!

primitiveInitializationString: aValue
	primitiveInitializationString := aValue.
	self changed: #primitiveInitializationString!

reengineredClassName
	^reengineredClassName!

reengineredClassName: aValue
	reengineredClassName := aValue.
	self changed: #reengineredClassName!

storeClassName
	^storeClassName!

storeClassName: elValor
	| unValor unosStrings |
	unValor := (elValor isNil or: [ elValor isEmpty])
		ifTrue: [ nil] 
		ifFalse: [ 	
			unosStrings := elValor  asArrayOfSubstrings.
			unosStrings isEmpty
				ifTrue: [ nil]
				ifFalse: [ 
					unosStrings size > 1
						ifTrue: [ unosStrings first asSymbol]
						ifFalse: [ elValor asSymbol]
				]
		].
	
	unValor = storeClassName  ifTrue: [ ^self].

	storeClassName := unValor.
	self markDirty.

	self changed: #storeClassName!

storeMethodSelector
	^storeMethodSelector!

storeMethodSelector: elValor
	| unValor unosStrings |
	unValor := (elValor isNil or: [ elValor isEmpty])
		ifTrue: [ nil] 
		ifFalse: [ 	
			unosStrings := elValor  asArrayOfSubstrings.
			unosStrings isEmpty
				ifTrue: [ nil]
				ifFalse: [ 
					unosStrings size > 1
						ifTrue: [ unosStrings first asSymbol]
						ifFalse: [ elValor asSymbol]
				]
		].
	
	unValor = storeMethodSelector  ifTrue: [ ^self].

	storeMethodSelector := unValor.
	self markDirty.

	self changed: #storeMethodSelector! !

!CODEComponent publicMethodsFor: 'accessing-find'!

hasTypeNamed: theTypeName
	
	^(self typeNamed: theTypeName) isNil not!

typeNamed: theTypeName
	
	| anExistingType |
	theTypeName isNil ifTrue: [ ^self].
	(theTypeName findString: '::' startingAt: 1 ) > 0 ifTrue: [  ^self findTypeNamed: theTypeName].

	anExistingType := self typesPrivate detect: [:aType | aType name = theTypeName] ifNone: [ nil].
	^anExistingType! !

!CODEComponent publicMethodsFor: 'accessing-private'!

forzeIsAbstract: aValue
	isAbstract := aValue == true.!

forzeIsEnumeration: aValue
	isEnumeration := aValue == true.!

forzeIsExclussion: aValue
	isExclussion := aValue == true.!

forzeIsHomeRooted: aValue
	isHomeRooted := aValue == true.!

forzeIsJustUsed: aValue
	isJustUsed := aValue == true.!

forzeIsPrimitive: aValue
	isPrimitive := aValue == true.!

forzeIsUse: aValue
	isUse := aValue == true.!

forzePrimitiveInitializationString: aValue
	primitiveInitializationString := aValue!

forzeReengineredClassName: aValue
	reengineredClassName := aValue!

forzeStoreClassName: aValue
	storeClassName := aValue!

forzeStoreMethodSelector: aValue
	storeMethodSelector := aValue! !

!CODEComponent publicMethodsFor: 'association initialize-release'!

initSubTypes
	"Generated by ISF/AD. Do not modify"
	subTypes := IdentitySet new.!

initSuperTypes
	"Generated by ISF/AD. Do not modify"
	superTypes := OrderedCollection new.!

initTypes
	"Generated by ISF/AD. Do not modify"
	types := OrderedCollection new.!

moduleRelease
	"Generated by ISF/AD. Do not modify"
	module == nil
		ifFalse:
			[module typesPrivateRemove: self.
				module := nil.
				self changed: #module]!

subTypesRelease
	"Generated by ISF/AD. Do not modify"
	self subTypes do: [:each | self subTypesRemove: each]!

superTypesRelease
	"Generated by ISF/AD. Do not modify"
	self superTypes do: [:each | self superTypesRemove: each]!

typesRelease
	"Generated by ISF/AD. Do not modify"
	self types do: [:each | self typesRemove: each]! !

!CODEComponent publicMethodsFor: 'associations accessing'!

module
	"Generated by ISF/AD. Do not modify"
	^module!

module: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkModule: aValue) ifFalse: [^aValue].
	module == aValue ifTrue: [ ^self].
	self moduleRelease.
	module := aValue.
	aValue == nil ifFalse: [aValue typesPrivateAdd: self].
	self changed: #module!

subTypes
	"Generated by ISF/AD. Do not modify"
	^self subTypesPrivate copy!

subTypesAsArray
	"Generated by ISF/AD. Do not modify"
	^self subTypes asArray!

superTypes
	"Generated by ISF/AD. Do not modify"
	^self superTypesPrivate copy!

superTypesAsArray
	"Generated by ISF/AD. Do not modify"
	^self superTypes asArray!

types
	"Generated by ISF/AD. Do not modify"
	^self typesPrivate copy!

typesAsArray
	"Generated by ISF/AD. Do not modify"
	^self types asArray! !

!CODEComponent publicMethodsFor: 'associations modifying'!

subTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSubTypesAdd: aValue) ifFalse: [^aValue].
	(self subTypesIncludes: aValue) ifTrue: [^aValue].
	(self subTypesPrivateAdd: aValue) superTypesPrivateAdd: self.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ 
		aValue invalidateMemberInstanceTypesCache.
		aValue invalidateEffectiveFeaturesCaches
	].
	self changed: #subTypes.
	^aValue!

subTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSubTypesRemove: aValue) ifFalse: [^aValue].
	(self subTypesPrivate remove: aValue ifAbsent: [^aValue]) superTypesPrivateRemove: self.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ 
		aValue invalidateMemberInstanceTypesCache.
		aValue invalidateEffectiveFeaturesCaches
	].
	self changed: #subTypes.
	^aValue!

superTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSuperTypesAdd: aValue) ifFalse: [^aValue].
	(self superTypesIncludes: aValue) ifTrue: [^aValue].
	(self superTypesPrivateAdd: aValue) subTypesPrivateAdd: self.

	self invalidateEffectiveFeaturesCaches.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ aValue invalidateMemberInstanceTypesCache].

	self isUse ifTrue: [ self updateUses].
	self updateRefinedFeatures.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].

	^aValue!

superTypesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(self superTypes indexOf: aValue) = self superTypesSize ifTrue: [^aValue].
	self superTypesPrivate remove: aValue.
	aRes := self superTypesPrivateAdd: aValue.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(index := self superTypes indexOf: aValue) = self superTypesSize ifTrue: [^aValue].
	index = (self superTypesSize -1)
		ifTrue:
			[self superTypesPrivate remove: aValue.
			aRes := self superTypesPrivateAdd: aValue.
			self notifyChangeAllRelationshipsChildSpecs.
			^aRes].
	aRes := self superTypesPrivateMove: aValue beforeIndex: index + 2.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(self superTypes indexOf: aValue) = 1 ifTrue: [^aValue].
	self superTypesPrivateMove: aValue beforeIndex: 1.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].!

superTypesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(index := self superTypes indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self superTypesPrivateMove: aValue beforeIndex: index - 1.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSuperTypesRemove: aValue) ifFalse: [^aValue].
	(self superTypesPrivate remove: aValue ifAbsent: [^aValue]) subTypesPrivateRemove: self.

	self removeRefinementFeaturesFromMissingSuperTypes.

	self invalidateEffectiveFeaturesCaches.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ aValue invalidateMemberInstanceTypesCache].

	self isUse ifTrue: [ self updateUses].
	self updateRefinedFeatures.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].

	^aValue!

typesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesAdd: aValue) ifFalse: [^aValue].
	(self typesIncludes: aValue) ifTrue: [^self typesMoveBottom: aValue].
	(self typesPrivateAdd: aValue) modulePrivate: self.
	self changed: #types.
	^aValue!

typesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	self typesPrivate remove: aValue.
	^self typesPrivateAdd: aValue!

typesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	index = (self typesSize -1)
		ifTrue:
			[self typesPrivate remove: aValue.
			^self typesPrivateAdd: aValue].
	^self typesPrivateMove: aValue beforeIndex: index + 2!

typesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = 1 ifTrue: [^aValue].
	self typesPrivateMove: aValue beforeIndex: 1!

typesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = 1 ifTrue: [^aValue].
	^self typesPrivateMove: aValue beforeIndex: index - 1!

typesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesRemove: aValue) ifFalse: [^aValue].
	(self typesPrivate remove: aValue ifAbsent: [^aValue]) modulePrivate: nil.
	self changed: #types.
	^aValue! !

!CODEComponent publicMethodsFor: 'associations private'!

modulePrivate: aValue
	| aPrevValue |
	aPrevValue := module.
	module := aValue.
	self changed: #module.
	(module isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

subTypesPrivate
	"Generated by ISF/AD. Do not modify"
	subTypes isNil
		ifTrue: [self initSubTypes].
	^subTypes!

subTypesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self subTypesPrivate add: aValue.
	self changed: #subTypes.
	^aValue!

subTypesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self subTypesPrivate remove: aValue.
	self changed: #subTypes.
	^aValue!

superTypesPrivate
	"Generated by ISF/AD. Do not modify"
	superTypes isNil
		ifTrue: [self initSuperTypes].
	^superTypes!

superTypesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self superTypesPrivate add: aValue.
	self changed: #superTypes.
	^aValue!

superTypesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self superTypes at: anIndex.
	self superTypesPrivate remove: aValue.
	self superTypesPrivate add: aValue before: obj.
	self changed: #superTypes.
	^aValue!

superTypesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self superTypesPrivate remove: aValue.
	self changed: #superTypes.
	^aValue!

typesPrivate
	"Generated by ISF/AD. Do not modify"
	types isNil
		ifTrue: [self initTypes].
	^types!

typesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate add: aValue.
	self markDirty.

	self changed: #types.
	^aValue!

typesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self types at: anIndex.
	self typesPrivate remove: aValue.
	self typesPrivate add: aValue before: obj.
	self markDirty.

	self changed: #types.
	^aValue!

typesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate remove: aValue.
	self markDirty.

	self changed: #types.
	^aValue! !

!CODEComponent publicMethodsFor: 'associations testing'!

subTypesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^subTypes isNil
		ifTrue: [false]
		ifFalse: [self subTypes includes: aValue]!

subTypesSize
	"Generated by ISF/AD. Do not modify"
	^subTypes isNil
		ifTrue: [0]
		 ifFalse: [subTypes size]!

superTypesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^superTypes isNil
		ifTrue: [false]
		ifFalse: [self superTypes includes: aValue]!

superTypesSize
	"Generated by ISF/AD. Do not modify"
	^superTypes isNil
		ifTrue: [0]
		 ifFalse: [superTypes size]!

typesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [false]
		ifFalse: [self types includes: aValue]!

typesSize
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [0]
		 ifFalse: [types size]! !

!CODEComponent publicMethodsFor: 'changing'!

notifyFullyQualifiedNameChanged
	
	self changed: #allContainerNamespaceNames.

	self types do: [:aType | aType notifyFullyQualifiedNameChanged]! !

!CODEComponent publicMethodsFor: 'derivations cache'!

initEffectiveFeaturesCaches
	| someFeatures someAttributes someRelationships someOperations |

	effectiveAttributesCache := nil.
	effectiveRelationshipsCache := nil.
	effectiveStructuralFeaturesCache := nil.
	effectiveOperationsCache := nil.
	effectiveFeaturesCache := nil.
	effectiveIDAttributeCache := nil.
	effectiveNameAttributeCache := nil.

	someFeatures := self allEffectiveFeaturesNoCache.
	someFeatures isNil ifTrue: [ ^self].

	someAttributes := OrderedCollection new: someFeatures size.
	someRelationships := OrderedCollection new: someFeatures size.
	someOperations := OrderedCollection new: someFeatures size.

	someFeatures do: [:aFeature |
		aFeature isAttribute ifTrue: [ 
			someAttributes add: aFeature.
			effectiveIDAttributeCache isNil ifTrue: [ aFeature isIDAttribute ifTrue: [ effectiveIDAttributeCache := aFeature]].
			effectiveNameAttributeCache isNil ifTrue: [ aFeature isNameAttribute ifTrue: [ effectiveNameAttributeCache := aFeature]].
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [ someRelationships add: aFeature] ifFalse: [ 
		aFeature isOperation ifTrue: [ someOperations add: aFeature] ifFalse: [ 
		
		]]]
	].

	effectiveFeaturesCache := someFeatures.
	effectiveAttributesCache := someAttributes asArray.
	effectiveRelationshipsCache := someRelationships asArray.
	effectiveStructuralFeaturesCache := effectiveAttributesCache , effectiveRelationshipsCache.
	effectiveOperationsCache := someOperations asArray.
	effectiveFeaturesCache := effectiveStructuralFeaturesCache , effectiveOperationsCache.

	effectiveIDAttributeCache isNil ifTrue: [ effectiveIDAttributeCache := self class alreadyDerivedAttribute].
	effectiveNameAttributeCache isNil ifTrue: [ effectiveNameAttributeCache := self class alreadyDerivedAttribute].!

invalidateEffectiveFeaturesCaches
	| someSubTypes |

	effectiveAttributesCache := nil.
	effectiveRelationshipsCache := nil.
	effectiveStructuralFeaturesCache := nil.
	effectiveOperationsCache := nil.
	effectiveFeaturesCache := nil.
	effectiveIDAttributeCache  := nil.
	effectiveNameAttributeCache := nil.

	someSubTypes := self subTypes.
	someSubTypes isNil ifTrue: [ ^self].

	someSubTypes do: [:aSubType | aSubType  invalidateEffectiveFeaturesCaches]! !

!CODEComponent publicMethodsFor: 'derived accessing'!

allContainerModuleNamesInto: theStream

	| aModule |
	theStream isNil ifTrue: [ ^self].

	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].!

allContainerNamespaceNames

	self module isNil ifTrue: [ ^'' copy].
	^self module allNamespaceNames!

allContainerPackageNames

	self module isNil ifTrue: [ ^'' copy].
	^self module allPackageNames!

allDefinedAspectsInto: theSet
	theSet isNil ifTrue: [ ^self].

	super allDefinedAspectsInto: theSet.
	self attributes do: [:anAttribute | anAttribute allDefinedAspectsInto: theSet].
	self relationships do: [:aRelationship | aRelationship allDefinedAspectsInto: theSet].!

allFeatures

	| someFeatures someSortedFeatures |

	someFeatures := IdentitySet new: 37.

	self allFeaturesInto: someFeatures.
		
	someSortedFeatures := someFeatures asSortedCollection: [:aFeature :otherFeature |
		aFeature name < otherFeature name].

	^someSortedFeatures!

allFeaturesInto: theSet

	theSet isNil ifTrue: [ ^nil].

	theSet addAll: self attributes.
	theSet addAll: self relationships.

	self superTypes do: [:aType | 
		aType allFeaturesInto: theSet	
	].
		
	^theSet!

allLocalEffectiveFeatures

	| someAttributes someRelationships someFeatures |

	someAttributes := self attributes.
	someRelationships := self relationships.
	someFeatures := OrderedCollection new: someAttributes size + someRelationships size.
	someAttributes do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			someFeatures add: aFeature
		]
	].
	someRelationships do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			someFeatures add: aFeature
		]
	].
	^someFeatures!

allModuleNamesInto: theStream

	| aModule aSep |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

allModules

	| aModule someModules |
	aModule := self module.
	aModule isNil ifTrue: [ ^Array new].

	someModules := IdentitySet new: 13.
	aModule allModulesInto: someModules.
	^someModules!

allNamespaceNames
	| aPackages |
	self module isNil ifTrue: [ ^self name copy].
	aPackages := self module allNamespaceNames.
	^(aPackages isEmpty ifTrue: [''] ifFalse: [ aPackages , '::']) , self name!

allNonAbstractTypes
	| someTypes someNonAbstractTypes |
	someTypes := self allTypes.
	someNonAbstractTypes := someTypes reject: [:aType | aType isAbstract].
	^someNonAbstractTypes!

allPackageNames
	| aPackages |
	self module isNil ifTrue: [ ^self name copy].
	aPackages := self module allPackageNames.
	^(aPackages isEmpty ifTrue: [''] ifFalse: [ aPackages , '.']) , self name!

allSubTypes
	^self allSubtypes!

allSubtypes
	| someSubTypes |
	someSubTypes := IdentitySet new: 13.
	self subTypesPrivate do: [:aSubType |	
		aSubType allSubTypesInto: someSubTypes
	].
	^someSubTypes!

allSubtypes: theSubTypes includes: theType

	theSubTypes isNil ifFalse: [ 
		(theSubTypes includes: self) 
			ifTrue: [ ^false]
			ifFalse: [  theSubTypes add: self]
	].

	(self subTypesIncludes: theType) ifTrue: [ ^true].

	^(self subTypes detect: [:aSubtype | aSubtype allSubtypes: theSubTypes includes: theType] ifNone: [ nil]) notNil!

allSubtypesIncludes: theType
	| someSubTypes |
	someSubTypes := IdentitySet new.
	^self allSubtypes: someSubTypes includes: theType!

allSubTypesInto: theSubTypes
	
	^self allSubtypesInto: theSubTypes!

allSubtypesInto: theSubTypes
	
	(theSubTypes includes: self) ifTrue: [ ^self].
	theSubTypes add: self.
	self subTypesPrivate do: [:aSubype |	
		aSubype allSubtypesInto: theSubTypes
	]!

allSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesInto: someSuperTypes
	].
	^someSuperTypes!

allSuperTypesInto: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesInto: theSuperTypes
	].!

allSuperTypesWithFeature: theFeature
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesWithFeature: theFeature into: someSuperTypes
	].
	^someSuperTypes!

allSuperTypesWithFeature: theFeature into: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].
	
	(self hasEffectiveFeature: theFeature) ifFalse: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesWithFeature: theFeature into: theSuperTypes
	].!

allTypes
	| someTypes |
	someTypes := IdentitySet new: 111.
	self allTypesInto: someTypes.
	^someTypes!

allTypesInto: theSet
	| someTypes |
	theSet isNil ifTrue: [ ^self].

	someTypes := self typesPrivate.
	theSet addAll: someTypes.
	someTypes do: [:aType | aType allTypesInto: theSet].!

applicationConfiguration
	^self module isNil ifTrue: [ nil] ifFalse: [ self module applicationConfiguration]!

features
	^self attributesPrivate asArray , self relationshipsPrivate asArray!

fullyQualifiedName

	| aModuleFullyQualifiedName aFullyQualifiedName |
	self module isNil ifTrue: [ ^self name].
	
	aModuleFullyQualifiedName := self module fullyQualifiedName.
	(aModuleFullyQualifiedName isNil or: [ aModuleFullyQualifiedName isEmpty]) ifTrue: [ 
		^self name
	].

	aFullyQualifiedName := aModuleFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

fullyQualifiedNameArray

	| aModuleFullyQualifiedName aFullyQualifiedNameArray |
	self module isNil ifTrue: [ ^Array with: self name].
	
	aModuleFullyQualifiedName := self module fullyQualifiedNameArray.
	(aModuleFullyQualifiedName isNil or: [ aModuleFullyQualifiedName isEmpty]) ifTrue: [ 
		^Array with: self name
	].

	aFullyQualifiedNameArray := aModuleFullyQualifiedName, (Array with: self name).
	^aFullyQualifiedNameArray!

hasEffectiveFeature: theFeature

	| aResult |

	theFeature isNil  ifTrue: [ ^false].

	aResult := self allEffectiveFeatures includes: theFeature.
	^aResult!

hasEffectiveFeatureNamed: theName

	^(self effectiveFeatureNamed: theName) isNil not!

hasEffectiveStructuralFeature: theFeature

	| aResult |

	theFeature isNil  ifTrue: [ ^false].

	aResult := self allEffectiveStructuralFeatures includes: theFeature.
	^aResult!

hasIdCounter
	
	| someEffectiveAttributes aNonVirtualType |

	self isPrimitive ifTrue: [ ^false].
	self isEnumeration ifTrue: [ ^false].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^false].
	
	aNonVirtualType isPrimitive ifTrue: [ ^false].
	aNonVirtualType isEnumeration ifTrue: [ ^false].

	someEffectiveAttributes := self allEffectiveAttributes.
	(someEffectiveAttributes isNil or: [ someEffectiveAttributes isEmpty]) ifTrue: [ ^false].

	 ^(someEffectiveAttributes detect: [:anAttribute | anAttribute hasIdCounter] ifNone: [ nil]) isNil not!

hasSuperType: theSuperType

	theSuperType isNil ifTrue: [ ^false].

	^(self superTypesPrivate detect: [:aSuperType |
		aSuperType == theSuperType or: [
			aSuperType hasSuperType: theSuperType 
		]
	] ifNone: [ nil]) isNil not!

idAttribute

	| aIDAttribute |
	aIDAttribute := self allEffectiveAttributes detect: [:anAttribute | anAttribute isIDAttribute] ifNone: [ nil].
	^aIDAttribute!

isAggregated

	^(self allRelationships detect: [:aRelationship | aRelationship  isAggregated] ifNone: [ nil]) isNil not!

isVisibleInModules: 		theModules
	andAspects: 			theAspects
	definitionsHolder: 	theDefinitionsHolder

	((theModules isNil or: [ theModules isEmpty]) and: [  
		theAspects isNil or: [ theAspects isEmpty]]) ifTrue: [ 
		^true
	].

	^(  self isVisibleInModules: 	theModules definitionsHolder: 	theDefinitionsHolder) and: [ 
		self isVisibleInAspects: 	theAspects definitionsHolder: 	theDefinitionsHolder
	]!

isVisibleInModules: 		theModules
	definitionsHolder: 	theDefinitionsHolder


	| aThisModule |

	(theModules isNil or: [ theModules isEmpty]) ifTrue: [ ^true ].

	(theModules isNil not and: [ theModules isEmpty not]) ifTrue: [ 
		aThisModule := self module.
		aThisModule isNil ifTrue: [ ^false].
		(theModules includes: aThisModule) ifFalse: [ 
			(theModules detect: [:aModule | aModule includesModule: aModule] ifNone: [ nil]) isNil ifTrue: [ ^false]
		]
	].!

model
	^self module isNil ifTrue: [ nil] ifFalse: [ self module model]!

nameAttribute

	| aNameAttribute |
	aNameAttribute := self allEffectiveAttributes detect: [:anAttribute | anAttribute isNameAttribute] ifNone: [ nil].
	^aNameAttribute!

nameRelationship

	| aNameRelationship |
	aNameRelationship := self allEffectiveRelationships detect: [:anRelationship | anRelationship isNameRelationship] ifNone: [ nil].
	^aNameRelationship!

nonVirtualType
	| someSuperTypes aNonVirtualSuperType |


	self isVirtual ifFalse: [ self isAbstract ifFalse: [ ^self]].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ self isAbstract ifFalse: [ ^self]].

	aNonVirtualSuperType := nil.
	someSuperTypes detect: [:aSuperType |
		aNonVirtualSuperType := aSuperType nonVirtualTypeNoDefault.
		aNonVirtualSuperType isNil not
	] ifNone: [ nil].

	aNonVirtualSuperType isNil ifFalse: [ ^aNonVirtualSuperType].

	^self!

nonVirtualTypeNoDefault
	| someSuperTypes aNonVirtualSuperType |


	self isVirtual ifFalse: [ self isAbstract ifFalse: [ ^self]].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ self isAbstract ifFalse: [ ^self]].

	aNonVirtualSuperType := nil.
	someSuperTypes detect: [:aSuperType |
		aNonVirtualSuperType := aSuperType nonVirtualTypeNoDefault.
		aNonVirtualSuperType isNil not
	] ifNone: [ nil].

	^aNonVirtualSuperType!

ownEffectiveAttributes

	| someAttributes someEffectiveAttributes |
	
	someAttributes := self attributes.
	(someAttributes isNil or: [ someAttributes isEmpty]) ifTrue: [ ^Array new].

	someEffectiveAttributes := OrderedCollection new: someAttributes size.

	someAttributes do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			someEffectiveAttributes add: aFeature.
		]
	].

	^someEffectiveAttributes!

ownEffectiveOperations

	| someOperations someEffectiveOperations |
	
	someOperations := self attributes.
	(someOperations isNil or: [ someOperations isEmpty]) ifTrue: [ ^Array new].

	someEffectiveOperations := OrderedCollection new: someOperations size.

	someOperations do: [:aFeature | 
		aFeature isExclussion not ifTrue: [ 
			someEffectiveOperations add: aFeature.
		]
	].

	^someEffectiveOperations!

rootTypes
	| someTypes |
	someTypes := IdentitySet new: 37.
	self rootTypesInto: someTypes.
	^someTypes!

rootTypesInto: theSet
	| someTypes |
	theSet isNil ifTrue: [ ^self].

	someTypes := self types.
	someTypes do: [:aType | aType isRootType ifTrue: [ theSet add: aType]].
	someTypes do: [:aType | aType rootTypesInto: theSet].!

superType
	self superTypesSize < 1 ifTrue: [ ^nil].
	^self superTypes first!

typePrefix
	^self model isNil ifTrue: [ nil] ifFalse: [ self model typePrefix]!

withAllNonAbstractSubtypes
	^self withAllSubtypes reject: [:aT | aT isAbstract]!

withAllNonAbstractSubtypes: theSubTypes
	theSubTypes isNil ifTrue: [ ^theSubTypes].
	self isAbstract ifFalse: [ 
		(theSubTypes includes: self) ifFalse: [ 
			theSubTypes add: self]].

	self subTypes do: [:aSubtype | aSubtype withAllNonAbstractSubtypes: theSubTypes].
	^theSubTypes!

withAllNonAbstractSuperTypes
	^self withAllSuperTypes reject: [:aT | aT isAbstract]!

withAllSubtypes
	| someSubTypes |
	someSubTypes := OrderedCollection new.
	self withAllSubtypes: someSubTypes.
	^someSubTypes!

withAllSubtypes: theSubTypes
	theSubTypes isNil ifTrue: [ ^theSubTypes].
	(theSubTypes includes: self) ifTrue: [ ^theSubTypes].
	theSubTypes add: self.
	self subTypesPrivate do: [:aSubtype | aSubtype withAllSubtypes: theSubTypes].
	^theSubTypes!

withAllSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new.
	self withAllSuperTypes: someSuperTypes.
	^someSuperTypes!

withAllSuperTypes: theSuperTypes
	theSuperTypes isNil ifTrue: [ ^theSuperTypes].
	(theSuperTypes includes: self) ifTrue: [ ^theSuperTypes].
	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType | aSuperType withAllSuperTypes: theSuperTypes].
	^theSuperTypes! !

!CODEComponent publicMethodsFor: 'derived col accessing'!

allAbstractSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allAbstractSuperTypesInto: someSuperTypes
	].
	^someSuperTypes!

allAbstractSuperTypesInto: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].

	self isAbstract ifFalse: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allAbstractSuperTypesInto: theSuperTypes
	].! !

!CODEComponent publicMethodsFor: 'derived effective features'!

allEffectiveFeatures

	^self allEffectiveFeaturesFromCache!

allEffectiveFeaturesFromCache

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	^effectiveFeaturesCache!

allEffectiveFeaturesNoCache

	| someFeatures someFeaturesNotToInclude someFeatureNamesNotToInclude |
"Transcript show: 'EF ' , self name; cr."

	someFeatures := OrderedCollection new: 32.

	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someFeaturesNotToInclude := IdentitySet new: 13.
		someFeatureNamesNotToInclude := Set new: 13.
		self attributes do: [:aFeature | 
			aFeature allRefinedAttributesInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self relationships do: [:aFeature | 
			aFeature allRefinedRelationshipsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self operations do: [:aFeature | 
			aFeature allRefinedOperationsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveFeatures do: [:aFeature |
				((someFeaturesNotToInclude includes: aFeature) or: [ 
					someFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
					(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
				]
			]
		].
	].

	self attributes do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	self relationships do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	self operations do: [:aFeature | 
		aFeature isExclussion not ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	^someFeatures!

effectiveFeatureNamed: theName

	^self effectiveFeatureNamedFromCache: theName!

effectiveFeatureNamedFromCache: theName

	| aFoundFeature |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveFeaturesCache isNil ifTrue: [ ^nil].

	aFoundFeature := nil.
	effectiveFeaturesCache detect: [:aFeature | 
		aFeature isExclussion ifFalse: [ 
			(aFeature isAttribute or: [ aFeature isRelationship]) 
				ifTrue: [ 
					(aFeature maxMult = aFeature class  maxMultNone) ifFalse: [ 
						aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
					]
				]
				ifFalse: [ 
					aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
				]								
		].
		aFoundFeature isNil not
	] ifNone: [ nil].

	^aFoundFeature!

effectiveFeatureTypedNamed: theName

	^self effectiveFeatureTypedNamedFromCache: theName!

effectiveFeatureTypedNamedFromCache: theName

	| aFoundFeature |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveFeaturesCache isNil ifTrue: [ ^nil].

	aFoundFeature := nil.
	effectiveFeaturesCache detect: [:aFeature |  | aFeatureReferencedType |
		aFeature isExclussion ifFalse: [ 
			(aFeature isAttribute or: [ aFeature isRelationship]) 
				ifTrue: [ 
					(aFeature maxMult = aFeature class  maxMultNone) ifFalse: [ 
						aFeatureReferencedType := aFeature referencedType.
						(aFeatureReferencedType isNil not and: [ aFeatureReferencedType name = theName])  ifTrue: [ aFoundFeature := aFeature].
					]
				]
				ifFalse: [ 
					aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
				]								
		].
		aFoundFeature isNil not
	] ifNone: [ nil].

	^aFoundFeature! !

!CODEComponent publicMethodsFor: 'derived use'!

initUseFeatures: theFeatures! !

!CODEComponent publicMethodsFor: 'dirty'!

cleanDirtyMark
	super cleanDirtyMark.
	self attributes do: [:anAttrib | anAttrib cleanDirtyMark].
	self relationships do: [:aRel | aRel cleanDirtyMark].!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self module isNil ifFalse: [ self module markDirtyOwner]
	].!

markDirtyOwner
	self mustStore 
		ifTrue: [ self markDirty]
		ifFalse: [ self module isNil ifFalse: [ self module markDirty]]!

persistIfDirty
	^self module isNil ifFalse: [ self module persistIfDirty] ifTrue: [ nil]! !

!CODEComponent publicMethodsFor: 'find'!

featureNamed: theFeatureName
	
	| anExistingFeature |

	theFeatureName isNil ifTrue: [ ^self].

	anExistingFeature := self attributes detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self relationships detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self operations detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	^nil!

featureOrInheritedNamed: theFeatureName
	
	| anExistingFeature someSuperTypes |

	theFeatureName isNil ifTrue: [ ^nil].

	anExistingFeature := self attributes detect: [:anAttribute | anAttribute name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self relationships detect: [:aRelationship | aRelationship name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^nil].

	someSuperTypes detect: [:aSuperType |  | aFeature |
		aFeature := aSuperType featureOrInheritedNamed: theFeatureName.
		aFeature isNil ifFalse: [ ^aFeature] ifTrue: [ false]
	] ifNone: [ nil].

	^nil!

hasOrInheritsFeature: theFeature
	
	| someSuperTypes aResult |

	theFeature isNil ifTrue: [ ^false].

	(self attributesIncludes: theFeature) 			ifTrue: [ ^true].
	(self relationshipsIncludes: theFeature) 		ifTrue: [ ^true].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSuperTypes detect: [:aSuperType | 
		aSuperType hasOrInheritsFeature: theFeature] ifNone: [ nil]) isNil not.

	^aResult!

hasOrInheritsFeatureNamed: theFeatureName
	
	| anExistingFeature someSuperTypes aResult |

	theFeatureName isNil ifTrue: [ ^false].

	anExistingFeature := self attributes detect: [:anAttribute | anAttribute name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^true].

	anExistingFeature := self relationships detect: [:aRelationship | aRelationship name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^true].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSuperTypes detect: [:aSuperType | 
		aSuperType hasOrInheritsFeatureNamed: theFeatureName] ifNone: [ nil]) isNil not.

	^aResult! !

!CODEComponent publicMethodsFor: 'initialize-release'!

initIsAbstract
	isAbstract := false!

initIsEnumeration
	isEnumeration := false!

initIsExclussion
	isExclussion := false!

initIsHomeIDProvider
	isHomeIDProvider := false!

initIsHomeRooted
	isHomeRooted := false!

initIsJustUsed
	isJustUsed := true!

initIsPrimitive
	isPrimitive := false!

initIsUse
	isUse := false!

initIsVirtual
	isVirtual := false!

initSkip
	skip := false!

observersRelease
	observers isNil ifTrue: [ ^self].
	observers do: [:anObserver | anObserver release].
	observers := nil!

release
	self changed: #objectDisconnectedOfTree.

	self relatedWithRelease.
	self typeOfValuesRelease.
	self typeOfArgumentsRelease.
	self typeOfReturnsRelease.
	self superTypesRelease.
	self subTypesRelease.
	self relationshipsRelease.
	self attributesRelease.
	self operationsRelease.
	self moduleRelease.
	self observersRelease.
	self typesRelease.

	effectiveAttributesCache := nil.
	effectiveRelationshipsCache := nil.
	effectiveStructuralFeaturesCache := nil.
	effectiveOperationsCache := nil.
	effectiveFeaturesCache := nil.
	effectiveIDAttributeCache  := nil.
	effectiveNameAttributeCache := nil.

	memberInstanceTypesCache := nil.

	super release! !

!CODEComponent publicMethodsFor: 'integrity'!

integrityReportOn: theReport justFirst: theJustFirst

	| someTypes someAttributes someRelationships someOperations |

	theReport isNil  ifTrue: [ ^self].

	(theJustFirst == true and: [ theReport isEmpty not]) ifTrue:  [ ^self].

	someTypes := self types.
	someTypes do: [:aType | | aSuperType aReportEntry |
		aSuperType := aType module.
		self == aSuperType ifFalse: [ 
			aReportEntry := theReport at: aType ifAbsent: [ nil].
			aReportEntry ifTrue: [ 
				aReportEntry := OrderedCollection new: 2.
				theReport at: aType put: aReportEntry
			].
			aReportEntry add: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].

	someAttributes:= self attributes.
	someAttributes do: [:aAttribute |
		aAttribute integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].

	someRelationships:= self relationships.
	someRelationships do: [:aRelationship |
		aRelationship integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].
	someOperations:= self operations.
	someOperations do: [:aOperation |
		aOperation integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].! !

!CODEComponent publicMethodsFor: 'parse'!

featuresFromLine: theLine andStream: theStream
	
	| aStream  |
	theLine isNil ifTrue: [ ^self].
	theLine isEmpty ifTrue: [ ^self].
	(theLine first == $/ or: [ theLine first == $#]) ifTrue: [ ^self].
self logTranscript ifTrue: [ Transcript show: (String with: Character tab); show: ' features ';  cr].

	aStream := ReadStream on: theLine.
	[ aStream atEnd] whileFalse: [ | aWord  |
		aWord := aStream upTo: Character space.
		aWord isEmpty ifFalse: [ 
			aWord = '}' ifTrue: [ ^self].
			aWord = 'attribute' ifTrue: [  self attributeFromLineStream: aStream andStream: theStream] ifFalse: [ 
			aWord = 'relationship' ifTrue: [  self relationshipFromLineStream: aStream andStream: theStream] ifFalse: [ 
			]]			
		]
	]!

featuresFromStream: theStream

	theStream isNil ifTrue: [ ^nil].
	theStream atEnd ifTrue: [ ^nil].
	self model isNil ifTrue: [ ^nil].

	[ theStream atEnd] whileFalse: [ |  aLine aTrimmedLine |
		aLine := theStream upTo: Character cr.
		aTrimmedLine := aLine trimSeparators.
		aTrimmedLine isEmpty ifFalse: [ 
			aTrimmedLine first = $} ifTrue: [ ^self].
			self featuresFromLine: aTrimmedLine andStream: theStream	
		]	
	]!

findTypeNamed: theTypeName
	
	| anExistingType anSpacedTypeName someNames |
	theTypeName isNil ifTrue: [ ^self].
	theTypeName isEmpty ifTrue: [ ^self].

	(theTypeName findString: '::' startingAt: 1 ) > 0 
		ifFalse: [  
			anExistingType := self types detect: [:aType | aType name = theTypeName] ifNone: [ nil].
			anExistingType isNil ifFalse: [ ^anExistingType].
			someNames := Array with: theTypeName
		]
		ifTrue: [ 
			anSpacedTypeName := theTypeName copyReplaceAll: '::' with: ' '.
			someNames := anSpacedTypeName asArrayOfSubstrings
		].
	
	^self findTypeNamedArray: someNames!

findTypeNamedArray: theNames
	
	| aName aModule otherNames aSuperModule aType |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ 
		aType := self typeNamed: aName.
		aType isNil ifFalse: [ ^aType].
	].

	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ 
		aSuperModule := self superModule.
		aSuperModule isNil ifTrue: [ ^nil].
		^aSuperModule findTypeNamedArray: theNames].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames!

fromLineStream: theLineStream andStream: theStream

	theLineStream isNil ifTrue: [ ^nil].
	theLineStream atEnd ifTrue: [ ^nil].
self logTranscript ifTrue: [ Transcript  show: ' >> ';  show: self name; cr].

	[ theLineStream atEnd] whileFalse: [ 	| aWord |
		aWord := self nextTokenFrom: theLineStream.
		aWord isNil ifTrue: [ ^nil].
		aWord = ';' ifTrue: [ ^nil].
		aWord = ':' 
			ifTrue: [ self superTypeFromLineStream: theLineStream andStream: theStream]
			ifFalse: [ 
				aWord = '{' 
					ifTrue: [ self featuresFromStream: theStream]
					ifFalse: [ 
						aWord = '}' ifTrue: [ ^self]
					]	
			]	

	]!

superTypeFromLineStream: theLineStream andStream: theStream

	| aWord aSuperType |
	theLineStream isNil ifTrue: [ ^nil].
	theLineStream atEnd ifTrue: [ ^nil].
	self model isNil ifTrue: [ ^nil].

  [ theLineStream atEnd] whileFalse: [ 

	aWord := self nextTokenFrom: theLineStream stopAt: '{'.
	aWord isNil ifTrue: [ ^nil].
	aWord isEmpty ifTrue: [ ^self].
	aWord = '{' ifTrue: [ ^self].
	aWord = ','  ifFalse: [ 
	aSuperType := self module findTypeNamed: aWord.
	aSuperType isNil ifFalse: [ 
self logTranscript ifTrue: [ Transcript show: (String with: Character tab); show: ' super '; show: aWord; cr].
"Transcript show: (String with: Character tab); show: self name, ' super '; show: aWord; cr."
		aSuperType subTypesAdd: self.
	]
   ]
  ]!

typeFromLineStream: theLineStream andStream: theStream
	
	| aTypeName   anExistingType aNewType anErrorName |

	theLineStream isNil ifTrue: [ ^self].
	theLineStream atEnd ifTrue: [ ^self].
	
	aTypeName := self nextTokenFrom: theLineStream.
	aTypeName isEmpty ifTrue: [ ^self].
	
	anExistingType := self typeNamed: aTypeName.
	anExistingType isNil
		ifFalse: [ 
			self model errorLineKind isNil ifFalse: [ 
				anErrorName := self model errorLineName.
				anErrorName = 'Enumeration' ifTrue: [ anExistingType isEnumeration: true].
				anErrorName = 'primitive' ifTrue: [ anExistingType isPrimitive: true].
			].
			self model foundIsAbstract ifTrue: [ 
				 anExistingType isAbstract: true].

			anExistingType fromLineStream: theLineStream andStream: theStream]
		ifTrue: [  
self logTranscript ifTrue: [ Transcript show: '+ T '; show: aTypeName; cr].
					
			aNewType := CODEComponent new.
			aNewType name: aTypeName.
			self typesAdd: aNewType.
			self model errorLineKind isNil ifFalse: [ 
				anErrorName := self model errorLineName.
				anErrorName = 'Enumeration' ifTrue: [ aNewType isEnumeration: true].
				anErrorName = 'primitive' ifTrue: [ aNewType isPrimitive: true].
			].
			aNewType fromLineStream: theLineStream andStream: theStream
		].!

typeNamedArray: theNames
	
	| aName aModule otherNames |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ ^self typeNamed: aName].
	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ ^nil].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames! !

!CODEComponent publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aModule aSep |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].

	theStream 
		nextPutAll: (self pcForV: self class qualifiedNameTypeStepSymbol); nextPutAll: aSep;
		 nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

asReferenceArray

	| someModuleNames aModule |

	aModule := self module.
	someModuleNames := aModule isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aModule allModuleNamesArray].

	^(Array with: self class refToTypeKindSymbol with: self name), someModuleNames!

asReferenceAsCodeString

	| aModule aStream |

	aStream := WriteStream on: (OrderedCollection new: 8).

	aModule := self module.

	aStream nextPut: self class refToTypeKindSymbol;  
		nextPut: self name.

	aModule isNil  ifFalse: [ aModule allModuleNamesInto: aStream].!

asReferenceAsCodeStringArray

	| someModuleNames aModule |

	aModule := self module.
	someModuleNames := aModule isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aModule allModuleNamesArray].
	someModuleNames isEmpty ifFalse: [ someModuleNames := someModuleNames copyFrom: 2 to: someModuleNames size].

	^(Array with: self class refToTypeKindSymbol with: self name), someModuleNames!

asReferenceAsCodeStringNOCROn: theStream

	| aSep aModule |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	theStream nextPutAll: ' ( ';  nextPutAll: (self pcForV: self class refToTypeKindSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	aModule isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [ aModule allModuleNamesInto: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAsCodeStringNOCROn: theStream. 
	theStream cr.!

attributesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self attributesPrivate isNil not and: [ self attributesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class attributesPersistenceSymbol); cr
			].
			self attributesPrivate do:  [:anAttrib |
				anAttrib persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

firstPersistenceIndexType
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initAttributesFromValues: theValues 
	
	| someAttributes |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someAttributes := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someAttributes isNil ifFalse: [ 
		self attributesPrivate addAll: someAttributes.
		someAttributes do: [:aC | aC typePrivate: self]]!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexType.

	self forzeIsAbstract:	 					(theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]).
	self forzeIsEnumeration:	 				(theValues size < (aFPI + 1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 1)]).
	self forzeIsPrimitive:						(theValues size < (aFPI + 2) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 2)]).
	self forzeStoreClassName: 				(theValues size < (aFPI + 3) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 3)]). 
	self forzeStoreMethodSelector: 			(theValues size < (aFPI + 4) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 4)]). 
	self forzeReengineredClassName:		(theValues size < (aFPI + 5) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 5)]). 
	self forzeIsExclussion:	 				(theValues size < (aFPI + 6) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 6)]).
	self forzeIsVirtual:						(theValues size < (aFPI + 7) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 7)]).
	self forzeIsHomeRooted:					(theValues size < (aFPI + 8) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 8)]).
	self forzeIsHomeIDProvider:				(theValues size < (aFPI + 9) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 9)]).
	self forzePrimitiveInitializationString:		(theValues size < (aFPI + 10) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 10)]).



	theValues size < (aFPI + 11) ifFalse: [  self initReferencedSuperTypesFromValues: (theValues at: (aFPI + 11)) ].
	theValues size < (aFPI + 12) ifFalse: [ self initAttributesFromValues: (theValues at: (aFPI + 12))].
	theValues size < (aFPI + 13) ifFalse: [ self initRelationshipsFromValues: (theValues at: (aFPI + 13)) ].
	theValues size < (aFPI + 14) ifFalse: [ self initOperationsFromValues: (theValues at: (aFPI + 14)) ].
	theValues size < (aFPI + 15) ifFalse: [ self initTypesFromValues: (theValues at: (aFPI + 15)) ].

	self forzeIsUse:	 						(theValues size < (aFPI + 16) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 16)]).!

initOperationsFromValues: theValues 
	
	| someOperations |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someOperations := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someOperations isNil ifFalse: [ 
		self operationsPrivate addAll: someOperations.
		someOperations do: [:aC | aC typePrivate: self]]!

initReferencedSuperTypesFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class superTypesPersistenceSymbol ifFalse: [ ^nil].

	superTypesRefsTmpValues := theValues.!

initRelationshipsFromValues: theValues 
	
	| someRelationships |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someRelationships := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someRelationships isNil ifFalse: [ 
		self relationshipsPrivate addAll: someRelationships.
		someRelationships do: [:aR | aR typePrivate: self]]!

initTypesFromValues: theValues
	
	| someTypes |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someTypes := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someTypes isNil ifFalse: [ 
		self typesPrivate addAll: someTypes.
		someTypes do: [:aC | aC modulePrivate: self]]!

inner: theIsInner persistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| aSep aNewStream aNewChunk |

	aSep := self separatorForPersistenceAsCode.
		
	aNewStream :=  nil.
	aNewChunk := nil.

	theIsInner
		ifTrue: [ 
			self mustStore 
				ifFalse: [ 
					theStream isNil ifFalse: [ 
						theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self kind);  
							nextPutAll: aSep; nextPutAll: self name printString; cr].
					self localValuesPersistenceAsCodeStringChunks: theCollection 
						on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.
					theStream isNil ifFalse: [ theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr]
				]
				ifTrue: [ 
					self persistenceRefToMethodAsCodeStringOn: theStream indent: theIS.
					theDoSubChunks ifTrue: [ 

						(self mustStoreWithFilter: theFilter) ifTrue: [ 
							aNewStream := WriteStream on: (String new: self subPartsSize * 256).
							aNewChunk := Array with: self with: aNewStream.
							theCollection add: aNewChunk
						].
						self inner: false persistenceAsCodeStringChunks: theCollection 
							on: aNewStream filter: theFilter indent: self indentStringForPersistenceAsCode 
							doSubChunks: theDoSubChunks
					]
				]
		]
		ifFalse: [ 
			theStream isNil ifFalse: [ 
				theStream nextPutAll: theIS; nextPutAll: '#( ';  nextPutAll: (self pcForV: self kind);  
					nextPutAll: aSep; nextPutAll: self name printString; cr].
			self localValuesPersistenceAsCodeStringChunks: theCollection 
				on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.
			theStream isNil ifFalse: [ theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr]
		]!

localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isAbstract ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isEnumeration ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isPrimitive ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self storeClassName );  nextPutAll: aSep; 
		nextPutAll: (self pcForV:  self storeMethodSelector ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self reengineredClassName );  cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  isExclussion ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isVirtual ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeRooted ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeIDProvider );cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self primitiveInitializationString ); cr.


	self referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS.
	self attributesPersistenceAsCodeStringOn: theStream indent: theIS.
	self relationshipsPersistenceAsCodeStringOn: theStream indent: theIS.
	self operationsPersistenceAsCodeStringOn: theStream indent: theIS.

	(self typesPrivate isNil not and: [ self typesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	   	  		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class typesPersistenceSymbol); cr
			].
			self typesPrivate do:  [:aType |
				aType inner: true persistenceAsCodeStringChunks: theCollection on: theStream 
					filter: theFilter indent: anIS , self indentStringForPersistenceAsCode doSubChunks: theDoSubChunks
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
	].

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isUse ); cr!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

self halt: 'This method should not be invoked on CODEComponent, but rather #localValuesPersistenceAsCodeStringChunks:on:filter:indent:doSubChunks:'.

self shouldNotImplement.

	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isAbstract ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isEnumeration ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isPrimitive ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self storeClassName );  nextPutAll: aSep; 
		nextPutAll: (self pcForV:  self storeMethodSelector ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self reengineredClassName );  cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self  isExclussion ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isVirtual ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeRooted ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeIDProvider );cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self primitiveInitializationString ); cr.


	self referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS.
	self attributesPersistenceAsCodeStringOn: theStream indent: theIS.
	self relationshipsPersistenceAsCodeStringOn: theStream indent: theIS.
	self operationsPersistenceAsCodeStringOn: theStream indent: theIS.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isUse ); cr!

mustStore

	^self storeMethodSelector isNil not and: [ 
		self storeMethodSelector isEmpty not and: [ 
			self storeClassName isNil not and: [ 
				self storeClassName isEmpty not]]]!

numberPersistenceEntriesType
	^17!

operationsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self operationsPrivate isNil not and: [ self operationsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class operationsPersistenceSymbol); cr
			].
			self operationsPrivate do:  [:anAttrib |
				anAttrib persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

persistenceAsCodeString

	| aCollection |

	aCollection := self persistenceAsCodeStringChunksFilter: true doSubChunks: false.
	(aCollection isNil or: [ aCollection isEmpty]) ifTrue: [ ^nil].

	^aCollection first at: 2!

persistenceRefToMethodAsCodeStringOn: theStream indent: theIS

	| aSep |
	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
		
	theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self class refToTypeMethodKind);  
		nextPutAll: aSep; nextPutAll: self name printString;  
		nextPutAll: aSep; nextPutAll: (self pcForV: self storeMethodSelector); nextPutAll: aSep; nextPutAll: (self pcForV: self storeClassName);  
		nextPutAll: ' )' ; cr; cr.!

ph2InitFromSolver: theSolver
	super ph2InitFromSolver: theSolver.

(self module name = 'CategoryPage' and: [ self name = 'Body']) ifTrue: [ self halt: 'Body in CategoryPage'].

	self ph2InitReferencedSuperTypesValuesFromSolver: theSolver.
	self attributesPrivate do: [:aType | aType ph2InitFromSolver: theSolver].	
	self relationshipsPrivate do: [:aType | aType ph2InitFromSolver: theSolver].
	self typesPrivate do: [:aType | aType ph2InitFromSolver: theSolver].!

ph2InitReferencedSuperTypesValuesFromSolver: theSolver
	
	| someTypes |

	(superTypesRefsTmpValues isNil or: [ superTypesRefsTmpValues isEmpty]) ifTrue: [ ^self].

	someTypes := 
		CODEElement resolveOrNewReferencedTypesCollectionFromPersistenceAsCode: superTypesRefsTmpValues  solver: theSolver.
	self superTypesPrivate  addAll: someTypes.
	someTypes do: [:aC | aC subTypesPrivate add: self].

	superTypesRefsTmpValues := nil!

referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self superTypesPrivate isNil not and: [ self superTypesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil); cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	    	 			nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class superTypesPersistenceSymbol); cr
			].
			self superTypesPrivate do:  [:aType |
				aType asReferenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

relationshipsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self relationshipsPrivate isNil not and: [ self relationshipsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class relationshipsPersistenceSymbol); cr
			].
			self relationshipsPrivate do:  [:aRel |
				aRel persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

resolveOrNewReferencedAspectName: theName elementNames: theElementNames
	| anElementName someElementNames anAttributeName anAttribute aRelationshipName aRelationship |
	theName isNil ifTrue: [ ^nil].
 
	(theElementNames isNil or: [ theElementNames isEmpty]) ifTrue: [
		^self resolveOrNewReferencedAspectName: theName
	].

	anElementName := theElementNames first.

	anElementName = self class qualifiedNameAttributeStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		anAttributeName := theElementNames at: 2. 
		anAttribute := self attributeNamed: anAttributeName.
		anAttribute isNil ifTrue: [ ^nil].
		someElementNames := theElementNames copyFrom: 2 to: theElementNames size.
		anAttribute resolveOrNewReferencedAspectName: theName elementNames: someElementNames	
	].

	anElementName = self class qualifiedNameRelationshipStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		aRelationshipName := theElementNames at: 2. 
		aRelationship := self typeNamed: aRelationshipName.
		aRelationship isNil ifTrue: [ ^nil].
		theElementNames size < 3 ifTrue: [ ^aRelationship].
		someElementNames := theElementNames copyFrom: 3 to: theElementNames size.
		aRelationship resolveOrNewReferencedAspectName: theName elementNames: someElementNames	
	].

	^nil!

resolveOrNewReferencedAttributeNamed: theName

	| anAttribute |

	theName isNil ifTrue: [ ^nil].

	anAttribute := self resolveReferencedAttributeNamed: theName.
	anAttribute isNil ifFalse: [ ^anAttribute].

	anAttribute := self preferredAttributeClass new name: theName.
	self attributesAdd: anAttribute.
	^anAttribute!

resolveOrNewReferencedElementName: theName elementNames: theElementNames
	| anElementName anAttributeName anAttribute aRelationshipName aRelationship |
	theName isNil ifTrue: [ ^nil].
 
	(theElementNames isNil or: [ theElementNames isEmpty]) ifTrue: [
		^self
	].

	anElementName := theElementNames first.

	anElementName = self class qualifiedNameAttributeStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		anAttributeName := theElementNames at: 2. 
		anAttribute := self attributeNamed: anAttributeName.
		^anAttribute	
	].

	anElementName = self class qualifiedNameRelationshipStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		aRelationshipName := theElementNames at: 2. 
		aRelationship := self typeNamed: aRelationshipName.
		^aRelationship
	].

	^nil!

resolveOrNewReferencedOperationNamed: theName

	| anOperation |

	theName isNil ifTrue: [ ^nil].

	anOperation := self resolveReferencedOperationNamed: theName.
	anOperation isNil ifFalse: [ ^anOperation].

	anOperation := self preferredOperationClass new name: theName.
	self attributesAdd: anOperation.
	^anOperation!

resolveOrNewReferencedRelationshipNamed: theName

	| aRel |

	theName isNil ifTrue: [ ^nil].

	aRel := self resolveReferencedRelationshipNamed: theName.
	aRel isNil ifFalse: [ ^aRel].

	aRel := self preferredRelationshipClass new name: theName.
	self relationshipsAdd: aRel.
	^aRel!

resolveOrNewReferencedRelationshipNamed: theName forInverseType: theType

	| aRel |

	theName isNil ifTrue: [ ^nil].

	aRel := self resolveReferencedRelationshipNamed: theName forInverseType: theType.
	aRel isNil ifFalse: [ ^aRel].

	aRel := self preferredRelationshipClass new name: theName.
	self relationshipsAdd: aRel.
	^aRel!

resolveOrNewReferencedTypeName: theName
	| aType |

	theName isNil ifTrue: [ ^nil].

	aType := self typeNamed: theName.
	aType isNil ifFalse: [ ^aType].

	aType := self preferredTypeClass new name: theName.
	self typesAdd: aType.
	^aType!

resolveReferencedAttributeNamed: theName
	| anAttribute |

	theName isNil ifTrue: [ ^nil].

	anAttribute := self attributeNamed: theName.
	^anAttribute!

resolveReferencedOperationNamed: theName
	| anOperation |

	theName isNil ifTrue: [ ^nil].

	anOperation := self operationNamed: theName.
	^anOperation!

resolveReferencedRelationshipNamed: theName
	| aRelationship |

	theName isNil ifTrue: [ ^nil].

	aRelationship := self relationshipNamed: theName.
	^aRelationship!

resolveReferencedRelationshipNamed: theName forInverseType: theType
	| aRefToTypeValues anExistingRelationship someRelationshipsSameName |

	theName isNil ifTrue: [ ^nil].

	someRelationshipsSameName := OrderedCollection new: 8.
	self relationships do: [:aRel | 
		aRel name = theName ifTrue: [ someRelationshipsSameName add: aRel]
	].

	someRelationshipsSameName isEmpty ifTrue:  [ ^nil].
	someRelationshipsSameName size = 1 ifTrue: [ ^someRelationshipsSameName first].


	aRefToTypeValues := theType asReferenceAsCodeStringArray.
	anExistingRelationship := someRelationshipsSameName detect: [:aRel |  | aRelRefToTypeValues |
		aRelRefToTypeValues := aRel referencedInverseRefToTypeValues.
		aRelRefToTypeValues = aRefToTypeValues] ifNone: [ nil].
	anExistingRelationship isNil ifTrue: [ self halt].

	^anExistingRelationship!

resolveReferencedTypeName: theName
	| aType |

	theName isNil ifTrue: [ ^nil].

	aType := self typeNamed: theName.
	^aType! !

!CODEComponent publicMethodsFor: 'primitive types'!

primitiveBroker

	| aNonVirtualType |

	primitiveBroker isNil ifFalse: [ ^primitiveBroker].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^nil].

	aNonVirtualType isPrimitive ifFalse: [ ^nil].

	aNonVirtualType == self ifFalse:  [ ^aNonVirtualType primitiveBroker].

	primitiveBroker := self preferredSystemPrimitiveBrokerClass primitiveBrokerForType: self.
	^primitiveBroker!

resetPrimitiveBroker

	primitiveBroker := nil! !

!CODEComponent publicMethodsFor: 'semantic checking'!

checkIsAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsEnumeration: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsHomeRooted: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsPrimitive: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsUse: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsVirtual: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkModel: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkModule: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSubTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSubTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSuperTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSuperTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEComponent publicMethodsFor: 'semantic links'!

moduleCandidates
	"Generated by ISF/AD. Do not modify"
	^self module isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self module]!

moduleCreate
	"Generated by ISF/AD. Do not modify"
	^CODEModule new!

moduleLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self moduleCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self module: anObject]!

moduleLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self moduleCandidates
		initially: self module
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self module: anObject.!

moduleLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self moduleCandidates
		initially: self module
		label: 'Select Or Create ...'
		class: self moduleCreate class
		ifUnchanged: [^self].
	self module: anObject!

moduleScope
	"Generated by ISF/AD. Do not modify"
	^nil!

subTypesCandidates
	"Generated by ISF/AD. Do not modify"
	^self subTypes asArray!

subTypesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEComponent new!

subTypesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self subTypesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self subTypesAdd: anObject]!

subTypesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self subTypesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self subTypesAdd: anObject.!

subTypesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self subTypesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self subTypesCreate class
		ifUnchanged: [^self].
	self subTypesAdd: anObject!

subTypesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

superTypeScope
	"Generated by ISF/AD. Do not modify"
	^nil!

superTypesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEComponent new!

superTypesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self superTypesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self superTypesAdd: anObject.!

superTypesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self superTypesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self superTypesCreate class
		ifUnchanged: [^self].
	self superTypesAdd: anObject!

superTypesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typesCandidates
	"Generated by ISF/AD. Do not modify"
	^self types asArray!

typesCreate
	^self preferredTypeClass new!

typesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self typesAdd: anObject]!

typesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self typesAdd: anObject.!

typesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self typesCreate class
		ifUnchanged: [^self].
	self typesAdd: anObject!

typesScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEComponent publicMethodsFor: 'semantic links-custom'!

superTypesCandidates
	
	| aModel someSubTypes someTypes someCandidateTypes someSuperTypes |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].

	someSubTypes := self withAllSubtypes.
	someTypes := aModel allTypes.
	someSuperTypes := self withAllSuperTypes.
	someTypes removeAll: someSuperTypes.

	someCandidateTypes := OrderedCollection new: someTypes size - someSubTypes size - 1.
	someTypes do: [:aType |
		((aType == self) not and: [ (someSubTypes includes: aType) not])  ifTrue: [ 
			someCandidateTypes add: aType
		]
	].
	^someCandidateTypes!

superTypesLinkCreate

	| someTypes aSelectedType aModel aNLSSolver aNLSItem aThisNLSItem |

	someTypes := self superTypesCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as SuperType of Type\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedType := Dialog 
		choose: ('							Please, select a Type as SuperType of Type							\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ') ', aType allContainerNamespaceNames ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	self superTypesAdd: aSelectedType.


	(Dialog confirm: 'Do you want to use the SuperType ItemTranslation?' initialAnswer: true) ifTrue: [ 

		aModel := self model.
		aModel isNil ifFalse: [ 
			aNLSSolver := aModel nlsSolver.
			aNLSSolver isNil ifFalse: [ 
				aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedType nlsAppName 
					group: aSelectedType nameNLSGroupName item: aSelectedType nameNLSItemName.
				aNLSItem isNil ifFalse: [
					aThisNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: self nlsAppName 
						group: self nameNLSGroupName item: self nameNLSItemName.
					aThisNLSItem isNil ifTrue: [ 
						aThisNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: self nlsAppName group: self nameNLSGroupName
							item: self nameNLSItemName translation: self name
					].
					(aThisNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
						aThisNLSItem usedItemTranslationsAdd: aNLSItem.
						self changed: #itemTranslations
					]
				]
			]
		]
	].

	self changed: #name.

	^aSelectedType! !

!CODEComponent publicMethodsFor: 'updating refinements'!

removeRefinementAttributesFromMissingSuperTypes

	| someOwnAttributes someAttributesToAvoid someAllAttributes someCandidateAttributes  |
	someOwnAttributes := self attributes.
	someAttributesToAvoid := IdentitySet new: (someOwnAttributes size * 1.5) floor.
	someAttributesToAvoid addAll: someOwnAttributes.

	someOwnAttributes do: [:anAttribute | 
		anAttribute isRefinement ifTrue: [ 
			someAttributesToAvoid addAll: anAttribute allRefinedAttributes
		]
	].

	someAllAttributes := self allEffectiveAttributes.
	someCandidateAttributes := IdentitySet new: (someAllAttributes size * 1.5) floor.
	someAllAttributes do: [:anAttribute | 
		(someAttributesToAvoid includes: anAttribute) ifFalse: [ 
			someCandidateAttributes add: anAttribute
		]
	].

	someOwnAttributes copy do: [:anAttribute |  | someBaseAttributes |
		anAttribute isRefinement ifTrue: [ 
			someBaseAttributes := anAttribute refinedAttributes.
			(someBaseAttributes isNil or: [ someBaseAttributes isEmpty or: [ (someCandidateAttributes includes: anAttribute) not]]) ifTrue: [ 
				anAttribute release
			]
		]
	].!

removeRefinementFeaturesFromMissingSuperTypes

	self removeRefinementRelationshipsFromMissingSuperTypes.
	self removeRefinementAttributesFromMissingSuperTypes!

removeRefinementRelationshipsFromMissingSuperTypes

	| someOwnRelationships someRelationshipsToAvoid someAllRelationships someCandidateRelationships  |
	someOwnRelationships := self relationships.
	someRelationshipsToAvoid := IdentitySet new: (someOwnRelationships size * 1.5) floor.
	someRelationshipsToAvoid addAll: someOwnRelationships.

	someOwnRelationships do: [:aRelationship | 
		aRelationship isRefinement ifTrue: [ 
			someRelationshipsToAvoid addAll: aRelationship allRefinedRelationships
		]
	].

	someAllRelationships := self allEffectiveRelationships.
	someCandidateRelationships := IdentitySet new: (someAllRelationships size * 1.5) floor.
	someAllRelationships do: [:aRelationship | 
		(someRelationshipsToAvoid includes: aRelationship) ifFalse: [ 
			someCandidateRelationships add: aRelationship
		]
	].

	someOwnRelationships copy do: [:aRelationship |  | someBaseRelationships |
		aRelationship isRefinement ifTrue: [ 
			someBaseRelationships := aRelationship refinedRelationships.
			(someBaseRelationships isNil or: [ someBaseRelationships isEmpty or: [ (someCandidateRelationships includes: aRelationship) not]]) ifTrue: [ 				aRelationship release
			]
		]
	].!

updateRefinedFeatures

	self updateRefinedFeaturesHere.
	self subTypes do: [:aType | aType updateRefinedFeatures]!

updateRefinedFeaturesHere

	| someAllFeatures someOwnAttributes someOwnRelationships someOwnFeatures someInheritedFeaturesPropagatingUse    |

	someAllFeatures := self allEffectiveStructuralFeatures.
	someOwnAttributes := self attributes.
	someOwnRelationships := self relationships.

	someOwnFeatures := IdentitySet new: ((someOwnAttributes size + someOwnRelationships size) * 1.5) floor.
	someOwnFeatures addAll: someOwnAttributes ; addAll: someOwnRelationships.

	someInheritedFeaturesPropagatingUse := someAllFeatures select: [:aFeature |
		((someOwnFeatures includes: aFeature) not and: [ aFeature isRefinementRequired and: [  aFeature isPropagateUse not]])
	].

	someInheritedFeaturesPropagatingUse isEmpty ifTrue: [ ^self].
	
	someInheritedFeaturesPropagatingUse do: [:aFeature |  
		| aValueType aRefinedAttribute  aRelatedType aRefinedRelationship anInverse aRefinedInverseRelationship |

		aFeature isAttribute ifTrue: [
			aValueType := aFeature valueType.
			aValueType isNil ifFalse: [ 
				aRefinedAttribute := self preferredAttributeRefinementClass new name: aFeature name.
				aRefinedAttribute type: self.
				aRefinedAttribute valueType: aValueType.
				aRefinedAttribute forzeIsPropagateUse: false.
				aRefinedAttribute forzeIsJustUsed: false.
				aRefinedAttribute forzeIsRefinementRequired: true.

				aRefinedAttribute refinedAttributesAdd: aFeature.

				aRefinedAttribute initTerminalMetaAttributesFrom: aFeature.
			]
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [
			anInverse := aFeature inverse.
			anInverse isNil ifFalse: [ 
				aRelatedType := aFeature relatedType.
				aRelatedType isNil ifFalse: [ 
					aRefinedRelationship := self preferredRelationshipRefinementClass new name: aFeature name.
					aRefinedRelationship type: self.
					aRefinedRelationship relatedType: aRelatedType.
					aRefinedRelationship forzeIsPropagateUse: false.
					aRefinedRelationship forzeIsJustUsed: false.
					aRefinedRelationship forzeIsRefinementRequired: true.

					aRefinedInverseRelationship := self preferredRelationshipRefinementClass new name: anInverse name.
					aRefinedInverseRelationship type: aRelatedType.
					aRefinedInverseRelationship relatedType: self.
					aRefinedInverseRelationship forzeIsPropagateUse: false.
					aRefinedInverseRelationship forzeIsJustUsed: false.
					aRefinedInverseRelationship forzeIsRefinementRequired: anInverse isRefinementRequired.

					aRefinedRelationship inverse: aRefinedInverseRelationship.
				
					aRefinedRelationship refinedRelationshipsAdd: aFeature.
					aRefinedInverseRelationship refinedRelationshipsAdd: anInverse.

					aRefinedRelationship initTerminalMetaAttributesFrom: aFeature.
					aRefinedInverseRelationship initTerminalMetaAttributesFrom: anInverse.

				]
			]
		] ifFalse: [ 
		]]
	].! !

!CODEComponent publicMethodsFor: 'updating uses'!

updateUses

	self updateUsesHere.
	self subTypes do: [:aType | aType updateUses]!

updateUsesHere

	| someAllFeatures someOwnAttributes someOwnRelationships someOwnFeatures someInheritedFeaturesPropagatingUse    |

	self isUse ifFalse: [ ^self].

	someAllFeatures := self allEffectiveStructuralFeatures.
	someOwnAttributes := self attributes.
	someOwnRelationships := self relationships.

	someOwnFeatures := IdentitySet new: ((someOwnAttributes size + someOwnRelationships size) * 1.5) floor.
	someOwnFeatures addAll: someOwnAttributes ; addAll: someOwnRelationships.

	someInheritedFeaturesPropagatingUse := someAllFeatures select: [:aFeature |
		((someOwnFeatures includes: aFeature) not and: [ aFeature isPropagateUse and: [ aFeature isRefinementRequired not]])
	].

	someInheritedFeaturesPropagatingUse isEmpty ifTrue: [ ^self].
	
	someInheritedFeaturesPropagatingUse do: [:aFeature |  
		| someLocalTypes aValueType aRefinedValueType aRefinedAttribute 
		 aRelatedType aRefinedRelatedType aRefinedRelationship anInverse aRefinedInverseRelationship |

		someLocalTypes := self types.
		aFeature isAttribute ifTrue: [
			aValueType := aFeature valueType.
			aValueType isNil ifFalse: [ 
				aRefinedValueType := someLocalTypes detect: [:aLocalType |
					aLocalType superTypesIncludes: aValueType ] ifNone: [ nil].
				aRefinedValueType isNil ifTrue: [ 
					aRefinedValueType := self preferredTypeClass new name: aValueType name.
					self typesAdd: aRefinedValueType.
					aRefinedValueType isUse: true.
					aRefinedValueType forzeIsJustUsed: true.
					aRefinedValueType superTypesAdd: aValueType
				].
				aRefinedAttribute := self preferredAttributeRefinementClass new name: aFeature name.
				aRefinedAttribute type: self.
				aRefinedAttribute valueType: aRefinedValueType.
				aRefinedAttribute forzeIsPropagateUse: true.
				aRefinedAttribute forzeIsJustUsed: true.
				aRefinedAttribute forzeIsRefinementRequired: false.

				aRefinedAttribute refinedAttributesAdd: aFeature.

				aRefinedAttribute initTerminalMetaAttributesFrom: aFeature.
			]
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [
			anInverse := aFeature inverse.
			anInverse isNil ifFalse: [ 
				aRelatedType := aFeature relatedType.
				aRelatedType isNil ifFalse: [ 
					aRefinedRelatedType := someLocalTypes detect: [:aLocalType |
						aLocalType superTypesIncludes: aRelatedType ] ifNone: [ nil].
					aRefinedRelatedType isNil ifTrue: [ 
						aRefinedRelatedType := self preferredTypeClass new name: aRelatedType name.
						self typesAdd: aRefinedRelatedType.
						aRefinedRelatedType isUse: true.
						aRefinedRelatedType forzeIsJustUsed: true.
						aRefinedRelatedType superTypesAdd: aRelatedType
					].
					aRefinedRelationship := self preferredRelationshipRefinementClass new name: aFeature name.
					aRefinedRelationship type: self.
					aRefinedRelationship relatedType: aRefinedRelatedType.
					aRefinedRelationship forzeIsPropagateUse: true.
					aRefinedRelationship forzeIsJustUsed: true.
					aRefinedRelationship forzeIsRefinementRequired: false.

					aRefinedInverseRelationship := self preferredRelationshipRefinementClass new name: anInverse name.
					aRefinedInverseRelationship type: aRefinedRelatedType.
					aRefinedInverseRelationship relatedType: self.
					aRefinedInverseRelationship forzeIsPropagateUse: false.
					aRefinedInverseRelationship forzeIsJustUsed: true.
					aRefinedInverseRelationship forzeIsRefinementRequired: false.

					aRefinedRelationship inverse: aRefinedInverseRelationship.
				
					aRefinedRelationship refinedRelationshipsAdd: aFeature.
					aRefinedInverseRelationship refinedRelationshipsAdd: anInverse.

					aRefinedRelationship initTerminalMetaAttributesFrom: aFeature.
					aRefinedInverseRelationship initTerminalMetaAttributesFrom: anInverse.

				]
			]
		] ifFalse: [ 
		]]
	].! !

!CODEElement class publicMethodsFor: 'accessing'!

kind
	^#element! !

!CODEElement class publicMethodsFor: 'class initialization'!

initialize
	"CODEElement initialize"

	self initModelElementKindsFactoryCache! !

!CODEElement class publicMethodsFor: 'constants'!

aggregatesRelationshipKind
	^#AGGREGATES!

aggregationRelationshipKind
	^#AGGREGATES!

alreadyDerivedAttribute
	^#'AlreadyDerivedAttribute'!

alreadyInitializedSentinelValue
	^#'AlreadyInitializedSentinelValueCMGO'!

attributeContentsNamePostfix
	^'_contents' copy!

attributeContentsNamePrefix
	^'' copy!

computationKindAfterConnection
	^#'AFTERCONNECTION'!

computationKindAlways
	^#'ALWAYS'!

computationKindFromHomeIDCounter
	^#'FROMHOMEIDCOUNTER'!

computationKindInitializedInConstructor
	^#'INITIALIZEDINCONSTRUCTOR'!

computationKindInitialValue
	^#'INITIALVALUE'!

computationKindNoComputation
	^#'NOCOMPUTATION'!

fullyQualifiedNameSeparator
	^'::' copy!

isAggregatedRelationshipKind
	^#isAGGREGATED!

maxMultMany
	^#*!

maxMultNone
	^#'0'!

maxMultOne
	^#'1'!

maxMultRequired
	^#'1'!

maxMultTwo
	^#'2'!

minMultOptional
	^#'0'!

minMultRequired
	^#'1'!

notRefinedMetaAttributeValue
	^#'NotRefinedMetaAttributeValue'!

presentationTextAspectName
	^'PresentationText' copy!

referencesRelationshipKind
	^#REFERENCES!

relationshipContainerNamePostfix
	^'_container' copy!

relationshipContainerNamePrefix
	^'' copy!

relationshipContentsNamePostfix
	^'_contents' copy!

relationshipContentsNamePrefix
	^'' copy!

relationshipNamePostfix
	^'_related' copy!

relationshipNamePrefix
	^'' copy! !

!CODEElement class publicMethodsFor: 'definitions holder for instances'!

defaultConfigurationClassForInstances
	^METAConfiguration!

defaultDefinitionsHolderClassForInstances
	^CMDefinitionsHolder! !

!CODEElement class publicMethodsFor: 'expression constants'!

candidatesPathCreate
	^#'create'!

candidatesPathNoCreate
	^#'nocreate'!

expressionBinaryOperators
	ExpressionBinaryOperators isNil ifTrue: [ self initExpressionBinaryOperators].
	^ExpressionBinaryOperators!

expressionOperators
	ExpressionOperators isNil ifTrue: [ self initExpressionOperators].
	^ExpressionOperators!

expressionUnaryOperators
	ExpressionUnaryOperators isNil ifTrue: [ self initExpressionUnaryOperators].
	^ExpressionUnaryOperators!

initExpressionAlgorithmOperatorRecurse
	^#':recurse'!

initExpressionAlgorithmOperatorRecurseCollect
	^#':recursecollect'!

initExpressionAlgorithmOperators
	^Array 
		with: self initExpressionAlgorithmOperatorRecurse
		with: self initExpressionAlgorithmOperatorRecurseCollect!

initExpressionArithmeticOperatorAdd
	^#'+'!

initExpressionArithmeticOperatorDiv
	^#'/'!

initExpressionArithmeticOperatorMax
	^#'max:'!

initExpressionArithmeticOperatorMin
	^#'min:'!

initExpressionArithmeticOperatorMult
	^#'*'!

initExpressionArithmeticOperatorPercentage
	^#'%'!

initExpressionArithmeticOperators
	^Array 
		with: self initExpressionArithmeticOperatorAdd
		with: self initExpressionArithmeticOperatorSubstract
		with: self initExpressionArithmeticOperatorMult
		with: self initExpressionArithmeticOperatorDiv
		with: self initExpressionArithmeticOperatorPercentage
		with: self initExpressionArithmeticOperatorMin
		with: self initExpressionArithmeticOperatorMax!

initExpressionArithmeticOperatorSubstract
	^#'-'!

initExpressionBinaryOperators
	ExpressionBinaryOperators := self expressionOperators - self expressionUnaryOperators - self initExpressionOperatorsSubExpressionDelimiters!

initExpressionBooleanOperatorAnd
	^#'and:'!

initExpressionBooleanOperatorNot
	^#':not'!

initExpressionBooleanOperatorOr
	^#'or:'!

initExpressionBooleanOperators
	^Array 
		with: self initExpressionBooleanOperatorAnd
		with: self initExpressionBooleanOperatorOr
		with: self initExpressionBooleanOperatorNot
		with: self initExpressionBooleanOperatorXor
		with: self initExpressionBooleanOperatorSame!

initExpressionBooleanOperatorSame
	^#'same:'!

initExpressionBooleanOperatorXor
	^#'xor:'!

initExpressionCalc
	^#'calc'!

initExpressionCastOperatorFloor
	^#':floor'!

initExpressionCastOperators
	^Array 
		with: self initExpressionCastOperatorFloor!

initExpressionCloneFalse
	^#'clonenot'!

initExpressionCloneTrue
	^#'clone'!

initExpressionComparisonOperatorEqual
	^#'='!

initExpressionComparisonOperatorGT
	^#'>'!

initExpressionComparisonOperatorGTE
	^#'>='!

initExpressionComparisonOperatorIdentical
	^#'=='!

initExpressionComparisonOperatorLT
	^#'<'!

initExpressionComparisonOperatorLTE
	^#'<='!

initExpressionComparisonOperators
	^Array 
		with: self initExpressionComparisonOperatorLT
		with: self initExpressionComparisonOperatorLTE
		with: self initExpressionComparisonOperatorEqual
		with: self initExpressionComparisonOperatorIdentical
		with: self initExpressionComparisonOperatorGT
		with: self initExpressionComparisonOperatorGTE!

initExpressionEndFilterExpression
	^#'}' copy!

initExpressionEndSubExpression
	^#')'!

initExpressionExtent
	^#'$extent'!

initExpressionLiteralValue
	^#'literal'!

initExpressionNilValue
	^#'nil'!

initExpressionObjectOperatorIsNil
	^#':isnil'!

initExpressionObjectOperatorNotNil
	^#':notnil'!

initExpressionObjectOperators
	^Array 
		with: self initExpressionObjectOperatorIsNil
		with: self initExpressionObjectOperatorNotNil!

initExpressionOperatorLiteralDelimiter
	^#'"'!

initExpressionOperators
	ExpressionOperators := (Set new: 87)
		addAll: self initExpressionArithmeticOperators;
		addAll: self initExpressionBooleanOperators;
		addAll: self initExpressionStringOperators;
		addAll: self initExpressionSetOperators;
		addAll: self initExpressionObjectOperators;
		addAll: self initExpressionAlgorithmOperators;
		addAll: self initExpressionComparisonOperators;
		addAll: self initExpressionOperatorsSubExpressionDelimiters;
		addAll: self initExpressionCastOperators;
		yourself!

initExpressionOperatorsAndSubExpressionDelimiters
	^self initExpressionArithmeticOperators,
		self initExpressionBooleanOperators,
		self initExpressionStringOperators,
		self initExpressionSetOperators!

initExpressionOperatorsSubExpressionDelimiters
	^Array 
		with: self initExpressionStartSubExpression
		with: self initExpressionEndSubExpression!

initExpressionRandomAndLiteralValue
	^#'ranliteral'!

initExpressionSelf
	^#'$self'!

initExpressionSetOperationSum
	^#':sum'!

initExpressionSetOperatorAverage
	^#':average'!

initExpressionSetOperatorConcat
	^#','!

initExpressionSetOperatorDifference
	^#'difference:'!

initExpressionSetOperatorFirst
	^#':first'!

initExpressionSetOperatorIncludes
	^#'includes:'!

initExpressionSetOperatorIncludesSet
	^#'includesset:'!

initExpressionSetOperatorIntersection
	^#'intersect:'!

initExpressionSetOperatorIsEmpty
	^#':isempty'!

initExpressionSetOperatorLast
	^#':last'!

initExpressionSetOperatorMax
	^#':max'!

initExpressionSetOperatorMin
	^#':min'!

initExpressionSetOperatorNotEmpty
	^#':notempty'!

initExpressionSetOperators
	^(Array 
		with: self initExpressionSetOperatorUnion
		with: self initExpressionSetOperatorIntersection
		with: self initExpressionSetOperatorDifference
		with: self initExpressionSetOperatorIncludes
		with: self initExpressionSetOperatorIncludesSet
		with: self initExpressionSetOperatorSize
		with: self initExpressionSetOperatorIsEmpty
		with: self initExpressionSetOperatorNotEmpty
		with: self initExpressionSetOperatorConcat
		with: self initExpressionSetOperationSum) , 
	(Array 
		with: self initExpressionSetOperatorFirst
		with: self initExpressionSetOperatorLast
		with: self initExpressionSetOperatorMin
		with: self initExpressionSetOperatorMax
		with: self initExpressionSetOperatorAverage)!

initExpressionSetOperatorSize
	^#':size'!

initExpressionSetOperatorUnion
	^#'union:'!

initExpressionSmalltalk
	^#'smalltalk'!

initExpressionSmalltalkArgument
	^#'$argument'!

initExpressionStartFilterExpression
	^#'{' copy!

initExpressionStartSubExpression
	^#'('!

initExpressionStringOperatorConcat
	^#',' copy!

initExpressionStringOperatorEndsWith
	^#'ends:'!

initExpressionStringOperatorIsEmpty
	^#':isempty'!

initExpressionStringOperatorMatch
	^#'match:'!

initExpressionStringOperatorNotEmpty
	^#':notempty'!

initExpressionStringOperators
	^Array 
		with: self initExpressionStringOperatorConcat
		with: self initExpressionStringOperatorStartsWith
		with: self initExpressionStringOperatorEndsWith
		with: self initExpressionStringOperatorSubstring
		with: self initExpressionStringOperatorMatch
		with: self initExpressionStringOperatorSize
		with: self initExpressionStringOperatorIsEmpty
		with: self initExpressionStringOperatorNotEmpty!

initExpressionStringOperatorSize
	^#':size'!

initExpressionStringOperatorStartsWith
	^#'starts:'!

initExpressionStringOperatorSubstring
	^#'substring:'!

initExpressionThis
	^#'$this'!

initExpressionUnaryOperators
	ExpressionUnaryOperators := (Set new: 43) 
		add: self initExpressionBooleanOperatorNot;
		add: self initExpressionSetOperatorSize;
		add: self initExpressionSetOperatorIsEmpty;
		add: self initExpressionStringOperatorSize;
		add: self initExpressionStringOperatorIsEmpty;
		add: self initExpressionObjectOperatorIsNil;
		add: self initExpressionObjectOperatorNotNil;
		add: self initExpressionSetOperationSum;
		add: self initExpressionAlgorithmOperatorRecurse;
		add: self initExpressionAlgorithmOperatorRecurseCollect;
		add: self initExpressionCastOperatorFloor;
		add: self initExpressionSetOperatorFirst;
		add: self initExpressionSetOperatorLast;
		add: self initExpressionSetOperatorMin;
		add: self initExpressionSetOperatorMax;
		add: self initExpressionSetOperatorAverage;
	
		yourself!

initExpressionWhenConnectedToContainer
	^#'onconnect'!

isAlgorithmExpressionOperator: theOperator

	theOperator isNil ifTrue: [ ^false].
	(theOperator isKindOf: String) ifFalse: [ ^false].

	^self initExpressionAlgorithmOperators includes: theOperator asSymbol!

isBinaryExpressionOperator: theOperator

	theOperator isNil ifTrue: [ ^false].
	(theOperator isKindOf: String) ifFalse: [ ^false].

	^self expressionBinaryOperators includes: theOperator asSymbol!

isExpressionOperator: theOperator

	theOperator isNil ifTrue: [ ^false].
	(theOperator isKindOf: String) ifFalse: [ ^false].

	^self expressionOperators includes: theOperator asSymbol!

isUnaryExpressionOperator: theOperator

	theOperator isNil ifTrue: [ ^false].
	(theOperator isKindOf: String) ifFalse: [ ^false].

	^self expressionUnaryOperators includes: theOperator asSymbol!

resetExpressionOperators
	ExpressionOperators := nil.
	ExpressionUnaryOperators := nil.
	ExpressionBinaryOperators := nil.! !

!CODEElement class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEElement class publicMethodsFor: 'navigation'!

browserParameters
	^nil!

browserParametersForElementChooser
	^Dictionary new
		at:  METABrowser showCanvasLabelParameterSymbol put: true;
		at:  METABrowser editorsOpenerParameterSymbol put: CODEMModelEditorsOpener editorsOpener;
		at:  METABrowser numberOfEditorHoldersParameterSymbol put: 3;
		at:  METABrowser initialVerticalCanvasesProportionParameterSymbol put: 100;
		yourself!

browserParametersForModelEditor
	^Dictionary new
		at:  METABrowser showCanvasLabelParameterSymbol put: true;
		at:  METABrowser editorsOpenerParameterSymbol put: CODEMModelEditorsOpener editorsOpener;
		at:  METABrowser numberOfEditorHoldersParameterSymbol put: 5;

		yourself!

defaultBrowserParameters
	^self browserParametersForModelEditor!

defaultChooserParameters
	^self browserParametersForElementChooser!

defaultDefinitionsHolder
	^CODEMModelDefinitionsHolder forModelEditor "forModelEditorWithCompositeChildSpec"!

editAllMetaSelectors
	"CODEElement editAllMetaSelectors"

	METAChildSpecAutoEditor openOn: #(CODEElement CODEModel CODEType CODEAttribute CODEAttributeRefinement CODERelationship CODERelationshipRefinement ) selector: #metaSelectors.!

metaPerspectives

	^self modelEditorMETAPerspectives!

metaSelectors

	^self modelEditorMETASelectors!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesElement!

modelEditorMETAPerspectivesElement
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'PersistIfDirty'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('IsDirty' 'PersistIfDirty')))
			nlsApp: 'CODE';
			nlsGroup: 'Element_Perspectives';
			nlsItem: 'PersistIfDirty';
			nlsTranslation: 'GrabarSiPendiente';
			yourself);
		yourself!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'IsDirty')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesTranslation
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Traducciones'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('NLSName' 'NLSKind' 'NLSAppName' 'NLSGroupName' 'NLSItemName')))
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Perspectives';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'Traducciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ItemTranslations'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('ItemTranslations')))
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Perspectives';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'ElementosDeTraduccion';
			yourself);
		yourself!

modelEditorMETASelectors

	^self modelEditorMETASelectorsGeneral!

modelEditorMETASelectorsGeneral

	"METAChildSpecAutoViewEditor openOn: CODEElement selector: #modelEditorMETASelectorsGeneral target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Name';
			basicSelector: #name;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Name';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'General_Selectors';
			nlsItem: 'Name';
			nlsTranslation: 'Nombre';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Kind';
			basicSelector: #kind;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Kind';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'General_Selectors';
			nlsItem: 'Kind';
			nlsTranslation: 'MetaClase';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsDirty';
			basicSelector: #isDirty;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsDirty';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'General_Selectors';
			nlsItem: 'IsDirty';
			nlsTranslation: 'EstaPendienteGrabar';
			yourself);
		add: ((Smalltalk at: #METAOperationVoidNoArgsChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PersistIfDirty';
			basicSelector: #persistIfDirty;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PersistIfDirty';
			displaySelector: nil;
			canShowInTree: false;
			nlsApp: 'CODE';
			nlsGroup: 'General_Selectors';
			nlsItem: 'PersistIfDirty';
			nlsTranslation: 'GrabaSiPendiente';
			yourself);
		yourself!

modelEditorMETASelectorsTranslation

	"METAChildSpecAutoViewEditor openOn: CODEElement selector: #modelEditorMETASelectorsTranslation target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSName';
			basicSelector: #nlsName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSName';
			nlsTranslation: 'NombreTraducido';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSKind';
			basicSelector: #nlsKind;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSKind';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSKind';
			nlsTranslation: 'MetaClaseTraducida';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSAppName';
			basicSelector: #nlsAppName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSAppName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSAppName';
			nlsTranslation: 'NobreTraduccionDeAplicacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSGroupName';
			basicSelector: #nameNLSGroupName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSGroupName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSGroupName';
			nlsTranslation: 'NobreGrupoTraduccion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSItemName';
			basicSelector: #nameNLSItemName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSItemName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSItemName';
			nlsTranslation: 'NombreItemTraduccion';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ItemTranslations';
			basicSelector: #itemTranslations;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ItemTranslations';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #ItemTranslation;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'ElementosDeTraduccion';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSSolver';
			basicSelector: #nlsSolver;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'NLSSolver';
			displaySelector: nil;
			objectClassName: #TranslationModelBase;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSSolver';
			nlsTranslation: 'AplicacionOCatalogoDeTraduccion';
			yourself);
		yourself!

modelEditorPathSelectors

	^self modelEditorPathSelectorsGeneral!

modelEditorPathSelectorsGeneral

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #()!

modelEditorPathSelectorsTranslation

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #( 'ItemTranslations')!

pathSelectors
	^self modelEditorPathSelectors! !

!CODEElement class publicMethodsFor: 'persistence-code'!

argumentsPersistenceSymbol	
	^#arguments!

aspectsPersistenceSymbol	
	^#aspects!

attributesPersistenceSymbol	
	^#attributes!

commentPersistenceSymbol
	^#comment!

commentsPersistenceSymbol
	^#comments!

definedAspectsPersistenceSymbol	
	^#definedAspects!

elementMapsPersistenceSymbol	
	^#elementMaps!

example
	
	| aSameLayoutGroupsTestResult |
	METAScopedApplicationBrowser openForObject:  (PROCachedWindowDefinitionsHolder definedWindowFor: #ClinicaHistoriaEditor).

	METAScopedApplicationBrowser openForObject: 
		(DefinedPart halt newFromPersistenceAsCode: 
			(Compiler evaluate: (PROCachedWindowDefinitionsHolder definedWindowFor: #ClinicaHistoriaEditor) persistenceAsCodeString)).


	aSameLayoutGroupsTestResult := (PROCachedWindowDefinitionsHolder definedWindowFor: #ClinicaHistoriaEditor) 
		reportSubPartsHaveSameLayoutGroups.
	aSameLayoutGroupsTestResult isNil ifFalse: [
		Dialog warn: aSameLayoutGroupsTestResult first kind , ' ',  aSameLayoutGroupsTestResult first name , 
			'\has more than one Group because\' withCRs,
			(aSameLayoutGroupsTestResult at: 2) kind , ' ',  (aSameLayoutGroupsTestResult at: 2) name
	].


[ | anEditor aDefinedWindow |
	anEditor := InterModelUpdater interModelUpdater models detect: [:aM | aM isKindOf: ClinicaHistoriaEditor] ifNone: [nil].
	aDefinedWindow := anEditor definedWindow.
	aDefinedWindow  initializeLayoutsFromEditor: anEditor
] value.!

factoryFromPersistenceAsCodeKind: theCodeKind

	^self modelElementKindsFactoryCache at: theCodeKind ifAbsent: [ nil]!

indentStringForPersistenceAsCode
	^'  ' copy!

initModelElementKindsFactoryCache
	"CODEElement  modelElementKindsFactoryCache"
	"CODEElement  initModelElementKindsFactoryCache"

	| someSubclasses |

	someSubclasses := (Array with: CODEModel with: CODEModule 
		with: CODEType with: CODEAspect
		with: CODEAttribute  with: CODEAttributeRefinement 
		with: CODERelationship with: CODERelationshipRefinement with: CODEComment with: CODEParameter) , 
		(Array with: CODEMap with: CODEMapsFolder with: CODEElementMap with: CODEMapLogic), 
		(Array with: CODEOperation with: CODEOperationRefinement with: CODEArgument with: CODEArgument).
	
	ModelElementKindsFactoryCache := IdentityDictionary new: someSubclasses size * 2 + 1.
	someSubclasses do: [:aSC | ModelElementKindsFactoryCache at: aSC kind put: aSC].!

mapLogicPersistenceSymbol	
	^#mapLogic!

modelElementKindsFactoryCache
	"CODEElement  modelElementKindsFactoryCache"

	(ModelElementKindsFactoryCache isNil or: [ModelElementKindsFactoryCache keys isEmpty]) ifFalse: [
		^ModelElementKindsFactoryCache].

	self initModelElementKindsFactoryCache.

	^ModelElementKindsFactoryCache!

newElementFromFactoryFromPersistenceAsCode: theValues
	
	| aKind aName aNewPart |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	
	aKind := theValues first.
	aKind = self kind ifFalse: [ ^nil].
	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aNewPart := self new name: aName copy.
	aNewPart initFromValues: theValues.
	aNewPart cleanDirtyMark.
	^aNewPart!

newElementsCollectionFromPersistenceAsCode: theValues
	| aCollection  aKind |
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	(aKind  = self commentsPersistenceSymbol or: [ 
		aKind = self parametersPersistenceSymbol or: [ 
		aKind = self subModulesPersistenceSymbol or: [ 
		aKind = self typesPersistenceSymbol or: [ 
		aKind = self attributesPersistenceSymbol or: [
		aKind = self relationshipsPersistenceSymbol or: [ 
		aKind = self superTypesPersistenceSymbol or: [ 
		aKind = self definedAspectsPersistenceSymbol or: [ 
		aKind = self elementMapsPersistenceSymbol or: [ 
		aKind = self subElementMapsPersistenceSymbol or: [ 
		aKind = self operationsPersistenceSymbol or: [
		aKind = self argumentsPersistenceSymbol or: [

		]]]]]]]]]]]]) ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewPart |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewPart := 	self newFromPersistenceAsCode: anElem.
			aNewPart isNil ifFalse: [ aCollection add: aNewPart]]].
	^aCollection!

newFromPersistenceAsCode: theValues
	| aKind aFactory |
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind := theValues first.
		
	aFactory := self factoryFromPersistenceAsCodeKind: aKind.
	(aFactory isNil or: [ aFactory == CODEElement]) ifFalse: [ 
		^aFactory  newElementFromFactoryFromPersistenceAsCode: theValues
	].

	(aKind = self refToModelMethodKind or: [ aKind = self refToModuleMethodKind or: [ 
		aKind = self refToMapMethodKind or: [ aKind = self refToMapsFolderMethodKind ]]])  ifTrue: [ 
		^self newFromPersistenceAsStoredMethod: theValues ].

	^nil!

newFromPersistenceAsCodeOrCurrent: theValues
	| aKind aFactory |
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind := theValues first.
		
	aFactory := self factoryFromPersistenceAsCodeKind: aKind.
	(aFactory isNil or: [ aFactory == CODEElement]) ifFalse: [ 
		^aFactory  newElementFromFactoryFromPersistenceAsCode: theValues
	].

	(aKind = self refToModelMethodKind or: [ aKind = self refToModuleMethodKind or: [ 
		aKind = self refToMapMethodKind or: [ aKind = self refToMapsFolderMethodKind ]]])  ifTrue: [ 
		^self newFromPersistenceAsStoredMethodOrCurrent: theValues ].

	^nil!

newFromPersistenceAsStoredMethod:  theValues
| aMethodSelector aClassName aClass someValues aKind anExpectedClass anElement anElementName anExpectedElementName |

	(theValues isNil or: [ theValues size < 4]) ifTrue: [ ^nil].

	anExpectedClass := theValues first = self refToModuleMethodKind ifTrue: [ CODEModule] ifFalse: [ 
		theValues first = self refToTypeMethodKind  ifTrue: [ CODEType] ifFalse: [ 
			theValues first = self refToMapMethodKind  ifTrue: [ CODEMap]  ifFalse: [ 
				theValues first = self refToMapsFolderMethodKind  ifTrue: [ CODEMapsFolder] ifFalse: [ 
					theValues first = self refToModelMethodKind  ifTrue: [ CODEModel] ifFalse: [  nil]]]]].

	anExpectedClass isNil ifTrue:  [ ^nil].

	anExpectedElementName := (theValues at: 2) asString.
	anExpectedElementName isNil ifTrue: [ ^nil].
	aMethodSelector := (theValues at: 3) asSymbol.
	aMethodSelector isNil ifTrue: [ ^nil].
	aClassName := (theValues at: 4) asSymbol.
	aClassName isNil ifTrue: [ ^nil].
	
	aClass := Smalltalk at: aClassName asSymbol ifAbsent: [ nil].
	aClass isNil ifTrue: [ ^nil].

	someValues := aClass perform: aMethodSelector.
	(someValues isNil or: [ someValues size < 2])  ifTrue: [ ^nil].

	aKind := someValues first.
	(aKind isNil or: [ aKind = anExpectedClass kind]) ifFalse: [ ^nil].
	anElementName := someValues at: 2.
	anExpectedElementName = anElementName ifFalse: [ ^nil].

	anElement := CODEElement newFromPersistenceAsCode: someValues .
	anElement isNil ifTrue: [ ^nil].
	(anElement isKindOf: anExpectedClass) ifFalse: [ ^nil].
	anElement name = anExpectedElementName ifFalse: [ ^nil].
	^anElement!

newFromPersistenceAsStoredMethodOrCurrent:  theValues
| aMethodSelector aClassName aClass someValues aKind anExpectedClass anElement anElementName anExpectedElementName anExistingObject |

	(theValues isNil or: [ theValues size < 4]) ifTrue: [ ^nil].

	anExpectedClass := theValues first = self refToModuleMethodKind ifTrue: [ CODEModule] ifFalse: [ 
		theValues first = self refToTypeMethodKind  ifTrue: [ CODEType] ifFalse: [ 
			theValues first = self refToMapMethodKind  ifTrue: [ CODEMap]  ifFalse: [ 
				theValues first = self refToMapsFolderMethodKind  ifTrue: [ CODEMapsFolder] ifFalse: [ 
					theValues first = self refToModelMethodKind  ifTrue: [ CODEModel] ifFalse: [  nil]]]]].

	anExpectedClass isNil ifTrue:  [ ^nil].

	anExpectedElementName := (theValues at: 2) asString.
	anExpectedElementName isNil ifTrue: [ ^nil].
	aMethodSelector := (theValues at: 3) asSymbol.
	aMethodSelector isNil ifTrue: [ ^nil].
	aClassName := (theValues at: 4) asSymbol.
	aClassName isNil ifTrue: [ ^nil].
	
	aClass := Smalltalk at: aClassName asSymbol ifAbsent: [ nil].
	aClass isNil ifTrue: [ ^nil].


	(anExpectedClass == CODEModel or: [ anExpectedClass == CODEModule]) ifTrue: [ 
		anExistingObject := Object messageNotUnderstoodSignal 
			handle: [:anEx | anEx returnWith: nil]
			do:  [ aClass perform: #currentModelStoreMethodSelector: with: aMethodSelector].
		(anExistingObject isKindOf: anExpectedClass) ifTrue: [ ^anExistingObject].
	].

	someValues := aClass perform: aMethodSelector.

	(someValues isNil or: [ someValues size < 2])  ifTrue: [ ^nil].

	aKind := someValues first.
	(aKind isNil or: [ aKind = anExpectedClass kind]) ifFalse: [ ^nil].
	anElementName := someValues at: 2.
	anExpectedElementName = anElementName ifFalse: [ ^nil].

	anElement := CODEElement newFromPersistenceAsCode: someValues .
	anElement isNil ifTrue: [ ^nil].
	(anElement isKindOf: anExpectedClass) ifFalse: [ ^nil].
	anElement name = anExpectedElementName ifFalse: [ ^nil].
	^anElement!

ojoDefinedParts!

operationsPersistenceSymbol	
	^#operations!

parameterPersistenceSymbol
	^#parameter!

parametersPersistenceSymbol
	^#parameters!

preferredInstallerClass
	^CODEGenInstaller!

qualifiedNameAttributeStepSymbol
	^#attribute!

qualifiedNameElementMapStepSymbol
	^#elementMap!

qualifiedNameRelationshipStepSymbol
	^#relationship!

qualifiedNameTypeStepSymbol
	^#type!

referencedElementsPersistenceSymbol	
	^#references!

refinedArgumentsPersistenceSymbol	
	^#refinedArguments!

refinedAttributesPersistenceSymbol	
	^#refinedAttributes!

refinedOperationsPersistenceSymbol	
	^#refinedOperations!

refinedRelationshipsPersistenceSymbol	
	^#refinedRelationships!

refToArgumentKindSymbol
	^#refToArgument!

refToArgumentTypeKindSymbol
	^self refToTypeKindSymbol!

refToAspectKindSymbol
	^#refToAspect!

refToAttributeKindSymbol
	^#refToAttribute!

refToInverseRelationshipKindSymbol
	^#refToInverseRelationship!

refToMapMethodKind
	^#refToMapMethod!

refToMapsFolderMethodKind
	^#refToMapsFolder!

refToModelMethodKind
	^#refToModel!

refToModuleMethodKind
	^#refToModuleMethod!

refToOperationKindSymbol
	^#refToOperation!

refToRefinedArgumentKindSymbol
	^#refToArgument!

refToRefinedAttributeKindSymbol
	^#refToAttribute!

refToRefinedOperationKindSymbol
	^#refToOperation!

refToRefinedRelationshipKindSymbol
	^#refToRefinedRelationship!

refToRelationshipKindSymbol
	^#refToRelationship!

refToReturnTypeKindSymbol
	^self refToTypeKindSymbol!

refToTypeKindSymbol
	^#refToType!

refToTypeMethodKind
	^#refToTypeMethod!

refToValueTypeKindSymbol
	^self refToTypeKindSymbol!

relationshipsPersistenceSymbol	
	^#relationships!

resetModelElementKindsFactoryCache
	"CODEElement resetModelElementKindsFactoryCache"
	
	ModelElementKindsFactoryCache := nil!

resolveOrNewReferencedArgumentFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName aRefToTypeValues anArgument anOperation |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToArgumentKindSymbol or: [  
		aKind = self refToRefinedArgumentKindSymbol ]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToTypeValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToTypeValues isNil ifTrue: [ ^nil].

	anOperation := self resolveOrNewReferencedOperationFromPersistenceAsCode: aRefToTypeValues solver: theSolver.
	anOperation isNil ifTrue: [ ^nil].

	anArgument := anOperation resolveOrNewReferencedArgumentNamed: aName.

	^anArgument!

resolveOrNewReferencedArgumentsCollectionFromPersistenceAsCode: theValues solver: theSolver
	
	| aCollection  aKind |
	
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	(aKind = self refinedArgumentsPersistenceSymbol) ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewElem |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewElem :=  self resolveOrNewReferencedArgumentFromPersistenceAsCode: anElem solver: theSolver.
			aNewElem isNil ifFalse: [ aCollection add: aNewElem]]].

	^aCollection!

resolveOrNewReferencedAspectFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName anAspect someElementNames |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	aKind = self refToAspectKindSymbol ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	someElementNames := theValues copyFrom: 3 to: theValues size.
	(someElementNames isNil not and: [ someElementNames first isEmpty]) ifTrue: [ 
		someElementNames := nil
	].

	anAspect := theSolver resolveOrNewReferencedAspectName: aName elementNames: someElementNames.
	anAspect isNil ifTrue: [ ^nil].
	^anAspect!

resolveOrNewReferencedAspectsCollectionFromPersistenceAsCode: theValues solver: theSolver
	
	| aCollection  aKind |
	
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	aKind = self aspectsPersistenceSymbol ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewElem |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewElem :=  self resolveOrNewReferencedAspectFromPersistenceAsCode: anElem solver: theSolver.
			aNewElem isNil ifFalse: [ aCollection add: aNewElem]]].

	^aCollection!

resolveOrNewReferencedAttributeFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName aType aRefToTypeValues anAttribute |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToAttributeKindSymbol or: [  
		aKind = self refToRefinedAttributeKindSymbol ]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToTypeValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToTypeValues isNil ifTrue: [ ^nil].

	aType := self resolveOrNewReferencedTypeFromPersistenceAsCode: aRefToTypeValues solver: theSolver.
	aType isNil ifTrue: [ ^nil].

	anAttribute := aType resolveOrNewReferencedAttributeNamed: aName.

	^anAttribute!

resolveOrNewReferencedAttributesCollectionFromPersistenceAsCode: theValues solver: theSolver
	
	| aCollection  aKind |
	
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	(aKind = self refinedAttributesPersistenceSymbol) ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewElem |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewElem :=  self resolveOrNewReferencedAttributeFromPersistenceAsCode: anElem solver: theSolver.
			aNewElem isNil ifFalse: [ aCollection add: aNewElem]]].

	^aCollection!

resolveOrNewReferencedElementFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aElement |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.

	aElement := aKind = self refToTypeKindSymbol 
		ifTrue: [ self resolveOrNewReferencedTypeFromPersistenceAsCode: theValues solver: theSolver]
		ifFalse:  [  
			aKind = self refToAttributeKindSymbol 
				ifTrue: [ self resolveOrNewReferencedAttributeFromPersistenceAsCode: theValues solver: theSolver]
				ifFalse:  [	
					aKind = self refToRelationshipKindSymbol 
						ifTrue: [ self resolveOrNewReferencedRelationshipFromPersistenceAsCode: theValues solver: theSolver]
						ifFalse:  [  
							nil
						]
				]
		].

	^aElement!

resolveOrNewReferencedElementsCollectionFromPersistenceAsCode: theValues solver: theSolver
	
	| aCollection  aKind |
	
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	aKind = self referencedElementsPersistenceSymbol ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewElem |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewElem :=  self resolveOrNewReferencedElementFromPersistenceAsCode: anElem solver: theSolver.
			aNewElem isNil ifFalse: [ aCollection add: aNewElem]]].

	^aCollection!

resolveOrNewReferencedOperationFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName aType aRefToTypeValues anOperation |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToOperationKindSymbol or: [  
		aKind = self refToRefinedOperationKindSymbol ]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToTypeValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToTypeValues isNil ifTrue: [ ^nil].

	aType := self resolveOrNewReferencedTypeFromPersistenceAsCode: aRefToTypeValues solver: theSolver.
	aType isNil ifTrue: [ ^nil].

	anOperation := aType resolveOrNewReferencedOperationNamed: aName.

	^anOperation!

resolveOrNewReferencedOperationsCollectionFromPersistenceAsCode: theValues solver: theSolver
	
	| aCollection  aKind |
	
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	(aKind = self refinedOperationsPersistenceSymbol) ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewElem |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewElem :=  self resolveOrNewReferencedOperationFromPersistenceAsCode: anElem solver: theSolver.
			aNewElem isNil ifFalse: [ aCollection add: aNewElem]]].

	^aCollection!

resolveOrNewReferencedRelationshipFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName aType aRefToTypeValues aRelationship |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToRelationshipKindSymbol or: [  
		aKind = self refToInverseRelationshipKindSymbol  or: [ 
			aKind = self refToRefinedRelationshipKindSymbol ]]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToTypeValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToTypeValues isNil ifTrue: [ ^nil].

	aType := self resolveOrNewReferencedTypeFromPersistenceAsCode: aRefToTypeValues solver: theSolver.
	aType isNil ifTrue: [ ^nil].

	aRelationship := aType resolveOrNewReferencedRelationshipNamed: aName.

	^aRelationship!

resolveOrNewReferencedRelationshipFromPersistenceAsCode: theValues solver: theSolver forInverseType: theType
	
	| aKind aName aType aRefToTypeValues aRelationship |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToRelationshipKindSymbol or: [  
		aKind = self refToInverseRelationshipKindSymbol  or: [ 
			aKind = self refToRefinedRelationshipKindSymbol ]]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToTypeValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToTypeValues isNil ifTrue: [ ^nil].

	aType := self resolveOrNewReferencedTypeFromPersistenceAsCode: aRefToTypeValues solver: theSolver.
	aType isNil ifTrue: [ ^nil].

	aRelationship := aType resolveOrNewReferencedRelationshipNamed: aName forInverseType: theType.

	^aRelationship!

resolveOrNewReferencedRelationshipsCollectionFromPersistenceAsCode: theValues solver: theSolver
	
	| aCollection  aKind |
	
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	(aKind = self refinedRelationshipsPersistenceSymbol) ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewElem |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewElem :=  self resolveOrNewReferencedRelationshipFromPersistenceAsCode: anElem solver: theSolver.
			aNewElem isNil ifFalse: [ aCollection add: aNewElem]]].

	^aCollection!

resolveOrNewReferencedTypeFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName someModuleNames aType |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	aKind = self refToTypeKindSymbol ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	someModuleNames := theValues copyFrom: 3 to: theValues size.
	(someModuleNames isNil not and: [ someModuleNames isEmpty]) ifTrue: [ 
		someModuleNames := nil
	].

	aType := theSolver resolveOrNewReferencedTypeName: aName moduleNames: someModuleNames.
	aType isNil ifTrue: [ ^nil].
	^aType!

resolveOrNewReferencedTypesCollectionFromPersistenceAsCode: theValues solver: theSolver
	
	| aCollection  aKind |
	
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	aKind = self superTypesPersistenceSymbol ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewElem |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewElem :=  self resolveOrNewReferencedTypeFromPersistenceAsCode: anElem solver: theSolver.
			aNewElem isNil ifFalse: [ aCollection add: aNewElem]]].

	^aCollection!

resolveReferencedArgumentFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName anArgument anOperation aRefToOperationValues |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToArgumentKindSymbol or: [  
		aKind = self refToRefinedArgumentKindSymbol ]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToOperationValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToOperationValues isNil ifTrue: [ ^nil].

	anOperation := self resolveReferencedOperationFromPersistenceAsCode: aRefToOperationValues solver: theSolver.
	anOperation isNil ifTrue: [ ^nil].

	anArgument := anOperation resolveReferencedArgumentNamed: aName.

	^anArgument!

resolveReferencedAttributeFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName aType aRefToTypeValues anAttribute |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToAttributeKindSymbol or: [  
		aKind = self refToRefinedAttributeKindSymbol ]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToTypeValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToTypeValues isNil ifTrue: [ ^nil].

	aType := self resolveReferencedTypeFromPersistenceAsCode: aRefToTypeValues solver: theSolver.
	aType isNil ifTrue: [ ^nil].

	anAttribute := aType resolveReferencedAttributeNamed: aName.

	^anAttribute!

resolveReferencedElementFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aElement |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.

	aElement := aKind = self refToTypeKindSymbol 
		ifTrue: [ self resolveReferencedTypeFromPersistenceAsCode: theValues solver: theSolver]
		ifFalse:  [  
			aKind = self refToAttributeKindSymbol 
				ifTrue: [ self resolveReferencedAttributeFromPersistenceAsCode: theValues solver: theSolver]
				ifFalse:  [	
					aKind = self refToRelationshipKindSymbol 
						ifTrue: [ self resolveReferencedRelationshipFromPersistenceAsCode: theValues solver: theSolver]
						ifFalse:  [	
					aKind = self refToOperationKindSymbol 
						ifTrue: [ self resolveReferencedOperationFromPersistenceAsCode: theValues solver: theSolver]
						ifFalse:  [	
					aKind = self refToArgumentKindSymbol 
						ifTrue: [ self resolveReferencedArgumentFromPersistenceAsCode: theValues solver: theSolver]
						ifFalse:  [  
							nil
						]
				]
				]
				]
		].

	^aElement!

resolveReferencedModelFromPersistenceAsCode: theValues 
	
	| aKind aModel |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToModelMethodKind or: [ aKind = self refToMapMethodKind]) ifFalse: [ ^nil].

	aModel := self  newFromPersistenceAsCode: theValues.
	((aModel isKindOf: CODEModel) or: [ aModel isKindOf: CODEMap]) ifFalse: [ ^nil].

	aModel isNil ifTrue: [ ^nil].
	^aModel!

resolveReferencedModelFromPersistenceAsCodeOrCurrent: theValues 
	
	| aKind aModel |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToModelMethodKind or: [ aKind = self refToMapMethodKind]) ifFalse: [ ^nil].

	aModel := self  newFromPersistenceAsCodeOrCurrent: theValues.
	((aModel isKindOf: CODEModel) or: [ aModel isKindOf: CODEMap]) ifFalse: [ ^nil].

	aModel isNil ifTrue: [ ^nil].
	^aModel!

resolveReferencedOperationFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName aType aRefToTypeValues anOperation |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToOperationKindSymbol or: [  
		aKind = self refToRefinedOperationKindSymbol ]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToTypeValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToTypeValues isNil ifTrue: [ ^nil].

	aType := self resolveReferencedTypeFromPersistenceAsCode: aRefToTypeValues solver: theSolver.
	aType isNil ifTrue: [ ^nil].

	anOperation := aType resolveReferencedOperationNamed: aName.

	^anOperation!

resolveReferencedRelationshipFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName aType aRefToTypeValues aRelationship |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	(aKind = self refToRelationshipKindSymbol or: [  
		aKind = self refToInverseRelationshipKindSymbol  or: [ 
			aKind = self refToRefinedRelationshipKindSymbol ]]) ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	aRefToTypeValues := theValues size < 3  ifTrue: [ nil] ifFalse: [ theValues at: 3].
	aRefToTypeValues isNil ifTrue: [ ^nil].

	aType := self resolveReferencedTypeFromPersistenceAsCode: aRefToTypeValues solver: theSolver.
	aType isNil ifTrue: [ ^nil].

	aRelationship := aType resolveReferencedRelationshipNamed: aName.

	^aRelationship!

resolveReferencedTypeFromPersistenceAsCode: theValues solver: theSolver
	
	| aKind aName someModuleNames aType |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].
	theSolver isNil ifTrue: [ ^nil].
	
	aKind := theValues first.
	aKind = self refToTypeKindSymbol ifFalse: [ ^nil].

	aName := theValues size < 2  ifTrue: [ nil] ifFalse: [ theValues at: 2].
	aName isNil ifTrue: [ ^nil].
	
	someModuleNames := theValues copyFrom: 3 to: theValues size.
	(someModuleNames isNil not and: [ someModuleNames first isEmpty]) ifTrue: [ 
		someModuleNames := nil
	].

	aType := theSolver resolveReferencedTypeName: aName moduleNames: someModuleNames.
	aType isNil ifTrue: [ ^nil].
	^aType!

resolveReferencedTypesCollectionFromPersistenceAsCode: theValues solver: theSolver
	
	| aCollection  aKind |
	
	theValues isNil ifTrue: [ ^nil].
	theValues isEmpty ifTrue: [ ^nil].
	
	aKind :=  theValues first.
	aKind = self superTypesPersistenceSymbol ifFalse: [ ^nil].
		
	aCollection := OrderedCollection new: theValues size.
	2 to: theValues size do: [:anIndex | | anElem aNewElem |
		anElem := theValues at: anIndex.
		anElem isNil ifFalse: [ 
			aNewElem :=  self resolveReferencedTypeFromPersistenceAsCode: anElem solver: theSolver.
			aNewElem isNil ifFalse: [ aCollection add: aNewElem]]].

	^aCollection!

separatorForPersistenceAsCode
	^' ' copy!

sourceElementsPersistenceSymbol	
	^#sourceElements!

subElementMapsPersistenceSymbol	
	^#subElementMaps!

subModulesPersistenceSymbol	
	^#submodules!

superTypesPersistenceSymbol	
	^#supertypes!

typesPersistenceSymbol	
	^#types!

viewElementsPersistenceSymbol	
	^#viewElements! !

!CODEElement class publicMethodsFor: 'preferences'!

preferredArgumentClass
	^CODEArgument!

preferredArgumentRefinementClass
	^CODEArgumentRefinement!

preferredAspectClass
	^CODEAspect!

preferredAttributeClass
	^CODEAttribute!

preferredAttributeRefinementClass
	^CODEAttributeRefinement!

preferredCommentClass
	^CODEComment!

preferredElementMapClass
	^CODEElementMap!

preferredMapClass
	^CODEMap!

preferredMapLogicClass
	^CODEMapLogic!

preferredMapsFolderClass
	^CODEMapsFolder!

preferredModelClass
	^CODEModel!

preferredModuleClass
	^CODEModule!

preferredOperationClass
	^CODEOperation!

preferredOperationRefinementClass
	^CODEOperationRefinement!

preferredParameterClass
	^CODEParameter!

preferredPreferencesClass
	^CMPreferences!

preferredRelationshipClass
	^CODERelationship!

preferredRelationshipRefinementClass
	^CODERelationshipRefinement!

preferredSystemPrimitiveBrokerClass
	^CMSystemPrimitiveBroker!

preferredTypeClass
	^CODEType!

preferredTypeDependencyClass
	^CMTypeDependency!

preferredTypeObserverClass
	^CMTypeObserver! !

!CODEElement class publicMethodsFor: 'primitive type constants'!

primTypeNameBoolean
	^'Boolean' copy!

primTypeNameDate
	^'Date' copy!

primTypeNameInteger
	^'Integer' copy!

primTypeNameNumber
	^'Number' copy!

primTypeNameString
	^'String' copy!

primTypeNameSymbol
	^'Symbol' copy!

primTypeNameTime
	^'Time' copy! !

!CODEElement class publicMethodsFor: 'utilities'!

capitalize: theString
	
	| aString aWriteStream aResult |
	(theString isNil or: [ theString isEmpty]) ifTrue: [^theString].

	aString := theString trimBlanks.

	aWriteStream := WriteStream on: (String new: aString size).
	aString asArrayOfSubstrings do: [:aSubstr | aWriteStream nextPutAll: aSubstr capitalized].
	aResult := aWriteStream contents.
	^aResult! !

!CODEElement class publicMethodsFor: 'xxx-garbage hunting'!

huntInDependents
	"CODEElement huntInDependents"

	| sC aDepDict |
	aDepDict := Object dependentsFields.

	sC := #(METANode METASimpleFilter METAObjectHolder CODEElement CMGenericObject) collect: [:aCN | Smalltalk at: aCN].
	aDepDict keys copy do: [:aK | 
		(sC detect: [:aC | aK isKindOf: aC] ifNone: [ nil]) isNil not ifTrue: [ aDepDict removeKey: aK]
	]! !

!CODEElement publicMethodsFor: 'accessing'!

expansions
	"Generated by ISF/AD. Do not modify"
	expansions isNil
		ifTrue: [self initExpansions].
	^expansions!

isNotPersistentMetaInfo
	"Generated by ISF/AD. Do not modify"
	isNotPersistentMetaInfo isNil
		ifTrue: [self initIsNotPersistentMetaInfo].
	^isNotPersistentMetaInfo!

isNotPersistentMetaInfo: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsNotPersistentMetaInfo: aValue) ifFalse: [^aValue].
	isNotPersistentMetaInfo := aValue.
	self markDirty.
	self changed: #isNotPersistentMetaInfo!

kind
	^self class kind!

name
	"Generated by ISF/AD. Do not modify"
	name isNil
		ifTrue: [self initName].
	^name!

name: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkName: aValue) ifFalse: [^aValue].
	name := aValue.
	self markDirty.
	self changed: #name!

timestamp
	^timestamp!

timestamp: theValue
	timestamp := theValue.
	self changed: #timestamp!

upperInitialName

	upperInitialName isNil
		ifTrue: [self initUpperInitialName].
	^upperInitialName! !

!CODEElement publicMethodsFor: 'configuration'!

getAlwaysShowSeparateTextPerspectivesInCreationDialogsParameterValue

	| aParameter |
	aParameter := self getCMAPDeveloperConfigurationParameter: CMAPDeveloperConfiguration alwaysShowSeparateTextPerspectivesInCreationDialogsParameterName default: true.
	^aParameter == true!

getCMAPDeveloperConfigurationParameter: theParameter default: theDefault

	| aConfiguration aParameter |

	theParameter isNil ifTrue: [ ^nil].
 
	aConfiguration := self cmapDeveloperConfiguration.
	aConfiguration isNil ifTrue: [ ^nil].
	
	aParameter := aConfiguration getParameter: theParameter default: theDefault.
	^aParameter!

getDiscardPerspectivesInCreationDialogsParameterValue

	| aParameter |
	aParameter := self getCMAPDeveloperConfigurationParameter: CMAPDeveloperConfiguration discardPerspectivesInCreationDialogsParameterName
		default: true.
	^aParameter == true!

getExpandRanliteralInitializationExpressionsParameterValue

	| aParameter |
	aParameter := self getCMAPDeveloperConfigurationParameter: CMAPDeveloperConfiguration expandRanliteralInitializationExpressionsParameterName default: true.
	^aParameter == true! !

!CODEElement publicMethodsFor: 'constants'!

attributeContentsNamePostfix
	^self class attributeContentsNamePostfix!

attributeContentsNamePrefix
	^self class attributeContentsNamePrefix!

relationshipContainerNamePostfix
	^self class relationshipContainerNamePostfix!

relationshipContainerNamePrefix
	^self class relationshipContainerNamePrefix!

relationshipContentsNamePostfix
	^self class relationshipContentsNamePostfix!

relationshipContentsNamePrefix
	^self class relationshipContentsNamePrefix!

relationshipNamePostfix
	^self class relationshipNamePostfix!

relationshipNamePrefix
	^self class relationshipNamePrefix! !

!CODEElement publicMethodsFor: 'derived accessing'!

cmapDeveloperConfiguration
	
	| aConfiguration aDeveloperConfiguration |
	aConfiguration := self applicationConfiguration.
	aConfiguration isNil ifTrue: [ ^nil].

	aDeveloperConfiguration := aConfiguration developerConfiguration.
	^aDeveloperConfiguration! !

!CODEElement publicMethodsFor: 'dirty'!

cleanDirtyMark
	dirty := false.	
	self changed: #dirty.!

doPersistIfDirty
	^false!

doPersistIfDirty: theValue

	theValue == true ifFalse: [ ^self].

	self persistIfDirty!

isDirty
	^dirty == true!

markDirty
	dirty == true ifFalse: [ 
		dirty := true.
		self changed: #dirty.
		timestamp := Time now.
		self changed: #timestamp.
	].!

markDirtyContainer
	self container isNil ifFalse: [ self container markDirtyContainer]!

markDirtyOwner!

persistIfDirty! !

!CODEElement publicMethodsFor: 'generate-support'!

expand: theKey
	expansionInitialized == true ifFalse: [ self initializeExpansions].

	^self expansions at: theKey ifAbsent: [
		(String with:self model expansionDelimiter) , theKey , (String with:self model expansionDelimiter)]!

expansion: theKey value: theValue

	self expansions at: theKey put: theValue!

initializeExpansions
	self expansions.
	expansionInitialized := true!

nextChunkFromTemplate: theStream
	|  aTextStream aC aKeyStream aDelimiter aGettingText aGettingKey |
	theStream isNil ifTrue: [ ^nil].
	theStream atEnd ifTrue: [ ^nil].

	aDelimiter := self model expansionDelimiter.
	aTextStream := WriteStream on: (String new: 512).
	aKeyStream := WriteStream on: (String new: 32).

	aGettingText := true.
	[  theStream atEnd not and: [ aGettingText]] 
		whileTrue: 
	[
		aC := theStream next.
		aC = aDelimiter
			ifTrue: [ aGettingText := false]
			ifFalse: [ aTextStream nextPut: aC]
	].
	theStream atEnd ifTrue: [ ^Array with: aTextStream contents with: nil].

	aGettingKey := true.
	[  theStream atEnd not and: [ aGettingKey]] 
		whileTrue: 
	[
		aC := theStream next.
		aC = aDelimiter
			ifTrue: [ aGettingKey := false]
			ifFalse: [ aKeyStream nextPut: aC]
	].
	^Array with: aTextStream contents with: aKeyStream contents!

toSetAttributeArgumentValue: theValue

	| aWriteStream |
	^(theValue isKindOf: String)
		ifTrue: [ '"' , (theValue copyReplaceAll: '\' with: '\\'), '"']
		ifFalse: [
			(theValue isKindOf: Array)
				ifTrue: [
					aWriteStream := WriteStream on: (String new: 256).
					aWriteStream nextPutAll: ' new String[] { '.
					theValue do: [:anElem |
						anElem isNil ifFalse: [ 
							aWriteStream nextPutAll: 
								((anElem isKindOf: String) ifTrue: [ '"' , anElem, '"'] ifFalse: [ anElem printString ]).
							anElem == theValue last ifFalse: [ aWriteStream nextPutAll: ','].
						]		
					].
					aWriteStream nextPutAll: ' } '.
					aWriteStream contents.
				]
				ifFalse: [ theValue printString ]].!

toUpperInitial: theName
	| anUpperName |
	theName isNil ifTrue: [ ^nil].
	theName isEmpty ifTrue: [ ^theName].

	anUpperName := (String with: theName first asUppercase) , (theName copyFrom: 2 to: theName size).
	^anUpperName! !

!CODEElement publicMethodsFor: 'initialize-release'!

initExpansions
	expansions := Dictionary new!

initIsNotPersistentMetaInfo
	isNotPersistentMetaInfo := false!

initName
	name := 'new ', self kind.!

initUpperInitialName
	upperInitialName := self toUpperInitial: self name!

release
	self changed: #objectDisconnectedOfTree.

	super release! !

!CODEElement publicMethodsFor: 'integrity'!

hasIntegrity
	
	| aReport aHasIntegrity |

	aReport := Dictionary new: 13.
	self integrityReportOn: aReport justFirst: true.
	aHasIntegrity := aReport isEmpty.
	^aHasIntegrity!

integrityReport
	
	| aReport |
	aReport := Dictionary new: 13.
	self integrityReportOn: aReport justFirst: false.
	^aReport!

integrityReport: theCriticsNode justFirst: theJustFirst

	| aCriticsNode |
	aCriticsNode := MDAMCriticsNode new.
	aCriticsNode element: self.
	^aCriticsNode!

integrityReportHereJustFirst: theJustFirst

	| aCriticsNode |
	aCriticsNode := MDAMCriticsNode new.
	aCriticsNode element: self.
	^aCriticsNode! !

!CODEElement publicMethodsFor: 'log'!

logTranscript
	^false! !

!CODEElement publicMethodsFor: 'navigation'!

browse
	^CODEMModelGenericBrowser
		openForObject: 			self 
		definitionsHolder: 		self defaultDefinitionsHolder
		browserParameters:	self defaultBrowserParameters!

browsePath

	^CODEMModelPathFinderGenericBrowser
		openForObject: 			self 
		definitionsHolder: 		self defaultDefinitionsHolder
		browserParameters:	self defaultBrowserParameters!

chooseWithPath

	| aValueHolder aDialogResult  |

	aValueHolder := nil asValue.

	aDialogResult := CODEMModelChooser
		openForObject: 			self 
		definitionsHolder: 		self defaultDefinitionsHolder
		browserParameters:	self defaultChooserParameters
		beDialog: true
		selectionOn: aValueHolder.

	aDialogResult == true ifFalse: [ ^nil].

	^aValueHolder value!

chooseWithPathAmong: theSelectableObjects navigable: theNavigableObjects

	| aValueHolder aDialogResult  aChooserParameters |

	aValueHolder := nil asValue.

	aChooserParameters := self defaultChooserParameters.
	aChooserParameters isNil ifTrue: [ aChooserParameters := Dictionary new: 13].

	((theNavigableObjects isNil not and: [ theNavigableObjects isEmpty not]) or: [ 
		theSelectableObjects isNil not and: [ theSelectableObjects isEmpty not]]) ifTrue: [ 

		(theNavigableObjects isNil not and: [ theNavigableObjects isEmpty not]) ifTrue: [ 
			aChooserParameters at: METABrowser navigableChooserObjectsSymbol put: theNavigableObjects
		].

		(theSelectableObjects isNil not and: [ theSelectableObjects isEmpty not]) ifTrue: [ 
			aChooserParameters at: METABrowser selectableChooserObjectsSymbol put: theSelectableObjects
		]
	].


	aChooserParameters at: METABrowser allowOkDialogWithoutSelectionParameterSymbol put: false.
	aChooserParameters at: METABrowser readOnlyBrowserParametersSymbol put: true.

	aDialogResult := CODEMModelChooser
		openForObject: 			self 
		definitionsHolder: 		self defaultDefinitionsHolder
		browserParameters:	aChooserParameters
		beDialog: true
		selectionOn: aValueHolder.

	aDialogResult == true ifFalse: [ ^nil].

	^aValueHolder value!

defaultBrowserParameters
	^self class defaultBrowserParameters!

defaultChooserParameters
	^self class defaultChooserParameters!

defaultDefinitionsHolder
	^self class defaultDefinitionsHolder!

displayName
	^self kind , ' ', self name!

metaClass

	^self class!

metaEditorClassLabel

	^self classLabelForMETAEditor!

metaNameSelector
	^#name!

metaSelectorsSelector
	^#metaSelectors

"*VIPVersion 15-7-97 | 8:30:48 pm 'ACV'*"! !

!CODEElement publicMethodsFor: 'parse'!

nextTokenFrom: theStream
	
	| aWordStream |
	theStream isNil ifTrue: [ ^nil].
	theStream atEnd ifTrue: [ ^nil].
	
	aWordStream := WriteStream on: (String new: 64).
	[ theStream atEnd] whileFalse: [ | aChar |
		aChar := theStream peek.
		aChar isSeparator
			ifTrue: [ 
				theStream next.
				aWordStream  writePosition > 0 
					ifTrue: [ ^aWordStream contents]
			] 
			ifFalse: [ 
				(aChar isAlphaNumeric or: [ aChar = $_ or: [aChar = $:]])
					ifTrue: [ 
						theStream next.
						aWordStream nextPut: aChar
					]
					ifFalse: [ 
						theStream next.
						aWordStream  writePosition > 0 
							ifTrue: [ ^aWordStream contents]
							ifFalse: [ ^String with: aChar]
					]
			]	
	].
	^aWordStream  writePosition > 0 
		ifTrue: [ aWordStream contents]
		ifFalse: [ nil]!

nextTokenFrom: theStream stopAt: theChars
	
	| aWordStream |
	theStream isNil ifTrue: [ ^nil].
	theStream atEnd ifTrue: [ ^nil].
	
	aWordStream := WriteStream on: (String new: 64).
	[ theStream atEnd] whileFalse: [ | aChar |
		aChar := theStream peek.
		(theChars includes: aChar) ifTrue: [  ^aWordStream contents].
		aChar isSeparator
			ifTrue: [ 
				theStream next.
				aWordStream  writePosition > 0 
					ifTrue: [ ^aWordStream contents]
			] 
			ifFalse: [ 
				(aChar isAlphaNumeric or: [ aChar = $_ or: [aChar = $:]])
					ifTrue: [ 
						theStream next.
						aWordStream nextPut: aChar
					]
					ifFalse: [ 
						theStream next.
						aWordStream  writePosition > 0 
							ifTrue: [ ^aWordStream contents]
							ifFalse: [ ^String with: aChar]
					]
			]	
	].
	^aWordStream  writePosition > 0 
		ifTrue: [ aWordStream contents]
		ifFalse: [ nil]!

nextTypeTokenFrom: theStream
	
	| aWordStream |
	theStream isNil ifTrue: [ ^nil].
	theStream atEnd ifTrue: [ ^nil].
	
	aWordStream := WriteStream on: (String new: 64).
	[ theStream atEnd] whileFalse: [ | aChar |
		aChar := theStream peek.
		aChar isSeparator
			ifTrue: [ 
				theStream next.
				aWordStream  writePosition > 0 
					ifTrue: [ ^aWordStream contents]
			] 
			ifFalse: [ 
				(aChar isAlphaNumeric or: [ aChar = $_ or: [aChar = $: or: [aChar = $[ or: [aChar = $] ]]]])
					ifTrue: [ 
						theStream next.
						aWordStream nextPut: aChar.
						aChar = $] ifTrue: [  ^aWordStream contents]
					]
					ifFalse: [ 
						theStream next.
						aWordStream  writePosition > 0 
							ifTrue: [ ^aWordStream contents]
							ifFalse: [ ^String with: aChar]
					]
			]	
	].
	^aWordStream  writePosition > 0 
		ifTrue: [ aWordStream contents]
		ifFalse: [ nil]! !

!CODEElement publicMethodsFor: 'persistence-code'!

allQualifiedNames
	| aCollection |
	aCollection := OrderedCollection new: 8.
	self allQualifiedNamesInto: aCollection.
	^aCollection!

allQualifiedNamesInto: theStream

	| aSep |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

fpi
	^self firstPersistenceIndex!

indentStringForPersistenceAsCode
	^self class indentStringForPersistenceAsCode!

initFromValues: theValues!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS!

numberPersistenceEntriesElement
	^2!

pcForV: theValue

	| aValue |
	(theValue isKindOf: Symbol) ifFalse: [
		((theValue isKindOf: String) or: [ theValue isKindOf: Integer]) ifTrue: [ ^theValue printString].
		aValue := theValue.
		(aValue isKindOf: Number) ifTrue: [ aValue := ((theValue * 1000)  asInteger / 1000) asFloat].
		^aValue printString
	].

	(theValue isKindOf: Symbol) ifTrue: [ 
		(theValue isEmpty or: [ theValue asString first isLetter not]) ifTrue: [ 
			^theValue printString
		]
	].

	^theValue asArrayOfSubstrings size > 1 
		ifTrue: [ theValue printString] 
		ifFalse: [ theValue asString]!

persistenceAsCodeStringOn: theStream indent: theIS

	| aSep |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
		
	theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self kind);  
		nextPutAll: aSep; nextPutAll: self name printString; cr.

	self localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr.!

ph2InitFromSolver: theSolver!

preferredInstallerClass
	^self class preferredInstallerClass!

separatorForPersistenceAsCode
	^self class separatorForPersistenceAsCode! !

!CODEElement publicMethodsFor: 'preferences'!

preferredArgumentClass
	^self class preferredArgumentClass!

preferredArgumentRefinementClass
	^self class preferredArgumentRefinementClass!

preferredAspectClass
	^self class preferredAspectClass!

preferredAttributeClass
	^self class preferredAttributeClass!

preferredAttributeRefinementClass
	^self class preferredAttributeRefinementClass!

preferredCommentClass
	^self class preferredCommentClass!

preferredElementMapClass
	^self class preferredElementMapClass!

preferredMapClass
	^self class preferredMapClass!

preferredMapLogicClass
	^self class preferredMapLogicClass!

preferredMapsFolderClass
	^self class preferredMapsFolderClass!

preferredModelClass
	^self class preferredModelClass!

preferredModuleClass
	^self class preferredModuleClass!

preferredOperationClass
	^self class preferredOperationClass!

preferredOperationRefinementClass
	^self class preferredOperationRefinementClass!

preferredParameterClass
	^self class preferredParameterClass!

preferredRelationshipClass
	^self class preferredRelationshipClass!

preferredRelationshipRefinementClass
	^self class preferredRelationshipRefinementClass!

preferredSystemPrimitiveBrokerClass
	^self class preferredSystemPrimitiveBrokerClass!

preferredTypeClass
	^self class preferredTypeClass!

preferredTypeDependencyClass
	^self class preferredTypeDependencyClass!

preferredTypeObserverClass
	^self class preferredTypeObserverClass! !

!CODEElement publicMethodsFor: 'printing'!

printOn: theStream
	theStream nextPutAll: self kind; space; nextPutAll: self name; space
	"theStream nextPut: $(.
	theStream nextPutAll: self class name.
	theStream nextPut: Character space.
	theStream nextPutAll: self name.
	theStream nextPut: $).
	theStream nextPut: Character space."! !

!CODEElement publicMethodsFor: 'semantic checking'!

checkIsNotPersistentMetaInfo: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkName: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEElement publicMethodsFor: 'semantic links'!

nameCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self name!

nameCreate
	"Generated by ISF/AD. Do not modify"
	^''!

nameLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self name: self nameCreate.!

nameLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self nameCandidates
		initially: self name
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self name: anObject.!

nameLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self nameCandidates
		initially: self name
		label: 'Select Or Create ...'
		class: self nameCreate class
		ifUnchanged: [^self].
	self name: anObject!

nameScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEElement publicMethodsFor: 'testing'!

isAttribute
	^false!

isFeature
	^false!

isMap
	^false!

isModel
	^false!

isOperation
	^false!

isRefinement
	^false!

isRelationship
	^false!

isStructuralFeature
	^false!

isType
	^false! !

!CODEElementMap class publicMethodsFor: 'accessing'!

kind
	^#elementMap! !

!CODEElementMap class publicMethodsFor: 'navigation'!

mapEditorSelectingFromSourceModelMETAPerspectives
	^self modelEditorMETAPerspectives!

mapEditorSelectingFromSourceModelMETASelectors

	^super modelEditorMETASelectors , self mapEditorSelectingFromSourceModelMETASelectorsElementMap,
		self modelEditorMETASelectorsTranslation!

mapEditorSelectingFromSourceModelMETASelectorsElementMap

	"METAChildSpecAutoViewEditor openOn: CODEElementMap selector: #modelEditorMETASelectorsElementMap target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubElementMaps';
			basicSelector: #subElementMaps;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubElementMaps';
			displaySelector: #name;
			componentsClassName: #CODEElementMap;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			customAddSelector:  #subElementMapsLinkCreateSelectingFromSourceModel;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'SubElementMaps';
			nlsTranslation: 'SubCorrespondencias';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ViewElements';
			basicSelector: #viewElements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'VIewElements';
			displaySelector: #name;
			componentsClassName: #CODEElement;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'VIewElements';
			nlsTranslation: 'ElementosVista';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SourceElements';
			basicSelector: #sourceElements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'SourceElements';
			displaySelector: #name;
			componentsClassName: #CODEElement;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'SourceElements';
			nlsTranslation: 'ElementosFuente';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MapLogic';
			basicSelector: #mapLogic;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MapLogic';
			displaySelector: nil;
			objectClassName: #CODEMapLogic;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'MapLogic';
			nlsTranslation: 'LogicaDeCorrespondencia';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperElementMap';
			basicSelector: #superElementMap;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperElementMap';
			displaySelector: #name;
			objectClassName: #CODEElementMap;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'SuperElementMap';
			nlsTranslation: 'SuperCorrespondencia';
			yourself);
	add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MapsFolder';
			basicSelector: #mapsFolder;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MapsFolder';
			displaySelector: #name;
			objectClassName: #CODEMapsFolder;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'MapsFolder';
			nlsTranslation: 'CarpetaDeCorrespondencias';
			yourself);
		yourself!

mapEditorSelectingFromSourceModelPathElectors
	^self modelEditorMETAPerspectives!

mapEditorSelectingFromSourceModelPathSelectors
	^self modelEditorPathSelectors!

modelEditorMETAPerspectives

	^super modelEditorMETAPerspectives, self modelEditorMETAPerspectivesElementMap,
		self modelEditorMETAPerspectivesTranslation!

modelEditorMETAPerspectivesElementMap

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SubElementMaps'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'SubElementMaps' )))
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Perspectives';
			nlsItem: 'SubElementMaps';
			nlsTranslation: 'SubCorrespondencias';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ViewElements'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'ViewElements' )))
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Perspectives';
			nlsItem: 'ViewElements';
			nlsTranslation: 'ElementosVista';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SourceElements'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'SourceElements' )))
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Perspectives';
			nlsItem: 'SourceElements';
			nlsTranslation: 'ElementosFuente';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'MapLogic'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'MapLogic' )))
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Perspectives';
			nlsItem: 'MapLogic';
			nlsTranslation: 'LogicaDeCorrespondencia';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SuperElementMap'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'SuperElementMap' )))
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Perspectives';
			nlsItem: 'SuperElementMap';
			nlsTranslation: 'SuperCorrespondencia';
			yourself);
	addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'MapsFolder'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'MapsFolder' )))
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Perspectives';
			nlsItem: 'MapsFolder';
			nlsTranslation: 'CarpetaDeCorrespondencias';
			yourself);
		yourself!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'MapLogic' 'IsDirty')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsElementMap,
		self modelEditorMETASelectorsTranslation!

modelEditorMETASelectorsElementMap

	"METAChildSpecAutoViewEditor openOn: CODEElementMap selector: #modelEditorMETASelectorsElementMap target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubElementMaps';
			basicSelector: #subElementMaps;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubElementMaps';
			displaySelector: #name;
			componentsClassName: #CODEElementMap;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'SubElementMaps';
			nlsTranslation: 'SubCorrespondencias';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ViewElements';
			basicSelector: #viewElements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'VIewElements';
			displaySelector: #name;
			componentsClassName: #CODEElement;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'VIewElements';
			nlsTranslation: 'ElementosVista';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SourceElements';
			basicSelector: #sourceElements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'SourceElements';
			displaySelector: #name;
			componentsClassName: #CODEElement;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'SourceElements';
			nlsTranslation: 'ElementosFuente';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MapLogic';
			basicSelector: #mapLogic;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MapLogic';
			displaySelector: nil;
			objectClassName: #CODEMapLogic;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'MapLogic';
			nlsTranslation: 'LogicaDeCorrespondencia';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperElementMap';
			basicSelector: #superElementMap;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperElementMap';
			displaySelector: #name;
			objectClassName: #CODEElementMap;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'SuperElementMap';
			nlsTranslation: 'SuperCorrespondencia';
			yourself);
	add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MapsFolder';
			basicSelector: #mapsFolder;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MapsFolder';
			displaySelector: #name;
			objectClassName: #CODEMapsFolder;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'ElementMap_Selectors';
			nlsItem: 'MapsFolder';
			nlsTranslation: 'CarpetaDeCorrespondencias';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsElementMap.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsElementMap

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('SubElementMaps'  'ViewElements' 'SourceElements' 'MapLogic' 'SuperElementMap'  'MapsFolder' )! !

!CODEElementMap publicMethodsFor: 'association initialize-release'!

initSourceElements
	sourceElements := OrderedCollection new.!

initSubElementMaps
	subElementMaps := OrderedCollection new.!

initViewElements
	viewElements := OrderedCollection new.!

mapLogicRelease

	| aMapLogic |
	mapLogic == nil
		ifFalse:
			[ aMapLogic := mapLogic.
				mapLogic := nil.
 				aMapLogic elementMapRelease.
				self changed: #mapLogic]!

mapsFolderRelease

	mapsFolder == nil
		ifFalse:
			[mapsFolder elementMapsPrivateRemove: self.
				mapsFolder := nil.
				self changed: #mapsFolder]!

sourceElementsRelease

	self sourceElements do: [:each | self sourceElementsRemove: each]!

subElementMapsRelease

	self subElementMaps do: [:each | self subElementMapsRemove: each]!

superElementMapRelease

	superElementMap == nil
		ifFalse:
			[superElementMap typesPrivateRemove: self.
				superElementMap := nil.
				self changed: #superElementMap]!

viewElementsRelease

	self viewElements do: [:each | self viewElementsRemove: each]! !

!CODEElementMap publicMethodsFor: 'associations accessing'!

mapLogic

	^mapLogic!

mapLogic: aValue

	(self checkMapLogic: aValue) ifFalse: [^aValue].
	mapLogic == aValue ifTrue: [ ^self].
	self mapLogicRelease.
	mapLogic := aValue.
	aValue == nil ifFalse: [aValue elementMap: self].
	self changed: #mapLogic!

mapsFolder

	^mapsFolder!

mapsFolder: aValue

	(self checkMapsFolder: aValue) ifFalse: [^aValue].
	mapsFolder == aValue ifTrue: [ ^self].
	aValue = nil ifTrue: [ self release].

	self mapsFolderRelease.
	mapsFolder := aValue.
	aValue == nil ifFalse: [aValue subElementMapsPrivateAdd: self].
	self changed: #mapsFolder!

sourceElements

	^self sourceElementsPrivate copy!

sourceElementsAsArray

	^self sourceElements asArray!

subElementMaps

	^self subElementMapsPrivate copy!

subElementMapsAsArray

	^self subElementMaps asArray!

superElementMap

	^superElementMap!

superElementMap: aValue

	(self checkSuperElementMap: aValue) ifFalse: [^aValue].
	superElementMap == aValue ifTrue: [ ^self].
	self superElementMapRelease.
	superElementMap := aValue.
	aValue == nil ifFalse: [aValue subElementMapsPrivateAdd: self].
	self changed: #superElementMap!

viewElements

	^self viewElementsPrivate copy!

viewElementsAsArray

	^self viewElements asArray! !

!CODEElementMap publicMethodsFor: 'associations modifying'!

sourceElementsAdd: aValue

	(self checkSourceElementsAdd: aValue) ifFalse: [^aValue].
	(self sourceElementsIncludes: aValue) ifTrue: [^self sourceElementsMoveBottom: aValue].
	self sourceElementsPrivateAdd: aValue.
	self changed: #sourceElements.
	^aValue!

sourceElementsMoveBottom: aValue

	(self sourceElementsIncludes: aValue) ifFalse: [^aValue].
	(self sourceElements indexOf: aValue) = self sourceElementsSize ifTrue: [^aValue].
	self sourceElementsPrivate remove: aValue.
	^self sourceElementsPrivateAdd: aValue!

sourceElementsMoveDown: aValue

	| index |
	(self sourceElementsIncludes: aValue) ifFalse: [^aValue].
	(index := self sourceElements indexOf: aValue) = self sourceElementsSize ifTrue: [^aValue].
	index = (self sourceElementsSize -1)
		ifTrue:
			[self sourceElementsPrivate remove: aValue.
			^self sourceElementsPrivateAdd: aValue].
	^self sourceElementsPrivateMove: aValue beforeIndex: index + 2!

sourceElementsMoveTop: aValue

	(self sourceElementsIncludes: aValue) ifFalse: [^aValue].
	(self sourceElements indexOf: aValue) = 1 ifTrue: [^aValue].
	self sourceElementsPrivateMove: aValue beforeIndex: 1!

sourceElementsMoveUp: aValue

	| index |
	(self sourceElementsIncludes: aValue) ifFalse: [^aValue].
	(index := self sourceElements indexOf: aValue) = 1 ifTrue: [^aValue].
	^self sourceElementsPrivateMove: aValue beforeIndex: index - 1!

sourceElementsRemove: aValue

	(self checkSourceElementsRemove: aValue) ifFalse: [^aValue].
	self sourceElementsPrivate remove: aValue ifAbsent: [^aValue].
	self changed: #sourceElements.
	^aValue!

subElementMapsAdd: aValue

	(self checkSubElementMapsAdd: aValue) ifFalse: [^aValue].
	(self subElementMapsIncludes: aValue) ifTrue: [^self subElementMapsMoveBottom: aValue].
	(self subElementMapsPrivateAdd: aValue) superElementMapPrivate: self.
	self changed: #subElementMaps.
	^aValue!

subElementMapsMoveBottom: aValue

	(self subElementMapsIncludes: aValue) ifFalse: [^aValue].
	(self subElementMaps indexOf: aValue) = self subElementMapsSize ifTrue: [^aValue].
	self subElementMapsPrivate remove: aValue.
	^self subElementMapsPrivateAdd: aValue!

subElementMapsMoveDown: aValue

	| index |
	(self subElementMapsIncludes: aValue) ifFalse: [^aValue].
	(index := self subElementMaps indexOf: aValue) = self subElementMapsSize ifTrue: [^aValue].
	index = (self subElementMapsSize -1)
		ifTrue:
			[self subElementMapsPrivate remove: aValue.
			^self subElementMapsPrivateAdd: aValue].
	^self subElementMapsPrivateMove: aValue beforeIndex: index + 2!

subElementMapsMoveTop: aValue

	(self subElementMapsIncludes: aValue) ifFalse: [^aValue].
	(self subElementMaps indexOf: aValue) = 1 ifTrue: [^aValue].
	self subElementMapsPrivateMove: aValue beforeIndex: 1!

subElementMapsMoveUp: aValue

	| index |
	(self subElementMapsIncludes: aValue) ifFalse: [^aValue].
	(index := self subElementMaps indexOf: aValue) = 1 ifTrue: [^aValue].
	^self subElementMapsPrivateMove: aValue beforeIndex: index - 1!

subElementMapsRemove: aValue

	(self checkSubElementMapsRemove: aValue) ifFalse: [^aValue].
	(self subElementMapsPrivate remove: aValue ifAbsent: [^aValue]) superElementMapPrivate: nil.
	self changed: #subElementMaps.
	^aValue!

viewElementsAdd: aValue

	(self checkViewElementsAdd: aValue) ifFalse: [^aValue].
	(self viewElementsIncludes: aValue) ifTrue: [^self viewElementsMoveBottom: aValue].
	self viewElementsPrivateAdd: aValue.
	self changed: #viewElements.
	^aValue!

viewElementsMoveBottom: aValue

	(self viewElementsIncludes: aValue) ifFalse: [^aValue].
	(self viewElements indexOf: aValue) = self viewElementsSize ifTrue: [^aValue].
	self viewElementsPrivate remove: aValue.
	^self viewElementsPrivateAdd: aValue!

viewElementsMoveDown: aValue

	| index |
	(self viewElementsIncludes: aValue) ifFalse: [^aValue].
	(index := self viewElements indexOf: aValue) = self viewElementsSize ifTrue: [^aValue].
	index = (self viewElementsSize -1)
		ifTrue:
			[self viewElementsPrivate remove: aValue.
			^self viewElementsPrivateAdd: aValue].
	^self viewElementsPrivateMove: aValue beforeIndex: index + 2!

viewElementsMoveTop: aValue

	(self viewElementsIncludes: aValue) ifFalse: [^aValue].
	(self viewElements indexOf: aValue) = 1 ifTrue: [^aValue].
	self viewElementsPrivateMove: aValue beforeIndex: 1!

viewElementsMoveUp: aValue

	| index |
	(self viewElementsIncludes: aValue) ifFalse: [^aValue].
	(index := self viewElements indexOf: aValue) = 1 ifTrue: [^aValue].
	^self viewElementsPrivateMove: aValue beforeIndex: index - 1!

viewElementsRemove: aValue

	(self checkViewElementsRemove: aValue) ifFalse: [^aValue].
	self viewElementsPrivate remove: aValue ifAbsent: [^aValue].
	self changed: #viewElements.
	^aValue! !

!CODEElementMap publicMethodsFor: 'associations private'!

mapLogicPrivate: aValue
	mapLogic := aValue.
	self changed: #mapLogic.!

mapsFolderPrivate: aValue
	| aPrevValue |
	aPrevValue := mapsFolder.
	mapsFolder := aValue.
	self changed: #mapsFolder.
	(mapsFolder isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

sourceElementsPrivate

	sourceElements isNil
		ifTrue: [self initSourceElements].
	^sourceElements!

sourceElementsPrivateAdd: aValue

	self sourceElementsPrivate add: aValue.
	self markDirty.

	self changed: #sourceElements.
	^aValue!

sourceElementsPrivateMove: aValue beforeIndex: anIndex

	| obj |
	obj := self sourceElements at: anIndex.
	self sourceElementsPrivate remove: aValue.
	self sourceElementsPrivate add: aValue before: obj.
	self markDirty.

	self changed: #sourceElements.
	^aValue!

sourceElementsPrivateRemove: aValue

	self sourceElementsPrivate remove: aValue.
	self markDirty.

	self changed: #sourceElements.
	^aValue!

subElementMapsPrivate

	subElementMaps isNil
		ifTrue: [self initSubElementMaps].
	^subElementMaps!

subElementMapsPrivateAdd: aValue

	self subElementMapsPrivate add: aValue.
	self markDirty.

	self changed: #subElementMaps.
	^aValue!

subElementMapsPrivateMove: aValue beforeIndex: anIndex

	| obj |
	obj := self subElementMaps at: anIndex.
	self subElementMapsPrivate remove: aValue.
	self subElementMapsPrivate add: aValue before: obj.
	self markDirty.

	self changed: #subElementMaps.
	^aValue!

subElementMapsPrivateRemove: aValue

	self subElementMapsPrivate remove: aValue.
	self markDirty.

	self changed: #subElementMaps.
	^aValue!

superElementMapPrivate: aValue
	| aPrevValue |
	aPrevValue := superElementMap.
	superElementMap := aValue.
	self changed: #superElementMap.
	(superElementMap isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

viewElementsPrivate

	viewElements isNil
		ifTrue: [self initViewElements].
	^viewElements!

viewElementsPrivateAdd: aValue

	self viewElementsPrivate add: aValue.
	self markDirty.

	self changed: #viewElements.
	^aValue!

viewElementsPrivateMove: aValue beforeIndex: anIndex

	| obj |
	obj := self viewElements at: anIndex.
	self viewElementsPrivate remove: aValue.
	self viewElementsPrivate add: aValue before: obj.
	self markDirty.

	self changed: #viewElements.
	^aValue!

viewElementsPrivateRemove: aValue

	self viewElementsPrivate remove: aValue.
	self markDirty.

	self changed: #viewElements.
	^aValue! !

!CODEElementMap publicMethodsFor: 'associations testing'!

sourceElementsIncludes: aValue

	^sourceElements isNil
		ifTrue: [false]
		ifFalse: [self sourceElements includes: aValue]!

sourceElementsSize

	^sourceElements isNil
		ifTrue: [0]
		 ifFalse: [sourceElements size]!

subElementMapsIncludes: aValue

	^subElementMaps isNil
		ifTrue: [false]
		ifFalse: [self subElementMaps includes: aValue]!

subElementMapsSize

	^subElementMaps isNil
		ifTrue: [0]
		 ifFalse: [subElementMaps size]!

viewElementsIncludes: aValue

	^viewElements isNil
		ifTrue: [false]
		ifFalse: [self viewElements includes: aValue]!

viewElementsSize

	^viewElements isNil
		ifTrue: [0]
		 ifFalse: [viewElements size]! !

!CODEElementMap publicMethodsFor: 'build from source'!

attributeSpecificModuleNameFor: theAttribute
	theAttribute isNil ifTrue: [ ^nil].

	^theAttribute type name, '_', theAttribute name, '_ValueTypes_Module'!

createNLSForElementMap: theElementMap  viewFeature: theViewFeature

"	Create NLS in the Maps translation for the new ElementMap using the ItemTranslation of the new View Feature
"
	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMapTranslation aMapTranslationItem aMap |

	theElementMap isNil ifTrue: [ ^nil].
	theViewFeature isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aMapTranslation := aMap nlsSolver.
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].


	(aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap nameNLSGroupName 
		item: theElementMap nameNLSItemName) isNil ifTrue: [ 

		aMapTranslationItem := aMapTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewFeature nameNLSGroupName 
			item: theViewFeature nameNLSItemName.
		aMapTranslationItem isNil ifFalse: [

			aMapTranslation 
				recordNLSGroup: theElementMap nameNLSGroupName 
				item: theElementMap nameNLSItemName
				translation: '%1 (', (String with: theViewFeature kind first asUppercase), ')'.

			aNewTranslationItem := aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap  nameNLSGroupName
				item: theElementMap nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aMapTranslationItem
			]
		]
	].!

createNLSForElementMap: theElementMap  viewType: theViewType

"	Create NLS in the Maps translation for the new ElementMap using the ItemTranslation of the new View Type
"
	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMapTranslation aMapTranslationItem aMap |

	theElementMap isNil ifTrue: [ ^nil].
	theViewType isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aMapTranslation := aMap nlsSolver.
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].


	(aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap nameNLSGroupName 
		item: theElementMap nameNLSItemName) isNil ifTrue: [ 

		aMapTranslationItem := aMapTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewType nameNLSGroupName 
			item: theViewType nameNLSItemName.
		aMapTranslationItem isNil ifFalse: [

			aMapTranslation 
				recordNLSGroup: theElementMap nameNLSGroupName 
				item: theElementMap nameNLSItemName
				translation: '%1 (T)' copy.

			aNewTranslationItem := aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap  nameNLSGroupName
				item: theElementMap nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aMapTranslationItem
			]
		]
	].!

createNLSForMapsFolder: theMapsFolder  viewModule: theViewModule

"	Create NLS in the Maps translation for the new MapsFolder using the ItemTranslation of the new View Module
"
	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMapTranslation aMapTranslationItem aMap |

	theMapsFolder isNil ifTrue: [ ^nil].
	theViewModule isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aMapTranslation := aMap nlsSolver.
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].


	(aMapTranslation nlsLocalResolverItemGroupNoDefault: theMapsFolder nameNLSGroupName 
		item: theMapsFolder nameNLSItemName) isNil ifTrue: [ 

		aMapTranslationItem := aMapTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewModule nameNLSGroupName 
			item: theViewModule nameNLSItemName.
		aMapTranslationItem isNil ifFalse: [

			aMapTranslation 
				recordNLSGroup: theMapsFolder nameNLSGroupName 
				item: theMapsFolder nameNLSItemName.

			aNewTranslationItem := aMapTranslation nlsLocalResolverItemGroupNoDefault: theMapsFolder  nameNLSGroupName
				item: theMapsFolder nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aMapTranslationItem
			]
		]
	].!

createNLSForMapsFolders: theMapsFolders

"	Create (if it does not exists yet)  a new NLS in the Translation of the View Model,
		for each of the argument theMapsFolders,
		using the ItemTranslation of the corresponding (by fullyQualifiedNameArray) view Module in the View Model
"

	| aViewModel aViewTranslation aMap aMapTranslation |

	(theMapsFolders isNil or: [ theMapsFolders isEmpty]) ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aMapTranslation := aMap nlsSolver.
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].


	theMapsFolders do: [:aMapsFolder |  | aViewModule |
		aViewModule := aViewModel moduleNamedArray:  aMapsFolder fullyQualifiedNameArray.
		aViewModule isNil ifFalse: [ 
			self createNLSForMapsFolder: aMapsFolder  viewModule: aViewModule 
		]
	].!

createNLSForViewFeature: theViewFeature  sourceFeature: theSourceFeature

"	Create a new NLS in the Translation of the View Model,
	using the ItemTranslation of the source Feature in the Source Model
"

	| aViewModel aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem aMap |
	theViewFeature isNil ifTrue: [ ^nil].
	theSourceFeature isNil ifTrue: [ ^nil].
	
	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].

	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewFeature nameNLSGroupName 
		item: theViewFeature nameNLSItemName) isNil ifTrue: [ 

		aSourceTranslationItem := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceFeature nameNLSGroupName 
			item: theSourceFeature nameNLSItemName.
		aSourceTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewFeature nameNLSGroupName 
				item: theViewFeature nameNLSItemName.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewFeature  nameNLSGroupName
				item: theViewFeature nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem
			]
		]
	].!

createNLSForViewInverseRelationship: theViewInverseRelationship elementMap: theElementMap

"	Create a NLS for the new inverse relationship ElementMap, in the Map's translation,
		using the NLS for the view inverse relationship
"

	| aMap aViewModel aViewTranslation aNewTranslationItem aMapTranslation aViewTranslationItem |

	theViewInverseRelationship isNil ifTrue: [ ^nil].
	theElementMap isNil ifTrue: [ ^nil].

	aMap := theElementMap map.
	aMap isNil ifTrue: [ ^nil].

	aMapTranslation := aMap nlsSolver.
	aMapTranslation isNil ifTrue: [ ^nil].
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].

	(aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap nameNLSGroupName 
		item: theElementMap nameNLSItemName) isNil ifTrue: [ 

		aViewTranslationItem := aMapTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewInverseRelationship nameNLSGroupName 
			item: theViewInverseRelationship nameNLSItemName.
		aViewTranslationItem isNil ifFalse: [

			aMapTranslation 
				recordNLSGroup: theElementMap nameNLSGroupName  item: theElementMap nameNLSItemName.

			aNewTranslationItem := aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap nameNLSGroupName
				item: theElementMap nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aViewTranslationItem
			]
		]
	].!

createNLSForViewInverseRelationship: theViewInverseRelationship  sourceInverseRelationship: theSourceInverseRelationship

"Create a NLS  item (or two, if inverse relationship has multiplicity many) for the  inverse relationship
"

	| aMap aViewModel aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem aSourceTranslationItemOne aNewTranslationItemOne |
	theViewInverseRelationship isNil ifTrue: [ ^nil].
	theSourceInverseRelationship isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].

	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewInverseRelationship nameNLSGroupName 
		item: theViewInverseRelationship nameNLSItemName) isNil ifTrue: [ 

		aSourceTranslationItem := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceInverseRelationship nameNLSGroupName 
			item: theSourceInverseRelationship nameNLSItemName.
		aSourceTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewInverseRelationship nameNLSGroupName 
				item: theViewInverseRelationship nameNLSItemName.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewInverseRelationship  nameNLSGroupName
				item: theViewInverseRelationship nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem
			]
		]
	].


	(theViewInverseRelationship isMultiplicityMany and: [ 
		(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewInverseRelationship nameNLSGroupName 
		item: theViewInverseRelationship nameNLSItemName) isNil])  ifTrue: [ 

		aSourceTranslationItemOne := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceInverseRelationship nameNLSGroupName 
			item: theSourceInverseRelationship nameNLSItemNameOne.
		aSourceTranslationItemOne isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theSourceInverseRelationship nameNLSGroupName 
				item: theSourceInverseRelationship nameNLSItemNameOne.

			aNewTranslationItemOne := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewInverseRelationship  nameNLSGroupName
				item: theViewInverseRelationship nameNLSItemNameOne.
			aNewTranslationItemOne isNil ifFalse: [
				aNewTranslationItemOne usedItemTranslationsAdd: aSourceTranslationItemOne
			]
		]
	].!

createNLSForViewModule: theViewModule  sourceModule: theSourceModule

"	Create (if it does not exists yet)  a new NLS in the Translation of the View Model,
		using the ItemTranslation of the source Module in the Source Model
"

	| aViewModel aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem aMap |
	theViewModule isNil ifTrue: [ ^nil].
	theSourceModule isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].

	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule nameNLSGroupName 
		item: theViewModule nameNLSItemName) isNil ifTrue: [ 

		aSourceTranslationItem := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceModule nameNLSGroupName 
			item: theSourceModule nameNLSItemName.
		aSourceTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewModule nameNLSGroupName 
				item: theViewModule nameNLSItemName.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule  nameNLSGroupName
				item: theViewModule nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem
			]
		]
	].!

createNLSForViewModule: theViewModule  viewAttribute: theViewAttribute


"	 If new View module to be used solely by the attribute was created, 
		create NLS for the ViewModules using as Arguments the ItemTranslation of the Attribute
		(someting like 'Module for Attribute %1')
"

	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMap aAttributeTranslationItem |

	theViewModule isNil ifTrue: [ ^nil].
	theViewAttribute isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].



	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule nameNLSGroupName 
		item: theViewModule nameNLSItemName) isNil ifTrue: [ 

		aAttributeTranslationItem := aViewTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewAttribute nameNLSGroupName 
			item: theViewAttribute nameNLSItemName.
		aAttributeTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewModule nameNLSGroupName 
				item: theViewModule nameNLSItemName
				translation: '%1_', theViewAttribute nlsKind, '_specific'.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule  nameNLSGroupName
				item: theViewModule nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aAttributeTranslationItem
			]
		]
	].!

createNLSForViewModule: theViewModule  viewRelationship: theViewRelationship


"	 If new View module to be used solely by the relationship was created, 
		create NLS for the ViewModules using as Arguments the ItemTranslation of the Relationship
		(someting like 'Module for Relationship %1')
"

	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMap aRelationshipTranslationItem |

	theViewModule isNil ifTrue: [ ^nil].
	theViewRelationship isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].



	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule nameNLSGroupName 
		item: theViewModule nameNLSItemName) isNil ifTrue: [ 

		aRelationshipTranslationItem := aViewTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewRelationship nameNLSGroupName 
			item: theViewRelationship nameNLSItemName.
		aRelationshipTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewModule nameNLSGroupName 
				item: theViewModule nameNLSItemName
				translation: '%1_', theViewRelationship nlsKind, '_specific'.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule  nameNLSGroupName
				item: theViewModule nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aRelationshipTranslationItem
			]
		]
	].!

createNLSForViewModules: theViewModules

"	Create (if it does not exists yet)  a new NLS in the Translation of the View Model,
		for each of the argument theViewModules,
		using the ItemTranslation of the corresponding (by fullyQualifiedNameArray) source Module in the Source Model
"

	| aViewModel aSourceModel aViewTranslation aSourceTranslation aMap |

	(theViewModules isNil or: [ theViewModules isEmpty]) ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].


	theViewModules do: [:aViewModule |  | aSourceModule |
		aSourceModule := aSourceModel moduleNamedArray:  aViewModule fullyQualifiedNameArray.
		aSourceModule isNil ifFalse: [ 
			self createNLSForViewModule: aViewModule  sourceModule: aSourceModule
		]
	].!

createNLSForViewType: theViewType  sourceType: theSourceType

"	Create (if it does not exists yet)  a new NLS in the Translation of the View Model,
		using the ItemTranslation of the source Type in the Source Model
"

	| aViewModel aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem aMap |

	theViewType isNil ifTrue: [ ^nil].
	theSourceType isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].

	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewType nameNLSGroupName 
		item: theViewType nameNLSItemName) isNil ifTrue: [ 

		aSourceTranslationItem := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceType nameNLSGroupName 
			item: theSourceType nameNLSItemName.
		aSourceTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewType nameNLSGroupName 
				item: theViewType nameNLSItemName.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewType  nameNLSGroupName
				item: theViewType nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem
			]
		]
	].!

createSubTypesFlatForViewType: theViewType sourceType: theSourceType module: theModule
	sourceTypesInto: theSourceSubTypes 	newTypesInto: theNewViewSubTypes
	elementMap: theElementMap newElementMapsInto: theNewElementMaps

	| someSourceSubTypes |

	theViewType isNil ifTrue: [ ^nil].
	theSourceType isNil ifTrue: [ ^nil].
	theModule isNil ifTrue: [ ^nil].
	theNewViewSubTypes isNil ifTrue: [ ^nil].

	someSourceSubTypes := theSourceType allSubtypes.
	(someSourceSubTypes isNil or: [ someSourceSubTypes isEmpty]) ifTrue: [ ^self].

	someSourceSubTypes do: [:aSourceSubType |  | aNewViewSubType aNewSubElementMap aNewSubMapLogic |
		(theViewType subTypes detect: [:aST | aST name = aSourceSubType name] ifNone: [ nil]) isNil ifTrue: [ 

			theSourceSubTypes add: aSourceSubType.

			aNewViewSubType := self preferredTypeClass new.
			aNewViewSubType name: aSourceSubType name copy.
			aNewViewSubType isAbstract: aSourceSubType isAbstract == true.
			aNewViewSubType isEnumeration: aSourceSubType isEnumeration == true.
			aNewViewSubType isPrimitive: aSourceSubType isPrimitive == true.

			theModule typesAdd: aNewViewSubType.
			theViewType subTypesAdd: aNewViewSubType.

			theNewViewSubTypes add: aNewViewSubType.


			aNewSubElementMap := self preferredElementMapClass new.
			aNewSubElementMap name: aSourceSubType name copy.
			aNewSubElementMap sourceElementsAdd: aSourceSubType.
			aNewSubElementMap viewElementsAdd: aNewViewSubType.

			theElementMap subElementMapsAdd: aNewSubElementMap.

			aNewSubMapLogic := self preferredMapLogicClass new.
			aNewSubMapLogic name: aNewSubMapLogic class mapModeTypeSymbol asString.
			aNewSubMapLogic mapMode: aNewSubMapLogic class mapModeTypeSymbol.

			aNewSubElementMap mapLogic: aNewSubMapLogic.

			theNewElementMaps add: aNewSubElementMap

		]
	].!

createSubTypesForViewType: theViewType sourceType: theSourceType module: theModule
	sourceTypesInto: theSourceSubTypes 	newTypesInto: theNewViewSubTypes
	elementMap: theElementMap newElementMapsInto: theNewElementMaps

	 (Dialog  confirm: 'Do you want to map the SubTypes  ?' initialAnswer: true) ifFalse: [ ^self].
	
	 ^(Dialog  confirm:  'Do you want to flatten the SubTypes hierarchy ?' initialAnswer: false) 
		ifTrue: [
			self createSubTypesFlatForViewType: theViewType sourceType: theSourceType module: theModule
				sourceTypesInto: theSourceSubTypes 	newTypesInto: theNewViewSubTypes
				elementMap: theElementMap newElementMapsInto: theNewElementMaps  
		]
		ifFalse: [
			self createSubTypesTreeForViewType: theViewType sourceType: theSourceType module: theModule
				sourceTypesInto: theSourceSubTypes 	newTypesInto: theNewViewSubTypes
				elementMap: theElementMap newElementMapsInto: theNewElementMaps  
		]!

createSubTypesTreeForViewType: theViewType sourceType: theSourceType module: theModule
	sourceTypesInto: theSourceSubTypes 	newTypesInto: theNewViewSubTypes
	elementMap: theElementMap newElementMapsInto: theNewElementMaps

	| someSourceSubTypes |

	theViewType isNil ifTrue: [ ^nil].
	theSourceType isNil ifTrue: [ ^nil].
	theModule isNil ifTrue: [ ^nil].
	theNewViewSubTypes isNil ifTrue: [ ^nil].

	someSourceSubTypes := theSourceType subTypes.
	(someSourceSubTypes isNil or: [ someSourceSubTypes isEmpty]) ifTrue: [ ^self].

	someSourceSubTypes do: [:aSourceSubType |  | aNewViewSubType aNewSubElementMap aNewSubMapLogic |
		(theViewType subTypes detect: [:aST | aST name = aSourceSubType name] ifNone: [ nil]) isNil ifTrue: [ 

			theSourceSubTypes add: aSourceSubType.

			aNewViewSubType := self preferredTypeClass new.
			aNewViewSubType name: aSourceSubType name copy.
			aNewViewSubType isAbstract: aSourceSubType isAbstract == true.
			aNewViewSubType isEnumeration: aSourceSubType isEnumeration == true.
			aNewViewSubType isPrimitive: aSourceSubType isPrimitive == true.

			theModule typesAdd: aNewViewSubType.
			theViewType subTypesAdd: aNewViewSubType.

			theNewViewSubTypes add: aNewViewSubType.


			aNewSubElementMap := self preferredElementMapClass new.
			aNewSubElementMap name: aSourceSubType name copy.
			aNewSubElementMap sourceElementsAdd: aSourceSubType.
			aNewSubElementMap viewElementsAdd: aNewViewSubType.

			theElementMap subElementMapsAdd: aNewSubElementMap.

			aNewSubMapLogic := self preferredMapLogicClass new.
			aNewSubMapLogic name: aNewSubMapLogic class mapModeTypeSymbol asString.
			aNewSubMapLogic mapMode: aNewSubMapLogic class mapModeTypeSymbol.

			aNewSubElementMap mapLogic: aNewSubMapLogic.

			theNewElementMaps add: aNewSubElementMap.

			self createSubTypesTreeForViewType: aNewViewSubType sourceType: aSourceSubType module: theModule
				sourceTypesInto: theSourceSubTypes 	newTypesInto: theNewViewSubTypes
				elementMap: theElementMap newElementMapsInto: theNewElementMaps

		]
	].!

mapAttributeNewSharedRelatedSourceType:  theSourceRelatedType 
"Create a new Type for relatedType of the mapped view Attribute,
	  available for reference in the whole model (i.e., not just for the mapped view attribute)
	
	1 - Find or create View Module (or root Model) into which to create the new View Type,
		with same fullyQualifed path that the SourceType. (create intermediate modules if needed)
	2 - Create new View Type 
	3 - Add the new Type to the found or created View Module (or root Model)
	4 - Link view Attribute valueType to the new View Type
	7 - If new View Modules were created, create MapsFolders with corresponding fully qualified names.
	8 - Create new ElementMap with sourceType and new View Type,
		inside the  MapsFolder with  fullyQualified name corresponding to the new View Type Module
	10 - if new View Modules were created, create NLS for the ViewModules using the ItemTranslations 
  		of the corresponding source Modules
	11 - Create NLS for the new View Type, using ItemTranslations of the Source Type
	13 - If new View Modules were created, create NLS for the corresponding MapsFolders,
		using the ItemTranslations of the corresponding   View Modules 
	14 - Create NLS for the new ElementMap of the new View Type
"

	| aMap aViewAttribute aSourceAttributeInverse aViewModel aSourceModule someNewViewModules aModuleForNewViewType aNewViewRelatedType aNewModuleMapsFolder someNewMapsFolders aNewTypeElementMap aNewTypeMapLogic |

	theSourceRelatedType 		isNil ifTrue: [ ^nil].

	aViewAttribute := self viewAttribute.
	aViewAttribute isNil ifTrue: [ ^nil].

	aSourceAttributeInverse := self sourceAttributeInverse.
	aSourceAttributeInverse isNil ifTrue: [ ^nil].


"We'll deal with re-defining other day ...."
	aViewAttribute inverse isNil ifFalse: [
		Dialog warn: 'View attribute ', aViewAttribute name, ' already has an Inverse : must have already been mapped'.
		^nil
	].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].


"	1 - Find or create View Module (or root Model) into which to create the new View Type,
		with same fullyQualifed path that the Source Type (create intermediate modules if needed)
"
	aSourceModule := theSourceRelatedType module.
	someNewViewModules := OrderedCollection new: 8.
	aModuleForNewViewType := aSourceModule isNil 
		ifTrue: [ aViewModel ]
		ifFalse: [ aViewModel newOrExistingModuleNamedArray: aSourceModule fullyQualifiedNameArray  newModulesInto: someNewViewModules].

	aModuleForNewViewType isNil ifTrue: [ aModuleForNewViewType := aViewModel].


"	2 - Create new View Type 
"
	aNewViewRelatedType := self preferredTypeClass new.
	aNewViewRelatedType name: theSourceRelatedType name copy.
	aNewViewRelatedType isAbstract: theSourceRelatedType isAbstract == true.
	aNewViewRelatedType isEnumeration: theSourceRelatedType isEnumeration == true.
	aNewViewRelatedType isPrimitive: theSourceRelatedType isPrimitive == true.


"	3 - Add the new Type to the found or created View Module (or root Model)
"
	aModuleForNewViewType typesAdd: aNewViewRelatedType.


"	4 - Link view Attribute relatedType to the new View Type
"
	aViewAttribute valueType: aNewViewRelatedType.


"	7 - If new View Modules were created, create MapsFolders with corresponding fully qualified names.
"
	aNewModuleMapsFolder := nil.
	(aModuleForNewViewType isNil not and: [ aModuleForNewViewType isModel not]) ifTrue: [ 
		someNewMapsFolders := OrderedCollection new: 8.
		aNewModuleMapsFolder := aMap newOrExistingModuleNamedArray: aModuleForNewViewType fullyQualifiedNameArray 
			newModulesInto: someNewMapsFolders
	].
	aNewModuleMapsFolder isNil ifTrue: [ aNewModuleMapsFolder := aMap].


"	8 - Create new ElementMap with sourceType and new View Type,
		inside the  MapsFolder with  fullyQualified name corresponding to the new View Type Module
"
	aNewTypeElementMap := self preferredElementMapClass new.
	aNewTypeElementMap name: theSourceRelatedType name copy.
	aNewTypeElementMap sourceElementsAdd: theSourceRelatedType.
	aNewTypeElementMap viewElementsAdd: aNewViewRelatedType.
	aNewTypeMapLogic := self preferredMapLogicClass new.
	aNewTypeMapLogic name: aNewTypeMapLogic class mapModeTypeSymbol asString.
	aNewTypeMapLogic mapMode: aNewTypeMapLogic class mapModeTypeSymbol.
	aNewTypeElementMap mapLogic: aNewTypeMapLogic.

	aNewModuleMapsFolder elementMapsAdd: aNewTypeElementMap.


"	10 - if new View Modules were created, create NLS for the ViewModules using the ItemTranslations 
  		of the corresponding source Modules
"
	(someNewViewModules isNil not and: [ someNewViewModules isEmpty not]) ifTrue: [ 
		self createNLSForViewModules: someNewViewModules
	].


"	11 - Create NLS for the new View Type, using ItemTranslations of the Source Type
"
	self createNLSForViewType: aNewViewRelatedType  sourceType: theSourceRelatedType.


"	13 - If new MapsFolders were created for new View Modules , 
		create NLS for the  MapsFolders,
		using the ItemTranslations of the corresponding   View Modules 
"
	(someNewMapsFolders isNil not and: [ someNewMapsFolders isEmpty not]) ifTrue: [ 
		self createNLSForMapsFolders: someNewMapsFolders
	].


"	14 - Create NLS for the new ElementMap of the new View Type
"
	self createNLSForElementMap: aNewTypeElementMap  viewType: aNewViewRelatedType.



	aNewViewRelatedType  changed: #name.

	(someNewViewModules isNil not and: [ someNewViewModules isEmpty not]) ifTrue: [ 
		someNewViewModules do: [:aMF | aMF changed: #Name]
	].

	aNewTypeElementMap changed: #name.
	
	(someNewMapsFolders isNil not and: [ someNewMapsFolders isEmpty not]) ifTrue: [ 
		someNewMapsFolders do: [:aMF | aMF changed: #Name]
	]!

mapAttributeWithExistingViewType:  theExistingViewType 
"Exists a View Type for relatedType of the mapped view Attribute
	
	1 - Link view Attribute valueType to existing View Type
"

	| aMap aViewAttribute |

	theExistingViewType 		isNil ifTrue: [ ^nil].

	aViewAttribute := self viewAttribute.
	aViewAttribute isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].


"	1 - Link view Attribute relatedType to existing View Type
"
	aViewAttribute valueType: theExistingViewType.!

mapAttributeWithNewAttributeSpecificSourceRelatedType: theSourceRelatedType

"The  relatedType of the mapped view Attribute will be a new View Type, used solely by this attribute,
 	the new View Type created in a module used solely by the attribute.
	
	1 - Find or create a View module to be used solely by the attribute
	2 - Create a new View Type to be used solely by the attribute
	3 - Add the new Type to the found or created View Module to be used solely by the attribute
	4 - Link view Attribute valueType to the new View Type
 	7 - Create new view SubTypes in the view module to be used solely by the attribute,
		for each of the source related  Type SubTypes
	     create ElementMaps for each SubTye,
		as subMaps of the Attribute elementMap
	8 - Create new ElementMap with sourceType and new View Type,
			as subElementMap of this elementMap
	10 - If new View module to be used solely by the attribute was created, 
		create NLS for the ViewModules using as Arguments the ItemTranslation of the Attribute
		(someting like 'Module for Attribute %1')
	11 - Create NLS for the new View Type, using ItemTranslations of the Source Type
	13 - Create NLS for the new ElementMap of the new View Type
	15 - If view Subtypes were created, create a NLS  items for each SubType 
			using the ItemTranslation of the Souce SubType
	16 - If view Subtypes were created, create a NLS  items for the ElementMap of
			each SubType  using the ItemTranslation of the corresponding View SubType
"

	| aParentViewModule aNewViewRelatedType aNewMapLogic aViewAttribute aModuleName aMap aFeatureSpecificViewModule aFeatureSpecificViewModuleWasCreated someNewViewSubTypes aNewTypeElementMap someSubTypeElementMaps someSourceSubTypes |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewAttribute := self viewAttribute.
	aViewAttribute isNil ifTrue: [ ^nil].


"	1 - Find or create a View module to be used solely by the attribute
"
	aParentViewModule := aViewAttribute type module.
	aParentViewModule isNil ifTrue: [ ^nil].

	aModuleName := self attributeSpecificModuleNameFor: aViewAttribute.
	aModuleName isNil ifTrue: [ ^nil].

	aFeatureSpecificViewModule := aParentViewModule subModuleNamed: aModuleName.
	aFeatureSpecificViewModuleWasCreated := false.
	aFeatureSpecificViewModule isNil ifTrue: [ 
		aFeatureSpecificViewModuleWasCreated := true.
		aFeatureSpecificViewModule := self preferredViewModuleClass new.
		aFeatureSpecificViewModule name: aModuleName.
		aParentViewModule subModulesAdd: aFeatureSpecificViewModule
	].
	

"	2 - Create a new View Type in the view module to be used solely by the attribute
"
	aNewViewRelatedType := self preferredTypeClass new.
	aNewViewRelatedType name: theSourceRelatedType name copy.
	aNewViewRelatedType isAbstract: theSourceRelatedType isAbstract == true.
	aNewViewRelatedType isEnumeration: theSourceRelatedType isEnumeration == true.
	aNewViewRelatedType isPrimitive: theSourceRelatedType isPrimitive == true.

"	3 - Add the new Type to the found or created View Module to be used solely by the attribute
"
	aFeatureSpecificViewModule typesAdd: aNewViewRelatedType.


"	4 - Link view Attribute relatedType to the new View Type
"
	aViewAttribute valueType: aNewViewRelatedType.


"	7 - Create new view SubTypes in the view module to be used solely by the attribute,
		for each of the source related  Type SubTypes
		create ElementMaps for each SubTye, as subMaps of the Attribute elementMap
"
	someSourceSubTypes := OrderedCollection new: 3.
	someNewViewSubTypes := OrderedCollection new: 3.
	someSubTypeElementMaps := OrderedCollection new: 3.
	self createSubTypesForViewType: aNewViewRelatedType sourceType: theSourceRelatedType
		module: aFeatureSpecificViewModule 
		sourceTypesInto: someSourceSubTypes newTypesInto: someNewViewSubTypes
		elementMap: self newElementMapsInto: someSubTypeElementMaps.


"	8 - Create new ElementMap with sourceType and new View Type,
			as subElementMap of this elementMap
"
	aNewTypeElementMap := self preferredElementMapClass new.
	aNewTypeElementMap name: theSourceRelatedType name copy.
	aNewTypeElementMap sourceElementsAdd: theSourceRelatedType.
	aNewTypeElementMap viewElementsAdd: aNewViewRelatedType.

	aNewMapLogic := self preferredMapLogicClass new.
	aNewMapLogic name: aNewMapLogic class mapModeTypeSymbol asString.
	aNewMapLogic mapMode: aNewMapLogic class mapModeTypeSymbol.
	aNewTypeElementMap mapLogic: aNewMapLogic.
	
	self subElementMapsAdd: aNewTypeElementMap.



"	10 - If new View module to be used solely by the attribute was created, 
		create NLS for the ViewModules using as Arguments the ItemTranslation of the Attribute
		(someting like 'Module for Attribute %1')
"
	self createNLSForViewModule: aFeatureSpecificViewModule  viewAttribute: aViewAttribute.


"	11 - Create NLS for the new View Type, using ItemTranslations of the Source Type
"
	self createNLSForViewType: aNewViewRelatedType  sourceType: theSourceRelatedType.



"	13 - Create NLS for the new ElementMap of the new View Type
"
	self createNLSForElementMap: aNewTypeElementMap  viewType: aNewViewRelatedType.




"	15 - If view Subtypes were created, create a NLS  items for each SubType 
			using the ItemTranslation of the Souce SubType
"
	1 to: someNewViewSubTypes size do: [:anIndex |  |  aViewSubType aSourceSubType  | 
		aSourceSubType := someSourceSubTypes at: anIndex.
		aViewSubType := someNewViewSubTypes at: anIndex.
		(aSourceSubType isNil not and: [ aViewSubType isNil not]) ifTrue: [ 
			self createNLSForViewType: aViewSubType  sourceType: aSourceSubType
		]
	]. 




"	16 - If view Subtypes were created, create a NLS  items for the ElementMap of
			each SubType  using the ItemTranslation of the corresponding View SubType
"
	1 to: someNewViewSubTypes size do: [:anIndex |  |  aViewSubType aSubTypeElementMap  | 
		aViewSubType := someNewViewSubTypes at: anIndex.
		aSubTypeElementMap := someSubTypeElementMaps at: anIndex.
		(aViewSubType isNil not and: [ aSubTypeElementMap isNil not]) ifTrue: [ 
			self createNLSForElementMap: aSubTypeElementMap  viewType: aViewSubType
		]
	]. 




	aNewViewRelatedType  changed: #name.

	(aFeatureSpecificViewModuleWasCreated and: [ aFeatureSpecificViewModule isNil not]) ifTrue: [
		aFeatureSpecificViewModule changed: #name
	].

	aNewTypeElementMap changed: #name.

	someNewViewSubTypes do: [:aSubType | aSubType changed: #name].
	someSubTypeElementMaps do: [:aSubEM | aSubEM changed: #name].!

mapRelationshipNewSharedRelatedSourceType:  theSourceRelatedType 
"Create a new Type for relatedType of the mapped view Relationship,
	  available for reference in the whole model (i.e., not just for the mapped view relationship)
	
	1 - Find or create View Module (or root Model) into which to create the new View Type,
		with same fullyQualifed path that the SourceType. (create intermediate modules if needed)
	2 - Create new View Type 
	3 - Add the new Type to the found or created View Module (or root Model)
	4 - Link view Relationship relatedType to the new View Type
	5 - Create a new view Relationship as inverse of mapped view Relationship,
 	6 - Link the new view inverse Relationship to new view Type,  to the view Relationship and to view Relationship type
	7 - If new View Modules were created, create MapsFolders with corresponding fully qualified names.
	8 - Create new ElementMap with sourceType and new View Type,
		inside the  MapsFolder with  fullyQualified name corresponding to the new View Type Module
	9 - Create new ElementMap for the new view Inverse Relationship and source Inverse Relationship
			as subElementMap of the ElementMap for the new View Type
	10 - if new View Modules were created, create NLS for the ViewModules using the ItemTranslations 
  		of the corresponding source Modules
	11 - Create NLS for the new View Type, using ItemTranslations of the Source Type
	12 - Create NLS (or two, if inverse relationship has multiplicity many) for the new view Inverse Relationship, 
		using ItemTranslations of the source InverseRelationship
	13 - If new View Modules were created, create NLS for the corresponding MapsFolders,
		using the ItemTranslations of the corresponding   View Modules 
	14 - Create NLS for the new ElementMap of the new View Type
	15 - Create NLS for the new ElementMap of the new View inverse Relationship
"

	| aNewViewInverseRelationship aNewInverseRelationshipSubElementMap aNewExistingViewTypeMapLogic aMap aViewRelationship aSourceRelationshipInverse aMapInverse aViewModel aSourceModule someNewViewModules aModuleForNewViewType aNewViewRelatedType aNewModuleMapsFolder someNewMapsFolders aNewTypeElementMap aNewTypeMapLogic |

	theSourceRelatedType 		isNil ifTrue: [ ^nil].

	aViewRelationship := self viewRelationship.
	aViewRelationship isNil ifTrue: [ ^nil].

	aSourceRelationshipInverse := self sourceRelationshipInverse.
	aSourceRelationshipInverse isNil ifTrue: [ ^nil].


"We'll deal with re-defining other day ...."
	aViewRelationship inverse isNil ifFalse: [
		Dialog warn: 'View relationship ', aViewRelationship name, ' already has an Inverse : must have already been mapped'.
		^nil
	].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].


"	1 - Find or create View Module (or root Model) into which to create the new View Type,
		with same fullyQualifed path that the Source Type (create intermediate modules if needed)
"
	aSourceModule := theSourceRelatedType module.
	someNewViewModules := OrderedCollection new: 8.
	aModuleForNewViewType := aSourceModule isNil 
		ifTrue: [ aViewModel ]
		ifFalse: [ aViewModel newOrExistingModuleNamedArray: aSourceModule fullyQualifiedNameArray  newModulesInto: someNewViewModules].

	aModuleForNewViewType isNil ifTrue: [ aModuleForNewViewType := aViewModel].


"	2 - Create new View Type 
"
	aNewViewRelatedType := self preferredTypeClass new.
	aNewViewRelatedType name: theSourceRelatedType name copy.
	aNewViewRelatedType isAbstract: theSourceRelatedType isAbstract == true.
	aNewViewRelatedType isEnumeration: theSourceRelatedType isEnumeration == true.
	aNewViewRelatedType isPrimitive: theSourceRelatedType isPrimitive == true.


"	3 - Add the new Type to the found or created View Module (or root Model)
"
	aModuleForNewViewType typesAdd: aNewViewRelatedType.


"	4 - Link view Relationship relatedType to the new View Type
"
	aViewRelationship relatedType: aNewViewRelatedType.

"	5 - Create a new view Relationship as inverse of mapped view Relationship,
"
	aNewViewInverseRelationship := self preferredRelationshipClass new.
	aNewViewInverseRelationship name: aSourceRelationshipInverse name copy.
	aNewViewInverseRelationship initTerminalMetaAttributesFrom: aSourceRelationshipInverse.


" 	6 - Link the new view inverse Relationship to new view Type,  to the view Relationship and to view Relationship type
"
	aNewViewRelatedType relationshipsAdd: aNewViewInverseRelationship.
	aNewViewInverseRelationship relatedType: aViewRelationship type.
	aViewRelationship inverse: aNewViewInverseRelationship.


"	7 - If new View Modules were created, create MapsFolders with corresponding fully qualified names.
"
	aNewModuleMapsFolder := nil.
	(aModuleForNewViewType isNil not and: [ aModuleForNewViewType isModel not]) ifTrue: [ 
		someNewMapsFolders := OrderedCollection new: 8.
		aNewModuleMapsFolder := aMap newOrExistingModuleNamedArray: aModuleForNewViewType fullyQualifiedNameArray 
			newModulesInto: someNewMapsFolders
	].
	aNewModuleMapsFolder isNil ifTrue: [ aNewModuleMapsFolder := aMap].


"	8 - Create new ElementMap with sourceType and new View Type,
		inside the  MapsFolder with  fullyQualified name corresponding to the new View Type Module
"
	aNewTypeElementMap := self preferredElementMapClass new.
	aNewTypeElementMap name: theSourceRelatedType name copy.
	aNewTypeElementMap sourceElementsAdd: theSourceRelatedType.
	aNewTypeElementMap viewElementsAdd: aNewViewRelatedType.
	aNewTypeMapLogic := self preferredMapLogicClass new.
	aNewTypeMapLogic name: aNewTypeMapLogic class mapModeTypeSymbol asString.
	aNewTypeMapLogic mapMode: aNewTypeMapLogic class mapModeTypeSymbol.
	aNewTypeElementMap mapLogic: aNewTypeMapLogic.

	aNewModuleMapsFolder elementMapsAdd: aNewTypeElementMap.


"	9 - Create new ElementMap for the new view Inverse Relationship and source Inverse Relationship
			as subElementMap of the ElementMap for the new View Type
"
	aMapInverse := Dialog confirm: 'Do you also want to map the inverse relationship\' withCRs, 
		aSourceRelationshipInverse name initialAnswer: false.

	aNewInverseRelationshipSubElementMap := self preferredElementMapClass new.
	aNewInverseRelationshipSubElementMap name: 
			(aMapInverse ifTrue: [ ''] ifFalse: [ 'voidmap_']) , aSourceRelationshipInverse name.
	aNewInverseRelationshipSubElementMap sourceElementsAdd: aSourceRelationshipInverse.
	aNewInverseRelationshipSubElementMap viewElementsAdd: aNewViewInverseRelationship.
	aNewExistingViewTypeMapLogic := self preferredMapLogicClass new.
	aNewExistingViewTypeMapLogic name: aNewExistingViewTypeMapLogic class mapModeRelationshipSymbol asString.
	aNewExistingViewTypeMapLogic mapMode: 
		(aMapInverse
			ifTrue: [ aNewExistingViewTypeMapLogic class mapModeRelationshipSymbol]
			ifFalse: [ aNewExistingViewTypeMapLogic class mapModeVoidRelationshipSymbol]).
	aNewInverseRelationshipSubElementMap mapLogic: aNewExistingViewTypeMapLogic.

	aNewTypeElementMap  subElementMapsAdd: aNewInverseRelationshipSubElementMap.


"	10 - if new View Modules were created, create NLS for the ViewModules using the ItemTranslations 
  		of the corresponding source Modules
"
	(someNewViewModules isNil not and: [ someNewViewModules isEmpty not]) ifTrue: [ 
		self createNLSForViewModules: someNewViewModules
	].


"	11 - Create NLS for the new View Type, using ItemTranslations of the Source Type
"
	self createNLSForViewType: aNewViewRelatedType  sourceType: theSourceRelatedType.


"	12 - Create NLS (or two, if inverse relationship has multiplicity many) for the new view Inverse Relationship, 
		using ItemTranslations of the source InverseRelationship
"
	self createNLSForViewInverseRelationship: aNewViewInverseRelationship  sourceInverseRelationship: aSourceRelationshipInverse.


"	13 - If new MapsFolders were created for new View Modules , 
		create NLS for the  MapsFolders,
		using the ItemTranslations of the corresponding   View Modules 
"
	(someNewMapsFolders isNil not and: [ someNewMapsFolders isEmpty not]) ifTrue: [ 
		self createNLSForMapsFolders: someNewMapsFolders
	].


"	14 - Create NLS for the new ElementMap of the new View Type
"
	self createNLSForElementMap: aNewTypeElementMap  viewType: aNewViewRelatedType.


"	15 - Create NLS for the new ElementMap of the new View inverse Relationship
"
	self createNLSForViewInverseRelationship: aNewViewInverseRelationship elementMap: aNewInverseRelationshipSubElementMap.

	aNewViewRelatedType  changed: #name.
	aNewViewInverseRelationship  changed: #name.

	(someNewViewModules isNil not and: [ someNewViewModules isEmpty not]) ifTrue: [ 
		someNewViewModules do: [:aMF | aMF changed: #Name]
	].

	aNewTypeElementMap changed: #name.
	aNewInverseRelationshipSubElementMap changed: #name.
	
	(someNewMapsFolders isNil not and: [ someNewMapsFolders isEmpty not]) ifTrue: [ 
		someNewMapsFolders do: [:aMF | aMF changed: #Name]
	]!

mapRelationshipWithExistingViewType:  theExistingViewType 
"Exists a View Type for relatedType of the mapped view Relationship
	
	1 - Link view Relationship relatedType to existing View Type
	2 - Create a new view Relationship as inverse of mapped view Relationship, 
			link it to existing relatedType view Type, to mapped view Relationship,
			and to mapped view Relationship type
	3 - Create an ElementMap for the new inverse Relationship, and the source inverse relationship
			as subElementMap of the Map's elementMap that has the existing relatedType view Type
	4 - Create a NLS  item (or two, if inverse relationship has multiplicity many) for the inverse Relationship
	5 - Create a NLS for the new inverse relationship ElementMap, in the Map's translation,
		using the NLS for the view inverse relationship
"

	| aNewViewInverseRelationship aNewInverseRelationshipSubElementMap aNewExistingViewTypeMapLogic aMap aViewRelationship aSourceRelationshipInverse aMapInverse anExistingElementMap |

	theExistingViewType 		isNil ifTrue: [ ^nil].

	aViewRelationship := self viewRelationship.
	aViewRelationship isNil ifTrue: [ ^nil].

	aSourceRelationshipInverse := self sourceRelationshipInverse.
	aSourceRelationshipInverse isNil ifTrue: [ ^nil].


"We'll deal with re-defining other day ...."
	aViewRelationship inverse isNil ifFalse: [
		Dialog warn: 'View relationship ', aViewRelationship name, ' already has an Inverse : must have already been mapped'.
		^nil
	].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].


"	1 - Link view Relationship relatedType to existing View Type
"
	aViewRelationship relatedType: theExistingViewType.


"	2 - Create a new view Relationship as inverse of mapped view Relationship, 
			link it to existing relatedType view Type, and to mapped view Relationship
"
	aNewViewInverseRelationship := self preferredRelationshipClass new.
	aNewViewInverseRelationship name: aSourceRelationshipInverse name copy.
	aNewViewInverseRelationship initTerminalMetaAttributesFrom: aSourceRelationshipInverse.

	theExistingViewType relationshipsAdd: aNewViewInverseRelationship.
	aNewViewInverseRelationship relatedType: aViewRelationship type.
	aViewRelationship inverse: aNewViewInverseRelationship.
	

"	3 - Create an ElementMap for the new inverse Relationship, and the source inverse relationship
			as subElementMap of the Map's elementMap that has the existing relatedType view Type
"
	aMapInverse := Dialog confirm: 'Do you also want to map the inverse relationship\' withCRs, 
		aSourceRelationshipInverse name initialAnswer: false.

	aNewInverseRelationshipSubElementMap := self preferredElementMapClass new.
	aNewInverseRelationshipSubElementMap name: 
			(aMapInverse ifTrue: [ ''] ifFalse: [ 'voidmap_']) , aSourceRelationshipInverse name.
	aNewInverseRelationshipSubElementMap sourceElementsAdd: aSourceRelationshipInverse.
	aNewInverseRelationshipSubElementMap viewElementsAdd: aNewViewInverseRelationship.
	aNewExistingViewTypeMapLogic := self preferredMapLogicClass new.
	aNewExistingViewTypeMapLogic name: aNewExistingViewTypeMapLogic class mapModeRelationshipSymbol asString.
	aNewExistingViewTypeMapLogic mapMode: 
		(aMapInverse
			ifTrue: [ aNewExistingViewTypeMapLogic class mapModeRelationshipSymbol]
			ifFalse: [ aNewExistingViewTypeMapLogic class mapModeVoidRelationshipSymbol]).
	aNewInverseRelationshipSubElementMap mapLogic: aNewExistingViewTypeMapLogic.

	anExistingElementMap := self preferredMapClass scanMapsFolder: aMap forElementMapWithViewMetaInfo: theExistingViewType.
	anExistingElementMap isNil ifFalse: [ 
		anExistingElementMap  subElementMapsAdd: aNewInverseRelationshipSubElementMap.
	].


"	4 - Create a NLS  item (or two, if inverse relationship has multiplicity many) for the inverse Relationship
"
	self createNLSForViewInverseRelationship: aNewViewInverseRelationship  sourceInverseRelationship: aSourceRelationshipInverse.



"	5 - Create a NLS for the new inverse relationship ElementMap, in the Map's translation,
		using the NLS for the view inverse relationship
"
	self createNLSForViewInverseRelationship: aNewViewInverseRelationship elementMap: aNewInverseRelationshipSubElementMap.

	aNewInverseRelationshipSubElementMap changed: #name.
	aNewViewInverseRelationship  changed: #name.!

mapRelationshipWithNewRelationshipSpecificSourceRelatedType: theSourceRelatedType

"The  relatedType of the mapped view Relationship will be a new View Type, used solely by this relationship,
 	the new View Type created in a module used solely by the relationship.
	
	1 - Find or create a View module to be used solely by the relationship
	2 - Create a new View Type to be used solely by the relationship
	3 - Add the new Type to the found or created View Module to be used solely by the relationship
	4 - Link view Relationship relatedType to the new View Type
	5 - Create a new view Relationship as inverse of mapped view Relationship,
 	6 - Link the new view inverse Relationship to new view Type,  to the view Relationship and to view Relationship type
	7 - Create new view SubTypes in the view module to be used solely by the relationship,
		for each of the source related  Type SubTypes
	     create ElementMaps for each SubTye,
		as subMaps of the Relationship elementMap
NO	  - If new View module to be used solely by the relationship was created, 
			create MapsFolders with corresponding fully qualified names.
	8 - Create new ElementMap with sourceType and new View Type,
			as subElementMap of this elementMap
	9 - Create new ElementMap for the new view Inverse Relationship and source Inverse Relationship
			as subElementMap of the ElementMap for the new View Type
	10 - If new View module to be used solely by the relationship was created, 
		create NLS for the ViewModules using as Arguments the ItemTranslation of the Relationship
		(someting like 'Module for Attribute %1')
	11 - Create NLS for the new View Type, using ItemTranslations of the Source Type
	12 - Create NLS (or two, if inverse relationship has multiplicity many) for the new view Inverse Relationship, 
		using ItemTranslations of the source InverseRelationship
NO  - If new View module to be used solely by the relationship was created, 
		create NLS for the corresponding MapsFolder,
		using the ItemTranslations of the corresponding   View Module 
	13 - Create NLS for the new ElementMap of the new View Type
	14 - Create NLS for the new ElementMap of the new View inverse Relationship
	15 - If view Subtypes were created, create a NLS  items for each SubType 
			using the ItemTranslation of the Souce SubType
	16 - If view Subtypes were created, create a NLS  items for the ElementMap of
			each SubType  using the ItemTranslation of the corresponding View SubType
"

	| aParentViewModule aNewViewRelatedType aNewMapLogic aViewRelationship aSourceRelationshipInverse aModuleName aNewViewInverseRelationship aMapInverse aNewInverseRelationshipSubElementMap aNewExistingViewTypeMapLogic aMap aFeatureSpecificViewModule aFeatureSpecificViewModuleWasCreated someNewViewSubTypes aNewTypeElementMap someSubTypeElementMaps someSourceSubTypes |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewRelationship := self viewRelationship.
	aViewRelationship isNil ifTrue: [ ^nil].

	aSourceRelationshipInverse := self sourceRelationshipInverse.
	aSourceRelationshipInverse isNil ifTrue: [ ^nil].


"	1 - Find or create a View module to be used solely by the relationship
"
	aParentViewModule := aViewRelationship type module.
	aParentViewModule isNil ifTrue: [ ^nil].

	aModuleName := self relationshipSpecificModuleNameFor: aViewRelationship.
	aModuleName isNil ifTrue: [ ^nil].

	aFeatureSpecificViewModule := aParentViewModule subModuleNamed: aModuleName.
	aFeatureSpecificViewModuleWasCreated := false.
	aFeatureSpecificViewModule isNil ifTrue: [ 
		aFeatureSpecificViewModuleWasCreated := true.
		aFeatureSpecificViewModule := self preferredViewModuleClass new.
		aFeatureSpecificViewModule name: aModuleName.
		aParentViewModule subModulesAdd: aFeatureSpecificViewModule
	].
	

"	2 - Create a new View Type in the view module to be used solely by the relationship
"
	aNewViewRelatedType := self preferredTypeClass new.
	aNewViewRelatedType name: theSourceRelatedType name copy.
	aNewViewRelatedType isAbstract: theSourceRelatedType isAbstract == true.
	aNewViewRelatedType isEnumeration: theSourceRelatedType isEnumeration == true.
	aNewViewRelatedType isPrimitive: theSourceRelatedType isPrimitive == true.

"	3 - Add the new Type to the found or created View Module to be used solely by the relationship
"
	aFeatureSpecificViewModule typesAdd: aNewViewRelatedType.


"	4 - Link view Relationship relatedType to the new View Type
"
	aViewRelationship relatedType: aNewViewRelatedType.


"	5 - Create a new view Relationship as inverse of mapped view Relationship,
"
	aNewViewInverseRelationship := self preferredRelationshipClass new.
	aNewViewInverseRelationship name: aSourceRelationshipInverse name copy.
	aNewViewInverseRelationship initTerminalMetaAttributesFrom: aSourceRelationshipInverse.

" 	6 - Link the new view inverse Relationship to new view Type,  to the view Relationship and to view Relationship type
"
	aNewViewRelatedType relationshipsAdd: aNewViewInverseRelationship.
	aNewViewInverseRelationship relatedType: aViewRelationship type.
	aViewRelationship inverse: aNewViewInverseRelationship.

"	7 - Create new view SubTypes in the view module to be used solely by the relationship,
		for each of the source related  Type SubTypes
		create ElementMaps for each SubTye, as subMaps of the Relationship elementMap
"
	someSourceSubTypes := OrderedCollection new: 3.
	someNewViewSubTypes := OrderedCollection new: 3.
	someSubTypeElementMaps := OrderedCollection new: 3.
	self createSubTypesForViewType: aNewViewRelatedType sourceType: theSourceRelatedType
		module: aFeatureSpecificViewModule 
		sourceTypesInto: someSourceSubTypes newTypesInto: someNewViewSubTypes
		elementMap: self newElementMapsInto: someSubTypeElementMaps.


"	8 - Create new ElementMap with sourceType and new View Type,
			as subElementMap of this elementMap
"
	aNewTypeElementMap := self preferredElementMapClass new.
	aNewTypeElementMap name: theSourceRelatedType name copy.
	aNewTypeElementMap sourceElementsAdd: theSourceRelatedType.
	aNewTypeElementMap viewElementsAdd: aNewViewRelatedType.

	aNewMapLogic := self preferredMapLogicClass new.
	aNewMapLogic name: aNewMapLogic class mapModeTypeSymbol asString.
	aNewMapLogic mapMode: aNewMapLogic class mapModeTypeSymbol.
	aNewTypeElementMap mapLogic: aNewMapLogic.
	
	self subElementMapsAdd: aNewTypeElementMap.


"	9 - Create new ElementMap for the new view Inverse Relationship and source Inverse Relationship
			as subElementMap of the ElementMap for the new View Type
"
	aMapInverse := Dialog confirm: 'Do you also want to map the inverse relationship\' withCRs, 
		aSourceRelationshipInverse name initialAnswer: false.

	aNewInverseRelationshipSubElementMap := self preferredElementMapClass new.
	aNewInverseRelationshipSubElementMap name: 
			(aMapInverse ifTrue: [ ''] ifFalse: [ 'voidmap_']) , aSourceRelationshipInverse name.
	aNewInverseRelationshipSubElementMap sourceElementsAdd: aSourceRelationshipInverse.
	aNewInverseRelationshipSubElementMap viewElementsAdd: aNewViewInverseRelationship.
	aNewExistingViewTypeMapLogic := self preferredMapLogicClass new.
	aNewExistingViewTypeMapLogic name: aNewExistingViewTypeMapLogic class mapModeRelationshipSymbol asString.
	aNewExistingViewTypeMapLogic mapMode: 
		(aMapInverse
			ifTrue: [ aNewExistingViewTypeMapLogic class mapModeRelationshipSymbol]
			ifFalse: [ aNewExistingViewTypeMapLogic class mapModeVoidRelationshipSymbol]).
	aNewInverseRelationshipSubElementMap mapLogic: aNewExistingViewTypeMapLogic.

	aNewTypeElementMap  subElementMapsAdd: aNewInverseRelationshipSubElementMap.




"	10 - If new View module to be used solely by the relationship was created, 
		create NLS for the ViewModules using as Arguments the ItemTranslation of the Relationship
		(someting like 'Module for Relationship %1')
"
	self createNLSForViewModule: aFeatureSpecificViewModule  viewRelationship: aViewRelationship.


"	11 - Create NLS for the new View Type, using ItemTranslations of the Source Type
"
	self createNLSForViewType: aNewViewRelatedType  sourceType: theSourceRelatedType.


"	12 - Create NLS (or two, if inverse relationship has multiplicity many) for the new view Inverse Relationship, 
		using ItemTranslations of the source InverseRelationship
"
	self createNLSForViewInverseRelationship: aNewViewInverseRelationship  sourceInverseRelationship: aSourceRelationshipInverse.


"	13 - Create NLS for the new ElementMap of the new View Type
"
	self createNLSForElementMap: aNewTypeElementMap  viewType: aNewViewRelatedType.


"	14 - Create NLS for the new ElementMap of the new View inverse Relationship
"
	self createNLSForViewInverseRelationship: aNewViewInverseRelationship elementMap: aNewInverseRelationshipSubElementMap.


"	15 - If view Subtypes were created, create a NLS  items for each SubType 
			using the ItemTranslation of the Souce SubType
"
	1 to: someNewViewSubTypes size do: [:anIndex |  |  aViewSubType aSourceSubType  | 
		aSourceSubType := someSourceSubTypes at: anIndex.
		aViewSubType := someNewViewSubTypes at: anIndex.
		(aSourceSubType isNil not and: [ aViewSubType isNil not]) ifTrue: [ 
			self createNLSForViewType: aViewSubType  sourceType: aSourceSubType
		]
	]. 




"	16 - If view Subtypes were created, create a NLS  items for the ElementMap of
			each SubType  using the ItemTranslation of the corresponding View SubType
"
	1 to: someNewViewSubTypes size do: [:anIndex |  |  aViewSubType aSubTypeElementMap  | 
		aViewSubType := someNewViewSubTypes at: anIndex.
		aSubTypeElementMap := someSubTypeElementMaps at: anIndex.
		(aViewSubType isNil not and: [ aSubTypeElementMap isNil not]) ifTrue: [ 
			self createNLSForElementMap: aSubTypeElementMap  viewType: aViewSubType
		]
	]. 




	aNewViewRelatedType  changed: #name.
	aNewViewInverseRelationship  changed: #name.

	(aFeatureSpecificViewModuleWasCreated and: [ aFeatureSpecificViewModule isNil not]) ifTrue: [
		aFeatureSpecificViewModule changed: #name
	].

	aNewTypeElementMap changed: #name.
	aNewInverseRelationshipSubElementMap changed: #name.

	someNewViewSubTypes do: [:aSubType | aSubType changed: #name].
	someSubTypeElementMaps do: [:aSubEM | aSubEM changed: #name].!

relationshipSpecificModuleNameFor: theRelationship
	theRelationship isNil ifTrue: [ ^nil].

	^theRelationship type name, '_', theRelationship name, '_RelatedTypes_Module'!

semAttSelectedSourceType

	|  someCandidateRelatedTypes aSelectedRelatedType someCandidateRelatedTypeLabels someSortedRelatedTypes |

	someCandidateRelatedTypes := self semAttSourceModelCandidates.

	(someCandidateRelatedTypes isNil or: [ someCandidateRelatedTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not Source Types candidates as RelatedType Source for new ElementMap'.
		^self
	].

	someSortedRelatedTypes := someCandidateRelatedTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateRelatedTypeLabels := someSortedRelatedTypes collect: [:aRelatedType | 
		aRelatedType nlsName, ' 	(', aRelatedType name ,')' 
	].
	
	aSelectedRelatedType := Dialog 
		choose: ('Please, select a RelatedType as Source for new ElementMap') withCRs
		fromList: someCandidateRelatedTypeLabels 
		values: someSortedRelatedTypes 
		lines: (((someSortedRelatedTypes size + 1) max: 5) min: 18)
		cancel: [nil].

	^aSelectedRelatedType!

semAttSelectedViewTypeForSourceType: theSourceType

	|  someCandidateViewTypes aSelectedViewType someCandidateViewTypeLabels someSortedViewTypes |

	someCandidateViewTypes := self semAttViewTypeCandidatesForSourceType: theSourceType.

	(someCandidateViewTypes isNil or: [ someCandidateViewTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not existing View Types candidates as ViewType Source for new ElementMap'.
		^nil
	].

	someSortedViewTypes := someCandidateViewTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateViewTypeLabels := someSortedViewTypes collect: [:aViewType | 
		aViewType nlsName, ' 	(', aViewType name ,')' 
	].
	
	aSelectedViewType := Dialog 
		choose: ('Please, select an existing ViewType for new ElementMap\and Source Type\' , 
			theSourceType nlsName, ' 	(', theSourceType name, ')\ or cancel to create a new View Type') withCRs
		fromList: someCandidateViewTypeLabels 
		values: someSortedViewTypes 
		lines: (((someSortedViewTypes size + 1) max: 5) min: 18)
		cancel: [nil].

	^aSelectedViewType!

semAttSourceModelCandidates
	

	| aMap aSourceModel someSourceElements someSourceRelatedTypes someExistingSourceRelatedTypes someSubElementMaps |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^nil].

	someSourceRelatedTypes :=IdentitySet new: 37. 
	someSourceElements do: [:aSourceElement |   | aRelatedType  |
		aSourceElement isAttribute ifTrue: [ 
			aRelatedType := aSourceElement valueType.
			aRelatedType isNil ifFalse: [ 
				aRelatedType withAllSubtypes: someSourceRelatedTypes.
			]
		]
	].

	someExistingSourceRelatedTypes := IdentitySet new: 13.
	someSubElementMaps := self subElementMaps.
	someSubElementMaps do: [:aSubElementMap |
		someSubElementMaps allSourceTypesInto: someExistingSourceRelatedTypes
	].
	someExistingSourceRelatedTypes do: [:aSF | someSourceRelatedTypes remove: aSF].

	^someSourceRelatedTypes!

semAttViewTypeCandidatesForSourceType: theSourceType

	| aMap someCandidateViewTypes |
	aMap := self map.
	aMap isNil ifTrue: [ ^nil].
 
	someCandidateViewTypes := self preferredMapClass scanMapsFolder: aMap forAllViewMetaInfosWithSourceMetaInfo: theSourceType.
	^someCandidateViewTypes!

semRelSelectedSourceType

	|  someCandidateRelatedTypes aSelectedRelatedType someCandidateRelatedTypeLabels someSortedRelatedTypes |

	someCandidateRelatedTypes := self semRelSourceModelCandidates.

	(someCandidateRelatedTypes isNil or: [ someCandidateRelatedTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not Source Types candidates as RelatedType Source for new ElementMap'.
		^self
	].

	someSortedRelatedTypes := someCandidateRelatedTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateRelatedTypeLabels := someSortedRelatedTypes collect: [:aRelatedType | 
		aRelatedType nlsName, ' 	(', aRelatedType name ,')' 
	].
	
	aSelectedRelatedType := Dialog 
		choose: ('Please, select a RelatedType as Source for new ElementMap') withCRs
		fromList: someCandidateRelatedTypeLabels 
		values: someSortedRelatedTypes 
		lines: (((someSortedRelatedTypes size + 1) max: 5) min: 18)
		cancel: [nil].

	^aSelectedRelatedType!

semRelSelectedViewTypeForSourceType: theSourceType

	|  someCandidateViewTypes aSelectedViewType someCandidateViewTypeLabels someSortedViewTypes |

	someCandidateViewTypes := self semRelViewTypeCandidatesForSourceType: theSourceType.

	(someCandidateViewTypes isNil or: [ someCandidateViewTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not existing View Types candidates as ViewType Source for new ElementMap'.
		^nil
	].

	someSortedViewTypes := someCandidateViewTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateViewTypeLabels := someSortedViewTypes collect: [:aViewType | 
		aViewType nlsName, ' 	(', aViewType name ,')' 
	].
	
	aSelectedViewType := Dialog 
		choose: ('Please, select an existing ViewType for new ElementMap\and Source Type\' , 
			theSourceType nlsName, ' 	(', theSourceType name, ')\ or cancel to create a new View Type') withCRs
		fromList: someCandidateViewTypeLabels 
		values: someSortedViewTypes 
		lines: (((someSortedViewTypes size + 1) max: 5) min: 18)
		cancel: [nil].

	^aSelectedViewType!

semRelSourceModelCandidates
	

	| aMap aSourceModel someSourceElements someSourceRelatedTypes someExistingSourceRelatedTypes someSubElementMaps |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^nil].

	someSourceRelatedTypes :=IdentitySet new: 37. 
	someSourceElements do: [:aSourceElement |   | aRelatedType  |
		aSourceElement isRelationship ifTrue: [ 
			aRelatedType := aSourceElement relatedType.
			aRelatedType isNil ifFalse: [ 
				aRelatedType withAllSubtypes: someSourceRelatedTypes.
			]
		]
	].

	someExistingSourceRelatedTypes := IdentitySet new: 13.
	someSubElementMaps := self subElementMaps.
	someSubElementMaps do: [:aSubElementMap |
		someSubElementMaps allSourceTypesInto: someExistingSourceRelatedTypes
	].
	someExistingSourceRelatedTypes do: [:aSF | someSourceRelatedTypes remove: aSF].

	^someSourceRelatedTypes!

semRelViewTypeCandidatesForSourceType: theSourceType

	| aMap someCandidateViewTypes |
	aMap := self map.
	aMap isNil ifTrue: [ ^nil].
 
	someCandidateViewTypes := self preferredMapClass scanMapsFolder: aMap forAllViewMetaInfosWithSourceMetaInfo: theSourceType.
	^someCandidateViewTypes!

sourceAttribute

	| someSourceElements aSourceElement |
	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^nil].

	aSourceElement := someSourceElements first.
	aSourceElement isAttribute ifFalse: [ ^nil].
	^aSourceElement!

sourceRelationship

	| someSourceElements aSourceElement |
	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^nil].

	aSourceElement := someSourceElements first.
	aSourceElement isRelationship ifFalse: [ ^nil].
	^aSourceElement!

sourceRelationshipInverse
	| aSourceRelationship |
	aSourceRelationship := self sourceRelationship.
	aSourceRelationship isNil ifTrue: [ ^nil].
	^aSourceRelationship inverse!

subElementMapsOfAttributeLinkCreateSelectingFromSourceModel

	|  aSelectedRelatedType aMap aViewModel anExistingViewType anAboutExistingMessage aBuildAttributeSpecificViewType |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSelectedRelatedType := self semAttSelectedSourceType.
	aSelectedRelatedType isNil ifTrue: [ ^nil].

	anExistingViewType := self semAttSelectedViewTypeForSourceType: aSelectedRelatedType.

	anExistingViewType isNil ifTrue: [ 
		anExistingViewType := aViewModel typeNamedArray: aSelectedRelatedType  fullyQualifiedNameArray
	].

	anAboutExistingMessage := anExistingViewType isNil 
		ifFalse: [ 'Type named\', aSelectedRelatedType fullyQualifiedName, '\already exists in ViewModel\']
		ifTrue: [ ''].

	aBuildAttributeSpecificViewType := Dialog  confirm: (anAboutExistingMessage , 
			'Do you want to create the new Type named:\' , aSelectedRelatedType name, '\in a Module specific to this Attribute?') withCRs 
		initialAnswer: false.

	^aBuildAttributeSpecificViewType 
		ifTrue: [ self  mapAttributeWithNewAttributeSpecificSourceRelatedType: aSelectedRelatedType]
		ifFalse: [ 
			anExistingViewType isNil 
				ifFalse: [  self mapAttributeWithExistingViewType: anExistingViewType ]
				ifTrue: [ self  mapAttributeNewSharedRelatedSourceType: aSelectedRelatedType]
		]!

subElementMapsOfRelationshipLinkCreateSelectingFromSourceModel

	|  aSelectedRelatedType aMap aViewModel anExistingViewType anAboutExistingMessage aBuildRelationshipSpecificViewType |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSelectedRelatedType := self semRelSelectedSourceType.
	aSelectedRelatedType isNil ifTrue: [ ^nil].

	anExistingViewType := self semRelSelectedViewTypeForSourceType: aSelectedRelatedType.

	anExistingViewType isNil ifTrue: [ 
		anExistingViewType := aViewModel typeNamedArray: aSelectedRelatedType  fullyQualifiedNameArray
	].

	anAboutExistingMessage := anExistingViewType isNil 
		ifFalse: [ 'Type named\', aSelectedRelatedType fullyQualifiedName, '\already exists in ViewModel\']
		ifTrue: [ ''].

	aBuildRelationshipSpecificViewType := Dialog  confirm: (anAboutExistingMessage , 
			'Do you want to create the new Type named:\' , aSelectedRelatedType name, '\in a Module specific to this Relationship?') withCRs 
		initialAnswer: false.

	^aBuildRelationshipSpecificViewType 
		ifTrue: [ self  mapRelationshipWithNewRelationshipSpecificSourceRelatedType: aSelectedRelatedType]
		ifFalse: [ 
			anExistingViewType isNil 
				ifFalse: [  self mapRelationshipWithExistingViewType: anExistingViewType ]
				ifTrue: [ self  mapRelationshipNewSharedRelatedSourceType: aSelectedRelatedType]
		]!

subElementMapsOfTypeLinkCreateSelectingFromSourceModel
"Create a View Feature (an Attribute or a Relationship) as Feature of an existing View type, from a Source Feature 
	1 - Create new View Feature
	2 - Add the new View Feature to the View Type
	3 - Create new ElementMap for the new View Feature
	4 - Add the new ElementMap as subElementMap of this ElementMap
		mapping the source Feature to the new View Feature
	5 - Create a new NLS in the Translation of the View Model, for the new View Feature,
		using the ItemTranslation of the source Feature in the Source Model
	6 - Create NLS in the Maps translation,  for the new ElementMap,
		using the ItemTranslation of the new View Module
"

	|  someSourceElements someViewElements aViewElement aSelectedFeature aNewViewFeature aMapMode aNewElementMap aNewMapLogic aViewModel aSourceModel aMap |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^nil].

	someViewElements := self viewElements.
	(someViewElements isNil or: [ someViewElements isEmpty]) ifTrue: [ ^nil].

	aViewElement := someViewElements first.
	aViewElement isType ifFalse: [ ^nil].

	aSelectedFeature := self subElementMapsOfTypeSelectedSourceFeature.
	aSelectedFeature isNil ifTrue: [ ^nil].

"	1 - Create new View Feature
	2 - Add the new View Feature to the View Type
"
	aSelectedFeature isRelationship
		ifFalse: [ 
			aNewViewFeature := self preferredAttributeClass new.
			aNewViewFeature name: aSelectedFeature name copy.
			aNewViewFeature initTerminalMetaAttributesFrom: aSelectedFeature.
			aViewElement attributesAdd: aNewViewFeature.
			aMapMode := self preferredMapLogicClass mapModeAttributeSymbol.
		]
		ifTrue: [ 
			aNewViewFeature := self preferredRelationshipClass new.
			aNewViewFeature name: aSelectedFeature name copy.
			aNewViewFeature initTerminalMetaAttributesFrom: aSelectedFeature.
			aViewElement relationshipsAdd: aNewViewFeature.
			aMapMode := self preferredMapLogicClass mapModeRelationshipSymbol.
		].


"	3 - Create new ElementMap for the new View Feature
"
	aNewElementMap := self preferredElementMapClass new.
	aNewElementMap name: aSelectedFeature name copy.
	aNewElementMap sourceElementsAdd: aSelectedFeature.
	aNewElementMap viewElementsAdd: aNewViewFeature.

	aNewMapLogic := self preferredMapLogicClass new.
	aNewMapLogic name: aMapMode asString.
	aNewMapLogic mapMode: aMapMode.

	aNewElementMap mapLogic: aNewMapLogic.


"	4 - Add the new ElementMap as subElementMap of this ElementMap
		mapping the source Feature to the new View Feature
"
	self subElementMapsAdd: aNewElementMap.




"	5 - Create a new NLS in the Translation of the View Model, for the new View Feature,
		using the ItemTranslation of the source Feature in the Source Model
"
	self createNLSForViewFeature: aNewViewFeature sourceFeature: aSelectedFeature.


"	6 - Create NLS in the Maps translation,  for the new ElementMap,
		using the ItemTranslation of the new View Module
"
	self createNLSForElementMap: aNewElementMap  viewFeature: aNewViewFeature.
	
	aNewViewFeature changed: #name.
	aNewElementMap changed: #name.!

subElementMapsOfTypeSelectedSourceFeature

	|  someCandidateFeatures aSelectedFeature someSortedFeatures someCandidateFeatureLabels |

	someCandidateFeatures := self subElementMapsOfTypeSourceFeatureCandidates.

	(someCandidateFeatures isNil or: [ someCandidateFeatures isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not Source Features candidates as  Source for new ElementMap'.
		^self
	].

	someSortedFeatures := someCandidateFeatures asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateFeatureLabels := someSortedFeatures collect: [:aFeature | 
		aFeature nlsName, ' 	(', aFeature name ,')' 
	].


	aSelectedFeature := Dialog 
		choose: ('Please, select a Feature as Source for new ElementMap') withCRs
		fromList: someCandidateFeatureLabels
		values: someSortedFeatures 
		lines: (((someSortedFeatures size + 1) max: 5) min: 18)
		cancel: [nil].
	
	^aSelectedFeature!

subElementMapsOfTypeSourceFeatureCandidates

	|  someSourceElements someSourceFeatures someExistingSourceFeatures someSubElementMaps |

	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^nil].

	someSourceFeatures :=IdentitySet new: 37.
	someSourceElements do: [:aSourceElement |  
		aSourceElement isType ifTrue: [ aSourceElement allFeaturesInto: someSourceFeatures]
	].

	someExistingSourceFeatures := IdentitySet new: 13.
	someSubElementMaps := self subElementMaps.
	someSubElementMaps do: [:aSubElementMap |
		aSubElementMap allSourceFeaturesInto: someExistingSourceFeatures
	].
	someExistingSourceFeatures do: [:aSF | someSourceFeatures remove: aSF ifAbsent: [ nil]].

	^someSourceFeatures!

viewAttribute

	| someViewElements aViewElement |
	someViewElements := self viewElements.
	(someViewElements isNil or: [ someViewElements isEmpty]) ifTrue: [ ^nil].

	aViewElement := someViewElements first.
	aViewElement isAttribute ifFalse: [ ^nil].
	^aViewElement!

viewRelationship

	| someViewElements aViewElement |
	someViewElements := self viewElements.
	(someViewElements isNil or: [ someViewElements isEmpty]) ifTrue: [ ^nil].

	aViewElement := someViewElements first.
	aViewElement isRelationship ifFalse: [ ^nil].
	^aViewElement!

xsubElementMapsOfAttributeLinkCreateSelectingFromSourceModel

	|  someSourceElements someViewElements aViewElement someSubElementMaps aNewElementMap aNewMapLogic someSourceValueTypes  someExistingSourceValueTypes someCandidateValueTypes aSelectedValueType aNewViewValueType aMap aViewModel aSourceValueTypeFullyQualifiedNameArray anExistingViewType aModuleForNewViewType aParentViewModule aNewViewModuleName aNewViewModule aSourceValueTypeModuleFullyQualifiedArray anExistingViewModule aUseAttributeSpecificType someSourceSubTypes aNewViewSubType aNewSubElementMap aNewSubMapLogic aMapsFolderForNewViewTypeMap aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].


	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^nil].

	someViewElements := self viewElements.
	(someViewElements isNil or: [ someViewElements isEmpty]) ifTrue: [ ^nil].

	aViewElement := someViewElements first.
	aViewElement isAttribute ifFalse: [ ^nil].

	someSourceValueTypes :=IdentitySet new: 37. 
	someSourceElements do: [:aSourceElement |   | aValueType  |
		aSourceElement isAttribute ifTrue: [ 
			aValueType := aSourceElement valueType.
			aValueType isNil ifFalse: [ 
				aValueType withAllSubtypes: someSourceValueTypes.
			]
		]
	].

	someExistingSourceValueTypes := IdentitySet new: 13.
	someSubElementMaps := self subElementMaps.
	someSubElementMaps do: [:aSubElementMap |
		someSubElementMaps allSourceTypesInto: someExistingSourceValueTypes
	].
	someExistingSourceValueTypes do: [:aSF | someSourceValueTypes remove: aSF].

	someCandidateValueTypes := someSourceValueTypes asSortedCollection: [:a :b | a name < b name].

	aSelectedValueType := Dialog 
		choose: ('Please, select a ValueType as Source for new ElementMap') withCRs
		fromList: (someCandidateValueTypes collect: [:aValueType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aValueType name]
				do: [ aValueType displayName ]]) 
		values: someCandidateValueTypes 
		lines: (((someCandidateValueTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedValueType isNil ifTrue: [ ^nil].

	aSourceValueTypeFullyQualifiedNameArray := aSelectedValueType fullyQualifiedNameArray.
	(aSourceValueTypeFullyQualifiedNameArray isNil or: [ 
		aSourceValueTypeFullyQualifiedNameArray isEmpty]) ifTrue: [ ^nil].

	anExistingViewType := aViewModel typeNamedArray: aSourceValueTypeFullyQualifiedNameArray.
	anExistingViewType isNil ifFalse: [ 
		(Dialog confirm: ('A Type named\', aSelectedValueType name, 'already exists in View Model Module\',
			aSelectedValueType module fullyQualifiedName, '\Do you want to use this existing View Type ?\',
				'- In this case no subElementMap will be created -') withCRs initialAnswer: true)
			ifTrue: [ 
				aViewElement valueType: anExistingViewType.
				^nil
			]
	].

	aUseAttributeSpecificType := false.
	aModuleForNewViewType := nil. 
	(anExistingViewType isNil not or:  [
		Dialog confirm: ('A New Type named\', aSelectedValueType name, 'will be created forValueType of attribute\', aViewElement name,
			'\Do you want to create the new Type in a Module specific to this Attribute?') withCRs initialAnswer: false]) 
		ifTrue: [ 
			aParentViewModule := aViewElement type module.
			aNewViewModuleName := self attributeSpecificModuleNameFor: aViewElement.
			aNewViewModule := self preferredViewModuleClass new.
			aNewViewModule name: aNewViewModuleName.
			aParentViewModule subModulesAdd: aNewViewModule.
			aModuleForNewViewType := aNewViewModule.
			aUseAttributeSpecificType := true.
		]
		ifFalse: [ 
			aSourceValueTypeModuleFullyQualifiedArray := aSelectedValueType module fullyQualifiedNameArray.
			anExistingViewModule := aViewModel moduleNamedArray: aSourceValueTypeModuleFullyQualifiedArray.
			anExistingViewModule isNil 
				ifFalse: [  aModuleForNewViewType := anExistingViewModule]
				ifTrue: [ 
					aModuleForNewViewType := aViewModel newOrExistingModuleNamedArray: aSourceValueTypeModuleFullyQualifiedArray.
				]
		].

	aModuleForNewViewType isNil ifTrue: [ ^nil].

	aNewViewValueType := self preferredTypeClass new.
	aNewViewValueType name: aSelectedValueType name copy.
	aNewViewValueType isAbstract: aSelectedValueType isAbstract == true.
	aNewViewValueType isEnumeration: aSelectedValueType isEnumeration == true.
	aNewViewValueType isPrimitive: aSelectedValueType isPrimitive == true.
	aModuleForNewViewType typesAdd: aNewViewValueType.
	aViewElement valueType: aNewViewValueType.



	aNewElementMap := self preferredElementMapClass new.
	aNewElementMap name: aSelectedValueType name copy.
	aNewElementMap sourceElementsAdd: aSelectedValueType.
	aNewElementMap viewElementsAdd: aNewViewValueType.

	aNewMapLogic := self preferredMapLogicClass new.
	aNewMapLogic name: aNewMapLogic class mapModeTypeSymbol asString.
	aNewMapLogic mapMode: aNewMapLogic class mapModeTypeSymbol.

	aNewElementMap mapLogic: aNewMapLogic.
	aUseAttributeSpecificType
		ifTrue: [ self subElementMapsAdd: aNewElementMap]
		ifFalse: [ 
			aSourceValueTypeModuleFullyQualifiedArray := aSelectedValueType module fullyQualifiedNameArray.
			aMapsFolderForNewViewTypeMap := aMap newOrExistingModuleNamedArray: aSourceValueTypeModuleFullyQualifiedArray.
			aMapsFolderForNewViewTypeMap elementMapsAdd: aNewElementMap
		].







	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^aNewElementMap].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^aNewElementMap].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^aNewElementMap].

	(aSelectedValueType nameNLSGroupName = aNewViewValueType nameNLSGroupName and: [ 
		aSelectedValueType nameNLSItemName = aNewViewValueType nameNLSItemName
	]) ifTrue: [ ^aNewElementMap].


	(aViewTranslation nlsLocalResolverItemGroupNoDefault: aNewViewValueType nameNLSGroupName item: aNewViewValueType nameNLSItemName) isNil ifFalse: [ 
		^aNewElementMap
	].

	aSourceTranslationItem := aViewTranslation superApplicationTranslation nlsResolverItemGroupNoDefault: aSelectedValueType nameNLSGroupName 
		item: aSelectedValueType nameNLSItemName.
	aSourceTranslationItem isNil ifTrue: [ ^aNewElementMap].

	aViewTranslation recordNLSGroup: aNewViewValueType nameNLSGroupName item: aNewViewValueType nameNLSItemName.

	aNewTranslationItem := self nlsLocalResolverItemGroupNoDefault: aNewViewValueType nameNLSGroupName item: aNewViewValueType nameNLSItemName.
	aNewTranslationItem isNil ifTrue: [ ^aNewElementMap].

	aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem.









	aUseAttributeSpecificType ifFalse: [ ^aNewElementMap].

	someSourceSubTypes := aSelectedValueType allSubtypes.
	(someSourceSubTypes isNil or: [ someSourceSubTypes isEmpty]) ifTrue: [ ^aNewElementMap].

	(Dialog confirm: 'Do you also want to map the subTypes of \', aSelectedValueType name initialAnswer: false) ifFalse: [ ^aNewElementMap].

	someSourceSubTypes do: [:aSourceSubType |
		(aNewViewValueType subTypes detect: [:aST | aST name = aSourceSubType name] ifNone: [ nil]) isNil ifTrue: [ 
			
			aNewViewSubType := self preferredTypeClass new.
			aNewViewSubType name: aSourceSubType name copy.
			aNewViewSubType isAbstract: aSourceSubType isAbstract == true.
			aNewViewSubType isEnumeration: aSourceSubType isEnumeration == true.
			aNewViewSubType isPrimitive: aSourceSubType isPrimitive == true.
			aModuleForNewViewType typesAdd: aNewViewSubType.
			aNewViewValueType subTypesAdd: aNewViewSubType.

			aNewSubElementMap := self preferredElementMapClass new.
			aNewSubElementMap name: aSourceSubType name copy.
			aNewSubElementMap sourceElementsAdd: aSourceSubType.
			aNewSubElementMap viewElementsAdd: aNewViewSubType.
			aNewElementMap subElementMapsAdd: aNewSubElementMap.

			aNewSubMapLogic := self preferredMapLogicClass new.
			aNewSubMapLogic name: aNewSubMapLogic class mapModeTypeSymbol asString.
			aNewSubMapLogic mapMode: aNewSubMapLogic class mapModeTypeSymbol.

			aNewSubElementMap mapLogic: aNewSubMapLogic
		]
	].

	^aNewElementMap! !

!CODEElementMap publicMethodsFor: 'derived accessing'!

allSourceFeaturesInto: theFeatures
	| someSourceElements someSubElementMaps |
	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^self].

	someSourceElements do: [:aSourceElement |
		aSourceElement isFeature ifTrue: [ theFeatures add: aSourceElement]
	].

	someSubElementMaps := self subElementMaps.
	(someSubElementMaps isNil or: [ someSubElementMaps isEmpty]) ifTrue: [ ^self].
	someSubElementMaps do: [:aSubElementMap |
		aSubElementMap allSourceFeaturesInto: theFeatures
	].!

allSourceTypes
	| someTypes |
	someTypes := IdentitySet new: 13.
	self allSourceTypesInto: someTypes.
	^someTypes!

allSourceTypesInto: theTypes
	| someSourceElements someSubElementMaps |
	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^self].

	someSourceElements do: [:aSourceElement |
		aSourceElement isType ifTrue: [ theTypes add: aSourceElement]
	].

	someSubElementMaps := self subElementMaps.
	(someSubElementMaps isNil or: [ someSubElementMaps isEmpty]) ifTrue: [ ^self].
	someSubElementMaps do: [:aSubElementMap |
		aSubElementMap allSourceTypesInto: theTypes
	].!

applicationConfiguration
	^self superElementMap isNil 
		ifFalse: [ self superElementMap applicationConfiguration]
		ifTrue: [ 
			self mapsFolder isNil 
				ifFalse: [ self mapsFolder applicationConfiguration]
				ifTrue: [ nil]]!

fullyQualifiedName

	| aModuleFullyQualifiedName aFullyQualifiedName aSuperElementMap aSuperElementMapFullyQualifiedName aModule |

	aModule := self module.

	(aModule isNil not and: [ aModule isMap]) ifTrue: [ ^self name].
	
	(aModule isNil not and: [ 
		aModuleFullyQualifiedName := aModule fullyQualifiedName.
		aModuleFullyQualifiedName isNil not and: [ aModuleFullyQualifiedName isEmpty not]])  ifTrue: [ 
			aFullyQualifiedName := aModuleFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
			^aFullyQualifiedName
	].

	aSuperElementMap := self superElementMap.
	aSuperElementMap isNil ifTrue: [ ^self name].

	aSuperElementMapFullyQualifiedName := aModule fullyQualifiedName.

	aFullyQualifiedName := aSuperElementMapFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

fullyQualifiedNameArray

	| aSuperModule aSuperElementMap aModuleFullyQualifiedNameArray aFullyQualifiedNameArray aSuperElementMapFullyQualifiedNameArray |

	aSuperModule := self superModule.

	(aSuperModule isNil not and: [ aSuperModule isMap]) ifTrue: [ ^Array with: self name].
	
	(aSuperModule isNil not and: [ 
		aModuleFullyQualifiedNameArray := aSuperModule fullyQualifiedNameArray.
		aModuleFullyQualifiedNameArray isNil not and: [ aModuleFullyQualifiedNameArray isEmpty not]])  ifTrue: [ 
			aFullyQualifiedNameArray := aModuleFullyQualifiedNameArray, (Array with: self name).
			^aFullyQualifiedNameArray
	].

	aSuperElementMap := self superElementMap.
	aSuperElementMap isNil ifTrue: [ ^Array with: self name].

	aSuperElementMapFullyQualifiedNameArray := aSuperModule fullyQualifiedNameArray.

	aFullyQualifiedNameArray := aSuperElementMapFullyQualifiedNameArray, (Array with: self name).
	^aFullyQualifiedNameArray!

map
	^self model!

model
	^self superElementMap isNil 
		ifFalse: [ self superElementMap model]
		ifTrue: [ 
			self mapsFolder isNil 
				ifFalse: [ self mapsFolder model]
				ifTrue: [ nil]]!

module
	^self superElementMap isNil 
		ifFalse: [ self superElementMap module]
		ifTrue: [ self mapsFolder]!

nameAndLogic
self halt.
	^self name , (self mapLogic isNil ifTrue: [ ''] ifFalse: [ self mapLogic mapMode])! !

!CODEElementMap publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self superElementMap isNil 
			ifFalse: [ self superElementMap markDirtyOwner]
			ifTrue: [
				self mapsFolder isNil 
					ifFalse: [ self mapsFolder markDirtyOwner]]
	].!

markDirtyOwner
	dirty == true ifFalse: [ 
		self superElementMap isNil 
			ifFalse: [ self superElementMap markDirtyOwner]
			ifTrue: [
				self mapsFolder isNil 
					ifFalse: [ self mapsFolder markDirtyOwner]]
	].!

persistIfDirty
	^self superElementMap isNil 
		ifFalse: [self  superElementMap persistIfDirty]
		ifTrue: [
			self mapsFolder isNil 
				ifFalse: [self  mapsFolder persistIfDirty]
				ifTrue: [ nil]].! !

!CODEElementMap publicMethodsFor: 'initialize-release'!

release
	self changed: #objectDisconnectedOfTree.

	self superElementMapRelease.
	self subElementMapsRelease.
	self sourceElementsRelease.
	self viewElementsRelease.
	self mapLogicRelease.

	super release! !

!CODEElementMap publicMethodsFor: 'nls'!

nameNLSGroupName
	| aGroupName |
	aGroupName := self fullyQualifiedName, self class elementMapNameNLSGroupNamePostfix .
	^aGroupName!

nameNLSItemName
	| anItemName |
	anItemName := self name, self class elementMapNameNLSItemNamePostfix.
	^anItemName! !

!CODEElementMap publicMethodsFor: 'persistence-code'!

firstPersistenceIndexElementMap
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexElementMap.

	theValues size < aFPI ifFalse: [ self initMapLogicFromValues: (theValues at: aFPI) ].

	theValues size < (aFPI + 1) ifFalse: [ self initSubElementMapsFromValues: (theValues at: (aFPI + 1))].

	theValues size < (aFPI + 2) ifFalse: [  self initReferencedSourceElementsFromValues: (theValues at: (aFPI + 2))].

	theValues size < (aFPI + 3) ifFalse: [  self initReferencedViewElementsFromValues: (theValues at: (aFPI + 3))].!

initMapLogicFromValues: theValues 
	
	| aMapLogic |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	aMapLogic := CODEElement newFromPersistenceAsCode: theValues.
	aMapLogic isNil ifFalse: [ 
		self mapLogicPrivate: aMapLogic.
		aMapLogic elementMapPrivate: self]!

initReferencedSourceElementsFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class referencedElementsPersistenceSymbol ifFalse: [ ^nil].

	sourceElementsRefsTmpValues := theValues.!

initReferencedViewElementsFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class referencedElementsPersistenceSymbol ifFalse: [ ^nil].

	viewElementsRefsTmpValues := theValues.!

initSourceElementsRefsTmpValuesFromModel 
	
	| someSourceElementsArrays |
	someSourceElementsArrays := self viewElementsPrivate collect:  [:anElement | anElement asReferenceArray ].

	sourceElementsRefsTmpValues := (Array with: self class referencedElementsPersistenceSymbol), someSourceElementsArrays asArray!

initSubElementMapsFromValues: theValues 
	
	| someSubElementMaps |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someSubElementMaps := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someSubElementMaps isNil ifFalse: [ 
		self subElementMapsPrivate addAll: someSubElementMaps.
		someSubElementMaps do: [:aEM | aEM superElementMapPrivate: self]]!

initViewElementsRefsTmpValuesFromModel 
	
	| someViewElementsArrays |
	someViewElementsArrays := self viewElementsPrivate collect:  [:anElement | anElement asReferenceArray ].

	viewElementsRefsTmpValues := (Array with: self class referencedElementsPersistenceSymbol), someViewElementsArrays asArray!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep aMapLogic |
	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	aMapLogic := self mapLogic.
	aMapLogic isNil  
		ifTrue: [ theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil); cr] 
		ifFalse: [ aMapLogic persistenceAsCodeStringOn: theStream indent: anIS].

	self subElementMapsPersistenceAsCodeStringOn: theStream indent: theIS.
	self referencedSourceElementsPersistenceAsCodeStringOn: theStream indent: theIS.
	self referencedViewElementsPersistenceAsCodeStringOn: theStream indent: theIS.!

numberPersistenceEntriesElementMap
	^0!

rebindReferencedSourceElementsValuesFromSolver: theSolver
	
	| someElements aSolver |

	(sourceElementsRefsTmpValues isNil or: [ sourceElementsRefsTmpValues isEmpty]) ifTrue: [ ^self].

	aSolver := (theSolver isKindOf: CODEMap) ifTrue: [ theSolver sourceModel] ifFalse: [ theSolver].
	someElements := 
		CODEElement resolveOrNewReferencedElementsCollectionFromPersistenceAsCode: sourceElementsRefsTmpValues  
			solver: aSolver.
	self sourceElementsPrivate  addAll: someElements.
	sourceElementsRefsTmpValues := nil!

rebindReferencedViewElementsValuesFromSolver: theSolver
	
	| someElements aSolver |

	(viewElementsRefsTmpValues isNil or: [ viewElementsRefsTmpValues isEmpty]) ifTrue: [ ^self].

	aSolver := (theSolver isKindOf: CODEMap) ifTrue: [ theSolver viewModel] ifFalse: [ theSolver].
	someElements := 
		CODEElement resolveOrNewReferencedElementsCollectionFromPersistenceAsCode: viewElementsRefsTmpValues  
			solver: aSolver.
	self viewElementsPrivate  addAll: someElements.

	viewElementsRefsTmpValues := nil!

rebindToModelsFromSolver: theSolver

	self rebindReferencedSourceElementsValuesFromSolver: theSolver.
	self rebindReferencedViewElementsValuesFromSolver: theSolver.

	self subElementMapsPrivate do: [:anElementMap | anElementMap rebindToModelsFromSolver: theSolver]!

referencedSourceElementsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self sourceElementsPrivate isNil not and: [ self sourceElementsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil); cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	    	 			nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class referencedElementsPersistenceSymbol); cr
			].
			self sourceElementsPrivate do:  [:anElement |
				anElement asReferenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

referencedViewElementsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self viewElementsPrivate isNil not and: [ self viewElementsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil); cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	    	 			nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class referencedElementsPersistenceSymbol); cr
			].
			self viewElementsPrivate do:  [:anElement |
				anElement asReferenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

subElementMapsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self subElementMapsPrivate isNil not and: [ self subElementMapsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class subElementMapsPersistenceSymbol); cr
			].
			self subElementMapsPrivate do:  [:anElementMap |
				anElementMap persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

unbindFromModels

	self initSourceElementsRefsTmpValuesFromModel.
	self initViewElementsRefsTmpValuesFromModel.

	self subElementMapsPrivate do: [:anElementMap | anElementMap unbindFromModels]! !

!CODEElementMap publicMethodsFor: 'preferences'!

preferredViewModuleClass
	^super  preferredModuleClass! !

!CODEElementMap publicMethodsFor: 'semantic checking'!

checkMapLogic: aValue

	^true!

checkMapsFolder: aValue

	^true!

checkSourceElementsAdd: aValue

	^true!

checkSourceElementsRemove: aValue

	^true!

checkSubElementMapsAdd: aValue

	^true!

checkSubElementMapsRemove: aValue

	^true!

checkSuperElementMap: aValue

	^true!

checkViewElementsAdd: aValue

	^true!

checkViewElementsRemove: aValue

	^true! !

!CODEElementMap publicMethodsFor: 'semantic links'!

mapLogicCandidates

	^self mapLogic isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self mapLogic]!

mapLogicCreate

	^nil!

mapLogicLinkSelect

	| anObject |

	anObject := RTObjectServer new
		selectIn: self mapLogicCandidates
		initially: self mapLogic
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self mapLogic: anObject.!

mapLogicLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self mapLogicCandidates
		initially: self mapLogic
		label: 'Select Or Create ...'
		class: self mapLogicCreate class
		ifUnchanged: [^self].
	self mapLogic: anObject!

mapLogicScope

	^nil!

mapsFolderCandidates

	^self mapsFolder isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self mapsFolder]!

mapsFolderCreate

	^nil!

mapsFolderLinkCreate

	| anObject |

	anObject := self mapsFolderCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self mapsFolder: anObject]!

mapsFolderLinkSelect

	| anObject |

	anObject := RTObjectServer new
		selectIn: self mapsFolderCandidates
		initially: self mapsFolder
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self mapsFolder: anObject.!

mapsFolderLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self mapsFolderCandidates
		initially: self mapsFolder
		label: 'Select Or Create ...'
		class: self mapsFolderCreate class
		ifUnchanged: [^self].
	self mapsFolder: anObject!

mapsFolderScope

	^nil!

sourceElementsCreate

	^nil!

sourceElementsLinkCreate

	| anObject |

	anObject := self sourceElementsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self sourceElementsAdd: anObject]!

sourceElementsLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self sourceElementsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self sourceElementsCreate class
		ifUnchanged: [^self].
	self sourceElementsAdd: anObject!

sourceElementsScope

	^nil!

subElementMapsCandidates

	^self subElementMaps asArray!

subElementMapsCreate

	^CODEElementMap new!

subElementMapsLinkCreate

	| anObject |

	anObject := self subElementMapsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self subElementMapsAdd: anObject]!

subElementMapsLinkSelect

	| anObject |

	anObject := RTObjectServer new
		selectIn: self subElementMapsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self subElementMapsAdd: anObject.!

subElementMapsLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self subElementMapsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self subElementMapsCreate class
		ifUnchanged: [^self].
	self subElementMapsAdd: anObject!

subElementMapsScope

	^nil!

superElementMapCandidates

	^self superElementMap isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self superElementMap]!

superElementMapCreate

	^nil!

superElementMapLinkCreate

	| anObject |

	anObject := self superElementMapCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self superElementMap: anObject]!

superElementMapLinkSelect

	| anObject |

	anObject := RTObjectServer new
		selectIn: self superElementMapCandidates
		initially: self superElementMap
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self superElementMap: anObject.!

superElementMapLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self superElementMapCandidates
		initially: self superElementMap
		label: 'Select Or Create ...'
		class: self superElementMapCreate class
		ifUnchanged: [^self].
	self superElementMap: anObject!

superElementMapScope

	^nil!

viewElementsCandidates

	^self viewElements asArray!

viewElementsCreate

	^nil!

viewElementsLinkCreate

	| anObject |

	anObject := self viewElementsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self viewElementsAdd: anObject]!

viewElementsLinkSelect

	| anObject |

	anObject := RTObjectServer new
		selectIn: self viewElementsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self viewElementsAdd: anObject.!

viewElementsLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self viewElementsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self viewElementsCreate class
		ifUnchanged: [^self].
	self viewElementsAdd: anObject!

viewElementsScope

	^nil! !

!CODEElementMap publicMethodsFor: 'semantic links-custom'!

mapLogicLinkCreate

	| aMapMode aMapLogic someMapModeSymbols |
	someMapModeSymbols :=  self preferredMapLogicClass mapModeSymbols.
	aMapMode := Dialog 
		choose: 'Please, select the MapMode for the new MapLogic\for ElementMap' withCRs, self name 
		fromList: someMapModeSymbols
		values: someMapModeSymbols
		lines: someMapModeSymbols size + 1
		cancel: [nil]
		initialSelection: (self mapLogic isNil ifTrue:  [ nil] ifFalse: [ self mapLogic mapMode]).

	aMapMode isNil ifTrue: [ ^nil].

	aMapLogic := self preferredMapLogicClass new.
	aMapLogic name: aMapMode asString.
	aMapLogic mapMode: aMapMode asSymbol.
	self mapLogic: aMapLogic.

	^aMapLogic!

sourceElementsCandidates!

sourceElementsLinkSelect
	| aMapLogic |


	aMapLogic := self mapLogic.
	aMapLogic isNil ifTrue: [ 
		Dialog warn: 'Please, create a MapLogic before assigning SourceElements'.
		self mapLogicLinkCreate
	].

	aMapLogic isNil ifTrue: [ 
		Dialog warn: 'Can not assign SourceElements without a MapLogic'.
		^nil
	].

	^aMapLogic sourceElementsLinkSelect!

subElementMapsLinkCreateSelectingFromSourceModel

	| aSourceElement someSourceElements |

	someSourceElements := self sourceElements.
	(someSourceElements isNil or: [ someSourceElements isEmpty]) ifTrue: [ ^nil].

	aSourceElement := someSourceElements first.

	^aSourceElement isType 
		ifTrue: [ self subElementMapsOfTypeLinkCreateSelectingFromSourceModel]
		ifFalse: [
			aSourceElement isAttribute 
				ifTrue: [ self subElementMapsOfAttributeLinkCreateSelectingFromSourceModel]
				ifFalse: [ self subElementMapsOfRelationshipLinkCreateSelectingFromSourceModel]
		]! !

!CODEElementMap publicMethodsFor: 'utils'!

scanForElementMapWithViewMetaInfo: theAttribute
	sourceMetaInfo: theSourceMetaInfo toViewMetaInfo: theViewMetaInfo forNode: theNode

	| aFoundElementMap |

	theNode isNil ifTrue: [ ^nil].
	theAttribute isNil ifTrue: [ ^nil].

	aFoundElementMap :=  self scanThisForElementMapWithViewMetaInfo: theAttribute
		sourceMetaInfo: theSourceMetaInfo toViewMetaInfo: theViewMetaInfo forNode: theNode.
	aFoundElementMap  isNil ifFalse: [ ^aFoundElementMap].

	aFoundElementMap :=  self scanInheritedForElementMapWithViewMetaInfo: theAttribute
		sourceMetaInfo: theSourceMetaInfo toViewMetaInfo: theViewMetaInfo forNode: theNode.
	^aFoundElementMap!

scanInheritedForElementMapWithViewMetaInfo: theAttribute
	sourceMetaInfo: theSourceMetaInfo toViewMetaInfo: theViewMetaInfo forNode: theNode

	| someSubElementMaps aSourceElementMap aFoundElementMap aMap |

	theNode isNil ifTrue: [ ^nil].
	theAttribute isNil ifTrue: [ ^nil].

	aMap := self map.
	

	someSubElementMaps := self subElementMaps.
	(someSubElementMaps isNil or: [ someSubElementMaps isEmpty]) ifTrue: [ ^nil].
	
	aSourceElementMap := someSubElementMaps detect: [:anElementMap |
		anElementMap viewElementsIncludes: theAttribute] ifNone: [ nil].
	aSourceElementMap  isNil ifFalse: [ ^aSourceElementMap].

	aFoundElementMap :=  nil.
	someSubElementMaps detect: [:anElementMap |   
		aFoundElementMap := anElementMap scanForElementMapWithViewMetaInfo: theAttribute
			sourceMetaInfo: theSourceMetaInfo toViewMetaInfo: theViewMetaInfo forNode: theNode.
		aFoundElementMap isNil not ] ifNone: [ nil].

	^aFoundElementMap!

scanThisForElementMapWithViewMetaInfo: theAttribute
	sourceMetaInfo: theSourceMetaInfo toViewMetaInfo: theViewMetaInfo forNode: theNode

	| someSubElementMaps aSourceElementMap aFoundElementMap |

	theNode isNil ifTrue: [ ^nil].
	theAttribute isNil ifTrue: [ ^nil].

	someSubElementMaps := self subElementMaps.
	(someSubElementMaps isNil or: [ someSubElementMaps isEmpty]) ifTrue: [ ^nil].
	
	aSourceElementMap := someSubElementMaps detect: [:anElementMap |
		anElementMap viewElementsIncludes: theAttribute] ifNone: [ nil].
	aSourceElementMap  isNil ifFalse: [ ^aSourceElementMap].

	aFoundElementMap :=  nil.
	someSubElementMaps detect: [:anElementMap |   
		aFoundElementMap := anElementMap scanForElementMapWithViewMetaInfo: theAttribute
			sourceMetaInfo: theSourceMetaInfo toViewMetaInfo: theViewMetaInfo forNode: theNode.
		aFoundElementMap isNil not ] ifNone: [ nil].

	^aFoundElementMap! !

!CODEgen class publicMethodsFor: 'ENVY'!

loaded

	CODEElement initialize! !

!CODEGenInstaller class publicMethodsFor: 'persistence-code'!

elementMethod: theSelector inClass: theClassName
	| aClassName aClass aSelector aCompiledMethod aMetaClass |
	(theSelector isNil or: [ theSelector isEmpty]) ifTrue: [ ^nil].
	(theClassName isNil or: [ theClassName isEmpty]) isNil ifTrue: [ ^nil].

	aClassName := theClassName asSymbol.
	aClass := Smalltalk at:  aClassName ifAbsent: [ nil].
	aClass isNil ifTrue: [ ^nil].

	aMetaClass := aClass class.

	aSelector := theSelector asSymbol.
	aCompiledMethod := aMetaClass compiledMethodAt: aSelector ifAbsent: [ nil].
	aCompiledMethod isNil ifTrue: [ ^nil].

	^Array with: aClass with: aCompiledMethod!

existsElementMethod: theSelector inClass: theClassName
	^(self elementMethod: theSelector inClass: theClassName) isNil not!

intoStream: theStream sourceHeaderForElementMethod: theSelector inClass: theClassName

	theStream isNil ifTrue: [ ^self].

	theStream nextPutAll: theSelector; cr; cr.
	theStream nextPutAll: '	"(CODEElement newFromPersistenceAsCode: ';
		nextPutAll: theClassName; nextPutAll: ' '; nextPutAll: theSelector; nextPutAll: ') browsePath"'; cr; cr.
	theStream nextPutAll: '	self ojoModel.'; cr; cr.
	theStream nextPutAll: '	^ '.!

isInteractive
	^false!

makeBackup
	^false!

modelElementsProtocol
	^'modelElements persistence' copy!

ojoDefinedParts!

persistChunk: theChunk

	| aSource aSelector aClassName aClass aMakeBackup aTargetSelector anElement |

	theChunk isNil ifTrue: [ ^nil].

	anElement := theChunk first.
	anElement isNil ifTrue: [ ^nil].

	aSource := theChunk at: 2.
	(aSource isNil or: [aSource isEmpty]) ifTrue: [ ^nil].
	
	aSelector := anElement storeMethodSelector.
	(aSelector isNil or: [ aSelector isEmpty]) ifTrue: [ ^nil].
	aSelector := aSelector asSymbol.

	aClassName := anElement storeClassName.
	(aClassName isNil or: [ aClassName isEmpty]) isNil ifTrue: [ ^nil].
	aClassName := aClassName asSymbol.

	aClass := Smalltalk at:  aClassName ifAbsent: [ nil].
	aClass isNil ifTrue: [ ^nil].

	self isInteractive ifTrue: [
		(Dialog confirm: 'Do you really want to install on Class\' withCRs,
			aClassName ,'>>', aSelector,  ' ?' initialAnswer: false) ifFalse: [ ^nil]].

	Transcript show: 'Installing on Class ' , aClassName ,'>>', aSelector, '  ... '; cr.


	aMakeBackup := false.

	(aClass class includesSelector: aSelector) ifTrue: [
		 self isInteractive
			ifFalse: [	
				aMakeBackup := self makeBackup.
				Transcript show: '     ', aClassName , ' class already includes selector ' , aSelector; cr.
				aMakeBackup 
					ifTrue: [ Transcript show: '        Keeping backup copy as x', aSelector; cr]
					ifFalse: [ Transcript show: '        No Backup kept of' , aClassName ,'>>', aSelector; cr]
			]
			ifTrue: [ 
				aMakeBackup := Dialog 
					choose: aClassName , ' class already includes selector\' withCRs,
						aSelector, '\' withCRs,
						'Do you want to keep a backup copy of it as ', 'x', aSelector, ' ?'
					labels: #('Backup copy' 'No Backup' 'Cancel')
					values: #(true false nil)
					default: false.
				aMakeBackup isNil ifTrue: [ ^nil]]].

	aMakeBackup ifTrue: [ 
		self errorSignal handle: [:anException |  | aMsg |
self halt.
			aMsg := '    Error making backup copy on Class ' , aClassName ,'>>x', 
				aSelector, '\' withCRs, 'Installation aborted'.
			self isInteractive ifTrue: [ Dialog warn: aMsg].
			Transcript show: aMsg;cr.
			^nil]
		do: [     | aMsg |
			aTargetSelector := aClass class 
				compile: 'x', (aClass class sourceCodeAt: aSelector)
				classified: self modelElementsProtocol
				notifying: nil.
			aTargetSelector isNil ifTrue: [ 
				aMsg := '    Backup copy in Class ' , aClassName ,'>>x',  aSelector, ' failed'.
				 self isInteractive ifTrue: [ Dialog warn: aMsg].
				Transcript show: aMsg;cr.
				^nil]]].


	self errorSignal handle: [:anException | | aMsg | 
self halt.
		aMsg :=  '    Error installing on Class ' , aClassName ,'>>', aSelector, 
				'\Installation aborted' withCRs.
		self isInteractive ifTrue: [ Dialog warn: aMsg].
		Transcript show: aMsg; cr.
		^nil]
		do: [  | aSourceCodeStream aMsg |

			aSourceCodeStream := WriteStream on: (String new: 1024).
			self intoStream: aSourceCodeStream sourceHeaderForElementMethod: aSelector 
				inClass: aClassName.

			aSourceCodeStream nextPutAll: aSource.

			aTargetSelector := aClass class 
				compile: aSourceCodeStream contents
				classified: self modelElementsProtocol
				notifying: nil.
			aTargetSelector isNil ifTrue: [ 
				aMsg := '    Installation on Class ' , aClassName ,'>>', aSelector, ' failed.'.
				self isInteractive ifTrue: [ Dialog warn: aMsg].
				Transcript show: aMsg; cr.
				^nil
			].
			Transcript show: '    Installation on Class ' , aClassName ,'>>', aSelector, ' OK'; cr.

	^self
]!

persistModel: theModel filter: theFilter

	| someResults someChunks |

	theModel isNil ifTrue: [ ^nil].
	theModel isModel ifFalse: [ ^nil].

	someChunks := theModel persistenceAsCodeStringChunksFilter: theFilter doSubChunks: true.
	someChunks isNil ifTrue: [ ^nil].

	someResults := someChunks collect: [:aChunk | self persistChunk: aChunk].
	^someResults!

sameSource: theSource elementMethod: theSelector inClass: theClassName

	| aClassAndMethod aSource aClass aMetaClass aStream aFullThisSource aRes |


	aClassAndMethod := self elementMethod: theSelector inClass: theClassName.
	((theSource isNil or: [ theSource isEmpty]) and: [  aClassAndMethod isNil]) ifTrue:  [ ^true].

	aClass := aClassAndMethod first.
	aMetaClass := aClass class.

	aSource := aMetaClass sourceCodeAt: theSelector ifAbsent: [ nil].
	((theSource isNil or: [ theSource isEmpty]) and: [  aSource isNil]) ifTrue:  [ ^true].
	aSource isNil ifTrue: [ ^false].

	aStream := WriteStream on: (String new: 1024 + aSource size).
	self intoStream: aStream sourceHeaderForElementMethod: theSelector inClass: theClassName.
	aStream nextPutAll: theSource.

	aFullThisSource := aStream contents.

	aRes := aFullThisSource asArrayOfSubstrings = aSource asArrayOfSubstrings.
	"| aS otherS |
	aS := aFullThisSource asArrayOfSubstrings.
	otherS  := aSource asArrayOfSubstrings.
	
((1 to: aS size) select: [:anI |  ((aS at: anI) = (otherS at: anI)) not]) collect: [:anI | Array with: (aS at: anI) with: (otherS at: anI)]"
	^aRes!

sourceHeaderForElementMethod: theSelector inClass: theClassName

	| aStream |
	aStream := WriteStream on: (String new: 1024).
	self intoStream: aStream sourceHeaderForElementMethod: theSelector inClass: theClassName.
	^aStream contents! !

!CODEMap class publicMethodsFor: 'accessing'!

kind
	^#map! !

!CODEMap class publicMethodsFor: 'navigation'!

defaultDefinitionsHolder
	^CODEMModelDefinitionsHolder forMapEditorSelectingFromSourceModel!

mapEditorSelectingFromSourceModelMETAPerspectives
	^self modelEditorMETAPerspectives!

mapEditorSelectingFromSourceModelMETASelectors

	| someMETASelectors someSubModulesMetaSelectors someMoreMETASelectors someSelectors |

	someMETASelectors := super modelEditorMETASelectors.
	someSubModulesMetaSelectors := self mapEditorSelectingFromSourceModelMETASelectorsSubModules.
	someMoreMETASelectors :=	self mapEditorSelectingFromSourceModelMETASelectorsMap.

	someSelectors := OrderedCollection new: someMETASelectors size + someMoreMETASelectors size.
	
	someMETASelectors do: [:aMETASelector |
		(someSubModulesMetaSelectors detect: [:aSMMS | 
			aSMMS name = aMETASelector name ] ifNone: [ nil]) isNil ifTrue: [ 
			someSelectors add: aMETASelector
		]
	].
	someSelectors addAll: someSubModulesMetaSelectors.
	someSelectors addAll: someMoreMETASelectors.
	^someSelectors!

mapEditorSelectingFromSourceModelMETASelectorsMap

	"METAChildSpecAutoViewEditor openOn: CODEMap selector: #modelEditorMETASelectorsMap target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ElementMaps';
			basicSelector: #elementMaps;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ElementMaps';
			displaySelector: #name;
			componentsClassName: #CODEElementMap;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			customAddSelector:  #elementMapsLinkCreateSelectingFromSourceModel;
			nlsApp: 'CODE';
			nlsGroup: 'Map_Selectors';
			nlsItem: 'ElementMaps';
			nlsTranslation: 'Correspondencias';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SourceModel';
			basicSelector: #sourceModel;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'SourceModel';
			displaySelector: #name;
			objectClassName: #CODEModel;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Map_Selectors';
			nlsItem: 'SourceModel';
			nlsTranslation: 'ModeloFuente';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ViewModel';
			basicSelector: #viewModel;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'ViewModel';
			displaySelector: #name;
			objectClassName: #CODEModel;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Map_Selectors';
			nlsItem: 'ViewModel';
			nlsTranslation: 'ModeloVista';
			yourself);
		yourself!

mapEditorSelectingFromSourceModelMETASelectorsSubModules

	"METAChildSpecAutoViewEditor openOn: CODEModule selector: #modelEditorMETASelectorsSubModules target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MapFolders';
			basicSelector: #subModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Folders';
			displaySelector: #name;
			componentsClassName: #CODEMapsFolder;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			customAddSelector:  #subModulesLinkCreateSelectingFromSourceModel;
			nlsApp: 'CODE';
			nlsGroup: 'Map_Selectors';
			nlsItem: 'MapFolders';
			nlsTranslation: 'CarpetasDeCorrespondencias';
			yourself);
		yourself!

mapEditorSelectingFromSourceModelPathSelectors
	^self modelEditorPathSelectors!

modelEditorMETAPerspectives

	^super modelEditorMETAPerspectives , self modelEditorMETAPerspectivesMap!

modelEditorMETAPerspectivesMap

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ElementMaps'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'ElementMaps' )))
			nlsApp: 'CODE';
			nlsGroup: 'Map_Perspectives';
			nlsItem: 'ElementMaps';
			nlsTranslation: 'Correspondencias';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'MapFolders'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('MapFolders' )))
			nlsApp: 'CODE';
			nlsGroup: 'Map_Perspectives';
			nlsItem: 'MapFolders';
			nlsTranslation: 'CarpetasDeCorrespondencias';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SourceModel'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('SourceModel' )))
			nlsApp: 'CODE';
			nlsGroup: 'Map_Perspectives';
			nlsItem: 'SourceModel';
			nlsTranslation: 'ModeloFuente';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ViewModel'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('ViewModel' )))
			nlsApp: 'CODE';
			nlsGroup: 'Map_Perspectives';
			nlsItem: 'ViewModel';
			nlsTranslation: 'ModeloVista';
			yourself);
		yourself!

modelEditorMETAPerspectivesSubModules

	^OrderedCollection new
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsMap!

modelEditorMETASelectorsMap

	"METAChildSpecAutoViewEditor openOn: CODEMap selector: #modelEditorMETASelectorsMap target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ElementMaps';
			basicSelector: #elementMaps;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ElementMaps';
			displaySelector: #name;
			componentsClassName: #CODEElementMap;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Map_Selectors';
			nlsItem: 'ElementMaps';
			nlsTranslation: 'Correspondencias';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SourceModel';
			basicSelector: #sourceModel;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'SourceModel';
			displaySelector: #name;
			objectClassName: #CODEModel;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Map_Selectors';
			nlsItem: 'SourceModel';
			nlsTranslation: 'ModeloFuente';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ViewModel';
			basicSelector: #viewModel;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'ViewModel';
			displaySelector: #name;
			objectClassName: #CODEModel;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Map_Selectors';
			nlsItem: 'ViewModel';
			nlsTranslation: 'ModeloVista';
			yourself);
		yourself!

modelEditorMETASelectorsSubModules

	"METAChildSpecAutoViewEditor openOn: CODEModule selector: #modelEditorMETASelectorsSubModules target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MapFolders';
			basicSelector: #subModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Folders';
			displaySelector: #name;
			componentsClassName: #CODEMapsFolder;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Map_Selectors';
			nlsItem: 'MapsFolders';
			nlsTranslation: 'CarpetasDeCorrespondencias';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsMap.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsMap

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #( 'ElementMaps' 'MapFolders' 'SourceModel' 'ViewModel' )!

modelEditorPathSelectorsModule

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #()! !

!CODEMap class publicMethodsFor: 'utils'!

scanElementMap: theElementMap forAllElementMapsWithSourceMetaInfo: theMetaInfo 

	| someElementMaps |

	theElementMap isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].

	someElementMaps := IdentitySet new: 37.

	self scanElementMap: theElementMap forAllElementMapsWithSourceMetaInfo: theMetaInfo  into: someElementMaps.
	^someElementMaps!

scanElementMap: theElementMap forAllElementMapsWithSourceMetaInfo: theMetaInfo  into: theElementMaps

	| someElementMaps |
	theElementMap isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].

	(theElementMap sourceElementsIncludes: theMetaInfo) ifTrue: [ 
		theElementMaps add: theElementMap
	].

	someElementMaps := theElementMap subElementMaps.
	(someElementMaps isNil or: [ someElementMaps isEmpty]) ifTrue: [ ^nil].
	
	someElementMaps do: [:anEM | 
		self scanElementMap: anEM forAllElementMapsWithSourceMetaInfo: theMetaInfo into: theElementMaps
	].!

scanElementMap: theElementMap forElementMapWithSourceMetaInfo: theMetaInfo 

	| anElementMap someElementMaps aFoundEM |
	theElementMap isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].

	someElementMaps := theElementMap subElementMaps.
	(someElementMaps isNil or: [ someElementMaps isEmpty]) ifTrue: [ ^nil].
	
	anElementMap := someElementMaps detect: [:anEM | anEM sourceElementsIncludes: theMetaInfo] ifNone: [ nil].
	anElementMap isNil ifFalse: [ ^anElementMap].

	aFoundEM := nil.
	someElementMaps detect: [:anEM |  
		aFoundEM := self scanElementMap: anEM forElementMapWithSourceMetaInfo: theMetaInfo .
		aFoundEM isNil not
	] ifNone: [ nil].
	aFoundEM isNil ifFalse: [ ^aFoundEM].

	
	^nil!

scanElementMap: theElementMap forElementMapWithViewMetaInfo: theMetaInfo

	| someElementMaps aFoundEM |
	theElementMap isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].

	(theElementMap viewElementsIncludes: theMetaInfo) ifTrue: [ ^theElementMap].

	someElementMaps := theElementMap subElementMaps.
	(someElementMaps isNil or: [ someElementMaps isEmpty]) ifTrue: [ ^nil].
	
	aFoundEM := nil.
	someElementMaps detect: [:anEM | 
		aFoundEM := self scanElementMap: anEM forElementMapWithViewMetaInfo: theMetaInfo.
		aFoundEM isNil not
	] ifNone: [ nil].
	^aFoundEM!

scanMapsFolder: theMapsFolder forAllElementMapsWithSourceMetaInfo: theMetaInfo

	| someElementMaps |
	theMapsFolder isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].
 
	someElementMaps := IdentitySet new: 37.

	self scanMapsFolder: theMapsFolder forAllElementMapsWithSourceMetaInfo: theMetaInfo  into: someElementMaps.
	^someElementMaps!

scanMapsFolder: theMapsFolder forAllElementMapsWithSourceMetaInfo: theMetaInfo into: theElementMaps

	| someElementMaps someMapsFolders |
	theMapsFolder isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].

	someElementMaps := theMapsFolder elementMaps.

	(someElementMaps isNil not and: [ someElementMaps isEmpty not]) ifTrue: [ 
		someElementMaps do: [:anElementMap |
			self scanElementMap: anElementMap forAllElementMapsWithSourceMetaInfo: theMetaInfo into: theElementMaps
		]
	].

	someMapsFolders := theMapsFolder subModules.
	(someMapsFolders isNil not and: [ someMapsFolders isEmpty not]) ifTrue: [ 
		someMapsFolders do: [:aMapsFolder |
			self scanMapsFolder: aMapsFolder forAllElementMapsWithSourceMetaInfo: theMetaInfo  into: theElementMaps
		]
	].!

scanMapsFolder: theMapsFolder forAllViewMetaInfosWithSourceMetaInfo: theMetaInfo

	| someAllElementMaps someAllViewMetaInfos  |
	theMapsFolder isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].
   
	someAllElementMaps := self scanMapsFolder: theMapsFolder forAllElementMapsWithSourceMetaInfo: theMetaInfo.

	someAllViewMetaInfos := IdentitySet new: (someAllElementMaps size * Float pi) floor.
	someAllElementMaps do: [:anElementMap |  | someViewMetaInfos  |
		someViewMetaInfos := anElementMap viewElements.
		(someViewMetaInfos isNil not and: [ someViewMetaInfos isEmpty not]) ifTrue: [ 
			someAllViewMetaInfos addAll: someViewMetaInfos
		]
	].
	
	^someAllViewMetaInfos asArray!

scanMapsFolder: theMapsFolder forElementMapWithSourceMetaInfo: theMetaInfo

| anElementMap someElementMaps aFoundEM someSubModules |
	theMapsFolder isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].

	someElementMaps := theMapsFolder elementMaps.
	(someElementMaps isNil or: [ someElementMaps isEmpty]) ifFalse: [ 
	
		anElementMap := someElementMaps detect: [:anEM | anEM sourceElementsIncludes: theMetaInfo] ifNone: [ nil].
		anElementMap isNil ifFalse: [ ^anElementMap].

		aFoundEM := nil.
		someElementMaps detect: [:anEM |  
			aFoundEM := self scanElementMap: anEM forElementMapWithSourceMetaInfo: theMetaInfo.
			aFoundEM isNil not
		] ifNone: [ nil].
		aFoundEM isNil ifFalse: [ ^aFoundEM]
	].
	
	aFoundEM := nil.
	someSubModules := theMapsFolder subModules.
	someSubModules detect: [:aSM | 
		aFoundEM := self scanMapsFolder: aSM forElementMapWithSourceMetaInfo: theMetaInfo.
		aFoundEM isNil not
	] ifNone: [ nil].
	aFoundEM isNil ifFalse: [ ^aFoundEM].
	
	^nil!

scanMapsFolder: theMapsFolder forElementMapWithViewMetaInfo: theMetaInfo

| someElementMaps aFoundEM someSubModules |

	theMapsFolder isNil ifTrue: [ ^nil].
	theMetaInfo isNil ifTrue: [ ^nil].
	

	someElementMaps := theMapsFolder elementMaps.
	(someElementMaps isNil or: [ someElementMaps isEmpty]) ifFalse: [ 
		someElementMaps detect: [:anEM |  
			aFoundEM := self scanElementMap: anEM forElementMapWithViewMetaInfo: theMetaInfo.
			aFoundEM isNil not
		] ifNone: [ nil].
		aFoundEM isNil ifFalse: [ ^aFoundEM]
	].
	
	aFoundEM := nil.
	someSubModules := theMapsFolder subModules.
	someSubModules detect: [:aSM | 
		aFoundEM := self scanMapsFolder: aSM forElementMapWithViewMetaInfo: theMetaInfo.
		aFoundEM isNil not
	] ifNone: [ nil].
	aFoundEM isNil ifFalse: [ ^aFoundEM].
	
	^nil! !

!CODEMap publicMethodsFor: 'accessing-private'!

forzeSourceModel: theModel
	sourceModel := theModel!

forzeViewModel: theModel
	viewModel := theModel! !

!CODEMap publicMethodsFor: 'association initialize-release'!

elementMapsRelease

	self elementMaps do: [:each | self elementMapsRemove: each]!

initElementMaps
	elementMaps := OrderedCollection new.!

sourceModelRelease
	sourceModel := nil.
	self changed: #sourceModel!

viewModelRelease
	viewModel := nil.
	self changed: #viewModel! !

!CODEMap publicMethodsFor: 'associations accessing'!

elementMaps

	^self elementMapsPrivate copy!

elementMapsAsArray

	^self elementMaps asArray!

sourceModel
	^sourceModel!

sourceModel: aValue
	(self checkSourceModel: aValue) ifFalse: [^aValue].
	sourceModel == aValue ifTrue: [ ^self].
	self sourceModelRelease.
	sourceModel := aValue.
	self changed: #sourceModel!

viewModel
	^viewModel!

viewModel: aValue
	(self checkSourceModel: aValue) ifFalse: [^aValue].
	viewModel == aValue ifTrue: [ ^self].
	self viewModelRelease.
	viewModel := aValue.
	self changed: #viewModel! !

!CODEMap publicMethodsFor: 'associations modifying'!

elementMapsAdd: aValue

	(self checkElementMapsAdd: aValue) ifFalse: [^aValue].
	(self elementMapsIncludes: aValue) ifTrue: [^self elementMapsMoveBottom: aValue].
	(self elementMapsPrivateAdd: aValue) mapsFolderPrivate: self.
	self changed: #elementMaps.
	^aValue!

elementMapsMoveBottom: aValue

	(self elementMapsIncludes: aValue) ifFalse: [^aValue].
	(self elementMaps indexOf: aValue) = self elementMapsSize ifTrue: [^aValue].
	self elementMapsPrivate remove: aValue.
	^self elementMapsPrivateAdd: aValue!

elementMapsMoveDown: aValue

	| index |
	(self elementMapsIncludes: aValue) ifFalse: [^aValue].
	(index := self elementMaps indexOf: aValue) = self elementMapsSize ifTrue: [^aValue].
	index = (self elementMapsSize -1)
		ifTrue:
			[self elementMapsPrivate remove: aValue.
			^self elementMapsPrivateAdd: aValue].
	^self elementMapsPrivateMove: aValue beforeIndex: index + 2!

elementMapsMoveTop: aValue

	(self elementMapsIncludes: aValue) ifFalse: [^aValue].
	(self elementMaps indexOf: aValue) = 1 ifTrue: [^aValue].
	self elementMapsPrivateMove: aValue beforeIndex: 1!

elementMapsMoveUp: aValue

	| index |
	(self elementMapsIncludes: aValue) ifFalse: [^aValue].
	(index := self elementMaps indexOf: aValue) = 1 ifTrue: [^aValue].
	^self elementMapsPrivateMove: aValue beforeIndex: index - 1!

elementMapsRemove: aValue

	(self checkElementMapsRemove: aValue) ifFalse: [^aValue].
	(self elementMapsPrivate remove: aValue ifAbsent: [^aValue]) mapsFolderPrivate: nil.
	self changed: #elementMaps.
	^aValue! !

!CODEMap publicMethodsFor: 'associations private'!

elementMapsPrivate

	elementMaps isNil
		ifTrue: [self initElementMaps].
	^elementMaps!

elementMapsPrivateAdd: aValue

	self elementMapsPrivate add: aValue.
	self markDirty.

	self changed: #elementMaps.
	^aValue!

elementMapsPrivateMove: aValue beforeIndex: anIndex

	| obj |
	obj := self elementMaps at: anIndex.
	self elementMapsPrivate remove: aValue.
	self elementMapsPrivate add: aValue before: obj.
	self markDirty.

	self changed: #elementMaps.
	^aValue!

elementMapsPrivateRemove: aValue

	self elementMapsPrivate remove: aValue.
	self markDirty.

	self changed: #elementMaps.
	^aValue!

sourceModelPrivate: aValue
	| |
	sourceModel := aValue.
	self markDirty.
	self changed: #sourceModel.!

viewModelPrivate: aValue
	viewModel := aValue.
	self markDirty.
	self changed: #viewModel.! !

!CODEMap publicMethodsFor: 'associations testing'!

elementMapsIncludes: aValue

	^elementMaps isNil
		ifTrue: [false]
		ifFalse: [self elementMaps includes: aValue]!

elementMapsSize

	^elementMaps isNil
		ifTrue: [0]
		 ifFalse: [elementMaps size]! !

!CODEMap publicMethodsFor: 'build from source'!

createNLSForElementMap: theElementMap  viewType: theViewType

"	Create NLS in the Maps translation for the new ElementMap using the ItemTranslation of the new View Type
"
	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMapTranslation aMapTranslationItem |

	theElementMap isNil ifTrue: [ ^nil].
	theViewType isNil ifTrue: [ ^nil].

	aViewModel := self viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := self sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aMapTranslation := self nlsSolver.
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].


	(aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap nameNLSGroupName 
		item: theElementMap nameNLSItemName) isNil ifTrue: [ 

		aMapTranslationItem := aMapTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewType nameNLSGroupName 
			item: theViewType nameNLSItemName.
		aMapTranslationItem isNil ifFalse: [

			aMapTranslation 
				recordNLSGroup: theElementMap nameNLSGroupName 
				item: theElementMap nameNLSItemName
				translation: '%1 (T)' copy.

			aNewTranslationItem := aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap  nameNLSGroupName
				item: theElementMap nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aMapTranslationItem
			]
		]
	].!

createNLSForMapsFolder: theMapsFolder  viewModule: theViewModule

"	Create NLS in the Maps translation for the new MapsFolder using the ItemTranslation of the new View Module
"
	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMapTranslation aMapTranslationItem |

	theMapsFolder isNil ifTrue: [ ^nil].
	theViewModule isNil ifTrue: [ ^nil].

	aViewModel := self viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := self sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aMapTranslation := self nlsSolver.
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].


	(aMapTranslation nlsLocalResolverItemGroupNoDefault: theMapsFolder nameNLSGroupName 
		item: theMapsFolder nameNLSItemName) isNil ifTrue: [ 

		aMapTranslationItem := aMapTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewModule nameNLSGroupName 
			item: theViewModule nameNLSItemName.
		aMapTranslationItem isNil ifFalse: [

			aMapTranslation 
				recordNLSGroup: theMapsFolder nameNLSGroupName 
				item: theMapsFolder nameNLSItemName.

			aNewTranslationItem := aMapTranslation nlsLocalResolverItemGroupNoDefault: theMapsFolder  nameNLSGroupName
				item: theMapsFolder nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aMapTranslationItem
			]
		]
	].!

createNLSForViewModule: theViewModule  sourceModule: theSourceModule

"	Create (if it does not exists yet)  a new NLS in the Translation of the View Model,
		using the ItemTranslation of the source Module in the Source Model
"

	| aViewModel aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem |
	theViewModule isNil ifTrue: [ ^nil].
	theSourceModule isNil ifTrue: [ ^nil].

	aViewModel := self viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := self sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].

	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule nameNLSGroupName 
		item: theViewModule nameNLSItemName) isNil ifTrue: [ 

		aSourceTranslationItem := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceModule nameNLSGroupName 
			item: theSourceModule nameNLSItemName.
		aSourceTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewModule nameNLSGroupName 
				item: theViewModule nameNLSItemName.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule  nameNLSGroupName
				item: theViewModule nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem
			]
		]
	].!

createNLSForViewType: theViewType  sourceType: theSourceType

"	Create (if it does not exists yet) a new NLS in the Translation of the View Model,
		using the ItemTranslation of the source Type in the Source Model
"

	| aViewModel aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem |
	theViewType isNil ifTrue: [ ^nil].
	theSourceType isNil ifTrue: [ ^nil].

	aViewModel := self viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := self sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].

	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewType nameNLSGroupName 
		item: theViewType nameNLSItemName) isNil ifTrue: [ 

		aSourceTranslationItem := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceType nameNLSGroupName 
			item: theSourceType nameNLSItemName.
		aSourceTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewType nameNLSGroupName 
				item: theViewType nameNLSItemName.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewType  nameNLSGroupName
				item: theViewType nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem
			]
		]
	].!

elementMapsLinkCreateSelectedSourceType
	| someCandidateTypes aSelectedType someSortedTypes someCandidateTypeLabels |


	someCandidateTypes := self elementMapsLinkCreateSourceModelCandidates.
 
	(someCandidateTypes isNil or: [ someCandidateTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not Source Types candidates as  Source for new ElementMap'.
		^self
	].

	someSortedTypes := someCandidateTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateTypeLabels := someSortedTypes collect: [:aType | 
		aType nlsName, ' 	(', aType name ,')' 
	].


	aSelectedType := Dialog 
		choose: ('Please, select a Type as Source for new ElementMap') withCRs
		fromList: someCandidateTypeLabels 
		values: someSortedTypes 
		lines: (((someSortedTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	
	^aSelectedType!

elementMapsLinkCreateSelectingFromSourceModel
"Create a View Module from a Source Module, into the top Map
	1 - Create new View Type
	2 - Add the new View Type to the View Model
	3 - Create new Element Map for the new View Type
	4 - Add the new ElementMap as elementMap of this Map
	5 - Create a new NLS in the Translation of the View Model, for the new Type
		using the ItemTranslation of the source Type in the Source Model
	6 - Create NLS in the Maps translation for the new ElementMap
		using the ItemTranslation of the new View Type
"
	| aSelectedType aViewModel aNewViewType aNewElementMap aNewMapLogic |


	aViewModel := self viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSelectedType := self elementMapsLinkCreateSelectedSourceType.
	aSelectedType isNil ifTrue: [ ^nil].

"	1 - Create new View Type
"
	aNewViewType := self preferredTypeClass new.
	aNewViewType name: aSelectedType name copy.
	aNewViewType isAbstract: aSelectedType isAbstract == true.
	aNewViewType isEnumeration: aSelectedType isEnumeration == true.
	aNewViewType isPrimitive: aSelectedType isPrimitive == true.


"	2 - Add the new View Type to the View Model
"
	aViewModel typesAdd: aNewViewType.


"	3 - Create new Element Map for the new View Type
"
	aNewElementMap := self preferredElementMapClass new.
	aNewElementMap name: aSelectedType name copy.
	aNewElementMap sourceElementsAdd: aSelectedType.
	aNewElementMap viewElementsAdd: aNewViewType.

	aNewMapLogic := self preferredMapLogicClass new.
	aNewMapLogic name: aNewMapLogic class mapModeTypeSymbol asString.
	aNewMapLogic mapMode: aNewMapLogic class mapModeTypeSymbol.

	aNewElementMap mapLogic: aNewMapLogic.


"	4 - Add the new ElementMap as elementMap of this Map
"
	self elementMapsAdd: aNewElementMap.


"	5 - Create a new NLS in the Translation of the View Model, for the new Type
		using the ItemTranslation of the source Type in the Source Model
"

	self createNLSForViewType: aNewViewType  sourceType: aSelectedType.


"	6 - Create NLS in the Maps translation for the new ElementMap
		using the ItemTranslation of the new View Type
"
	self createNLSForElementMap: aNewElementMap  viewType: aNewViewType.

	aNewViewType changed: #name.
	aNewElementMap changed: #name!

elementMapsLinkCreateSourceModelCandidates
	| aSourceModel aSomeSourceTypes someElementMaps someTypes aViewModel someMapsFolders |

	aSourceModel := self sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewModel := self viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSomeSourceTypes := aSourceModel allTypes.
	(aSomeSourceTypes isNil or: [ aSomeSourceTypes isEmpty]) ifTrue: [ ^nil].

	someTypes := aSomeSourceTypes copy.
	someElementMaps := self elementMaps.
	(someElementMaps isNil not and: [ someElementMaps isEmpty not]) ifTrue: [ 
		someElementMaps do: [:anElementMap |  | someElementSourceTypes  |
			someElementSourceTypes := anElementMap allSourceTypes.
			(someElementSourceTypes isNil not and: [ someElementSourceTypes isEmpty not]) ifTrue: [ 
				someTypes removeAll: someElementSourceTypes
			]
		]
	].

	someMapsFolders := self subModules.
	(someMapsFolders isNil not and: [ someMapsFolders isEmpty not]) ifTrue: [ 
		someMapsFolders do: [:aMapFolder |  | someElementSourceTypes  |
			someElementSourceTypes := aMapFolder allSourceTypes.
			(someElementSourceTypes isNil not and: [ someElementSourceTypes isEmpty not]) ifTrue: [ 
				someTypes removeAll: someElementSourceTypes
			]
		]
	].

	^someTypes!

subModulesLinkCreateSelectedSourceModule
	| someCandidateModules aSelectedModule someCandidateModuleLabels someSortedModules |

	someCandidateModules := self subModulesLinkCreateSourceModelCandidates.

	(someCandidateModules isNil or: [ someCandidateModules isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not Source Modules candidates as  Source for new MapsFolder'.
		^self
	].

	someSortedModules := someCandidateModules asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateModuleLabels := someSortedModules collect: [:aModule | 
		aModule nlsName, ' 	(', aModule name ,')' 
	].
	
	aSelectedModule := Dialog 
		choose: ('Please, select a Module as Source for new ElementMap') withCRs
		fromList: someCandidateModuleLabels 
		values: someSortedModules 
		lines: (((someSortedModules size + 1) max: 5) min: 18)
		cancel: [nil].

	^aSelectedModule!

subModulesLinkCreateSelectingFromSourceModel
"Create a View Module from a Source Module, into the top Map
	1 - Create new View Module
	2 - Add the new View Module to the View Model
	3 - Create new MapsFolder for the new View Module
	4 - Add the new MapsFolder as subModule of this Map
	5 - Create a new NLS in the Translation of the View Model, for the new View Module,
		using the ItemTranslation of the source Module in the Source Model
	6 - Create NLS in the Maps translation,  for the new MapsFolder,
		using the ItemTranslation of the new View Module
"

	| aSourceModel aViewModel aSelectedModule aNewMapsFolder aNewViewModule |

	aSourceModel := self sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewModel := self viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSelectedModule := self subModulesLinkCreateSelectedSourceModule.
	aSelectedModule isNil ifTrue: [ ^nil].

"	1 - Create new View Module
"
	aNewViewModule := self preferredViewModuleClass new.
	aNewViewModule name: aSelectedModule name copy.


"	2 - Add the new View Module to the View Model
"
	aViewModel subModulesAdd: aNewViewModule.


"	3 - Create new MapsFolder for the new View Module
"
	aNewMapsFolder := self preferredMapsFolderClass new.
	aNewMapsFolder name: aSelectedModule name copy.


"	4 - Add the new MapsFolder as subModule of this Map
"
	self subModulesAdd: aNewMapsFolder.


"	5 - Create a new NLS in the Translation of the View Model, for the new View Module,
		using the ItemTranslation of the source Module in the Source Model
"
	self createNLSForViewModule: aNewViewModule  sourceModule: aSelectedModule.


"	6 - Create NLS in the Maps translation,  for the new MapsFolder,
		using the ItemTranslation of the new View Module
"
	self createNLSForMapsFolder: aNewMapsFolder  viewModule: aNewViewModule.

	aNewViewModule changed: #name.
	aNewMapsFolder changed: #name!

subModulesLinkCreateSourceModelCandidates
	| aSourceModel aSomeSourceModules someModules aSomeExistingMapFolderNames |

	aSourceModel := self sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aSomeSourceModules := aSourceModel allModules.
	(aSomeSourceModules isNil or: [ aSomeSourceModules isEmpty]) ifTrue: [ ^nil].

	someModules := aSomeSourceModules copy.
	
	aSomeExistingMapFolderNames := self allFullyQualifiedMapFolderNames.
	(aSomeExistingMapFolderNames isNil not and: [ aSomeExistingMapFolderNames isEmpty not]) ifTrue: [ 
		aSomeExistingMapFolderNames do: [:aMapFolderFullyQualifiedName |    | aFoundModule |
			aFoundModule := someModules detect: [:aModule | aModule fullyQualifiedName = aMapFolderFullyQualifiedName] ifNone:[nil].
			aFoundModule isNil ifFalse: [
				someModules remove: aFoundModule
			]
		]
	].

	^someModules! !

!CODEMap publicMethodsFor: 'derived accessing'!

allFullyQualifiedMapFolderNames

	| someNames |
	someNames := OrderedCollection new: 8.

	self allFullyQualifiedMapFolderNamesInto: someNames.

	^someNames!

allFullyQualifiedMapFolderNamesInto: theNames

	| someMapsFolders |
	someMapsFolders := self subModules.

	(someMapsFolders isNil or: [ someMapsFolders isEmpty]) ifTrue: [ ^self].

	someMapsFolders do: [:aMapFolder |
		theNames add: aMapFolder fullyQualifiedName.
		aMapFolder allFullyQualifiedMapFolderNamesInto: theNames 
	].! !

!CODEMap publicMethodsFor: 'dirty'!

persistIfDirty
	| aViewModel |
	super persistIfDirty.

	aViewModel := self viewModel.
	aViewModel isNil ifFalse: [ aViewModel persistIfDirty].! !

!CODEMap publicMethodsFor: 'initialize-release'!

release

	self changed: #objectDisconnectedOfTree.

	self sourceModelRelease.
	self viewModelRelease.
	self elementMapsRelease.

	super release! !

!CODEMap publicMethodsFor: 'persistence-code'!

bindToReferencedModels
	
	self bindToReferencedSourceModel.
	self bindToReferencedViewModel.
	self rebindToModels!

bindToReferencedSourceModel
	
	| aModel |

	(sourceModelRefTmpValues isNil or: [ sourceModelRefTmpValues isEmpty]) ifTrue: [ ^nil].
	
	aModel := CODEElement resolveReferencedModelFromPersistenceAsCodeOrCurrent:  sourceModelRefTmpValues.

	aModel isNil ifFalse: [  self forzeSourceModel: aModel] .

	sourceModelRefTmpValues := nil!

bindToReferencedViewModel
	
	| aModel |

	(viewModelRefTmpValues isNil or: [ viewModelRefTmpValues isEmpty]) ifTrue: [ ^nil].
	
	aModel := CODEElement resolveReferencedModelFromPersistenceAsCodeOrCurrent:  viewModelRefTmpValues.

	aModel isNil ifFalse: [  self forzeViewModel: aModel] .

	viewModelRefTmpValues := nil!

bindToSourceModel: theSourceModel viewModel: theViewModel
	
	self forzeSourceModel: theSourceModel.
	self forzeViewModel: theViewModel.

	self rebindToModels!

elementMapsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self elementMapsPrivate isNil not and: [ self elementMapsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class elementMapsPersistenceSymbol); cr
			].
			self elementMapsPrivate do:  [:aRel |
				aRel persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

firstPersistenceIndexMap
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		self numberPersistenceEntriesModule  +
		self numberPersistenceEntriesModel  +
		1!

initElementMapsFromValues: theValues 
	
	| someElementMaps |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someElementMaps := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someElementMaps isNil ifFalse: [ 
		self elementMapsPrivate addAll: someElementMaps.
		someElementMaps do: [:aEM | aEM mapsFolderPrivate: self]]!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	aFPI := self firstPersistenceIndexMap.

	super initFromValues: theValues.

	theValues size < aFPI ifFalse: [ self initElementMapsFromValues: (theValues at: aFPI)].

	theValues size < (aFPI + 1) ifFalse: [ self initReferencedSourceModelFromValues: (theValues at: (aFPI + 1))].

	theValues size < (aFPI + 2) ifFalse: [ self initReferencedViewModelFromValues: (theValues at: (aFPI + 2))].!

initReferencedSourceModelFromValues: theValues

	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refToModelMethodKind ifFalse: [ ^nil].

	sourceModelRefTmpValues := theValues.!

initReferencedViewModelFromValues: theValues

	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refToModelMethodKind ifFalse: [ ^nil].

	viewModelRefTmpValues := theValues.!

localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| anIS aSep aSourceModel aViewModel |
	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	self elementMapsPersistenceAsCodeStringOn: theStream indent: theIS.

	aSourceModel := self sourceModel.
	aSourceModel isNil  
		ifTrue: [ theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil); cr] 
		ifFalse: [ aSourceModel persistenceRefToMethodAsCodeStringOn: theStream indent: anIS].

	aViewModel := self viewModel.
	aViewModel isNil  
		ifTrue: [ theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil); cr] 
		ifFalse: [ aViewModel persistenceRefToMethodAsCodeStringOn: theStream indent: anIS].!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep aSourceModel aViewModel |
	theStream isNil ifTrue: [ ^self]. 
self halt: 'Well, this seems to be used ..., see by whom ...'.
	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	self elementMapsPersistenceAsCodeStringOn: theStream indent: theIS.

	aSourceModel := self sourceModel.
	aSourceModel isNil  
		ifTrue: [ theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil); cr] 
		ifFalse: [ aSourceModel persistenceRefToMethodAsCodeStringOn: theStream indent: anIS].

	aViewModel := self viewModel.
	aViewModel isNil  
		ifTrue: [ theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil); cr] 
		ifFalse: [ aViewModel persistenceRefToMethodAsCodeStringOn: theStream indent: anIS].!

numberPersistenceEntriesMap
	^3!

persistenceRefToMethodAsCodeStringOn: theStream indent: theIS

	| aSep |
	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
		
	theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self class refToMapMethodKind);  
		nextPutAll: aSep; nextPutAll: self name printString;  
		nextPutAll: aSep; nextPutAll: (self pcForV: self storeMethodSelector); nextPutAll: aSep; nextPutAll: (self pcForV: self storeClassName);  
		nextPutAll: ' )' ; cr; cr.!

rebindToModels
	
	self elementMapsPrivate do: [:anElementMap | anElementMap rebindToModelsFromSolver: self].
	self subModulesPrivate do: [:aMapsFolder | aMapsFolder rebindToModelsFromSolver: self].!

unbindFromModels
	
	self elementMapsPrivate do: [:anElementMap | anElementMap unbindFromModels].
	self subModulesPrivate do: [:aMapsFolder | aMapsFolder unbindFromModels].

	self forzeSourceModel: nil.
	self forzeViewModel: nil.! !

!CODEMap publicMethodsFor: 'preferences'!

preferredElementMapClass
	^self class preferredElementMapClass!

preferredMapsFolderClass
	^self class preferredMapsFolderClass!

preferredModuleClass
	^self  preferredMapsFolderClass!

preferredViewModuleClass
	^super  preferredModuleClass! !

!CODEMap publicMethodsFor: 'semantic checking'!

checkElementMapsAdd: aValue

	^true!

checkElementMapsRemove: aValue

	^true!

checkSourceModel: aValue

	^true!

checkViewModel: aValue

	^true! !

!CODEMap publicMethodsFor: 'semantic links'!

elementMapsCandidates

	^self elementMaps asArray!

elementMapsCreate

	^CODEType new!

elementMapsLinkCreate

	| anObject |

	anObject := self elementMapsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self elementMapsAdd: anObject]!

elementMapsLinkSelect

	| anObject |

	anObject := RTObjectServer new
		selectIn: self elementMapsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self elementMapsAdd: anObject.!

elementMapsLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self elementMapsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self elementMapsCreate class
		ifUnchanged: [^self].
	self elementMapsAdd: anObject!

elementMapsScope

	^nil!

sourceModelCreate

	^CODEModel new!

sourceModelLinkCreate

	| anObject |

	anObject := self sourceModelCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self sourceModel: anObject]!

sourceModelLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self sourceModelCandidates
		initially: self sourceModel
		label: 'Select Or Create ...'
		class: self sourceModelCreate class
		ifUnchanged: [^self].
	self sourceModel: anObject!

sourceModelLinkSelects
	| someTypes aSelectedType |

	someTypes := self superTypesCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as SuperType of Type\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a name < b name].

	aSelectedType := Dialog 
		choose: ('			Please, select a Type as SuperType of Type			\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType displayName ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	self superTypesAdd: aSelectedType.

	^aSelectedType!

sourceModelScope

	^nil!

viewModelCreate

	^CODEModel new!

viewModelLinkCreate

	| anObject |

	anObject := self viewModelCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self viewModel: anObject]!

viewModelLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self viewModelCandidates
		initially: self viewModel
		label: 'Select Or Create ...'
		class: self viewModelCreate class
		ifUnchanged: [^self].
	self viewModel: anObject!

viewModelScope

	^nil! !

!CODEMap publicMethodsFor: 'semantic links-custom'!

sourceModelCandidates

	^CODEModel allModelsInSystem!

sourceModelLinkSelect
	| someModels aSelectedModel aViewModel |

	someModels := self sourceModelCandidates.
	(someModels isNil or: [ someModels isEmpty]) ifTrue: [ 
		Dialog warn: 'No Models in System candidate as SourceModel of Map\' withCRs, self name.
		^nil
	].

	someModels := someModels asSortedCollection: [:a :b | a name < b name].

	aSelectedModel := Dialog 
		choose: ('	Please, select a Model as SourceModel of Map		\	', self name) withCRs
		fromList: (someModels collect: [:aModel | 
			Object errorSignal
				handle: [:anException | anException returnWith: aModel name]
				do: [ aModel displayName ]]) 
		values: someModels 
		lines: (((someModels size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedModel isNil ifTrue: [ ^nil].

	aViewModel := self sourceModel.
	self unbindFromModels.
	self sourceModel: aSelectedModel.
	self forzeViewModel: aViewModel.
	self rebindToModels.

	^aSelectedModel!

viewModelCandidates

	^CODEModel allModelsInSystem!

viewModelLinkSelect
	| someModels aSelectedModel aSourceModel |

	someModels := self viewModelCandidates.
	(someModels isNil or: [ someModels isEmpty]) ifTrue: [ 
		Dialog warn: 'No Models in System candidate as ViewModel of Map\' withCRs, self name.
		^nil
	].

	someModels := someModels asSortedCollection: [:a :b | a name < b name].

	aSelectedModel := Dialog 
		choose: ('	Please, select a Model as ViewModel of Map		\	', self name) withCRs
		fromList: (someModels collect: [:aModel | 
			Object errorSignal
				handle: [:anException | anException returnWith: aModel name]
				do: [ aModel displayName ]]) 
		values: someModels 
		lines: (((someModels size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedModel isNil ifTrue: [ ^nil].

	aSourceModel := self sourceModel.
	self unbindFromModels.
	self viewModel: aSelectedModel.
	self forzeSourceModel: aSourceModel.
	self rebindToModels.

	^aSelectedModel! !

!CODEMap publicMethodsFor: 'testing'!

isMap
	^true! !

!CODEMap publicMethodsFor: 'utils'!

prePopulateFromViewAttribute: theAttribute inElementMap: theElementMap
	
	| anElementMap aMapLogic |

	theAttribute isNil ifTrue: [ ^self].
	theElementMap isNil ifTrue: [ ^self].

	anElementMap := self preferredElementMapClass new.
	anElementMap name: theAttribute name.
	anElementMap viewElementsAdd: theAttribute.

	theElementMap subElementMapsAdd: anElementMap.

	aMapLogic := self preferredMapLogicClass new.
	aMapLogic name: aMapLogic class mapModeAttributeSymbol asString.
	aMapLogic mapMode: aMapLogic class mapModeAttributeSymbol.

	anElementMap mapLogic: aMapLogic.!

prePopulateFromViewModel
	
	| aViewModel |
	aViewModel := self viewModel.
	aViewModel isNil ifTrue: [ ^self].

	self prePopulateNoCreateMapsFolder: self fromViewModule: aViewModel!

prePopulateFromViewModule: theModule inMapsFolder: theMapsFolder
	
	| aMapsFolder |
	theModule isNil ifTrue: [ ^self].

	aMapsFolder := self preferredMapsFolderClass new.
	aMapsFolder name: theModule name.

	theMapsFolder isNil ifFalse: [  theMapsFolder subModulesAdd: aMapsFolder].

	self prePopulateNoCreateMapsFolder: aMapsFolder fromViewModule: theModule!

prePopulateFromViewRelationship: theRelationship inElementMap: theElementMap
	
	| anElementMap aMapLogic |

	theRelationship isNil ifTrue: [ ^self].
	theElementMap isNil ifTrue: [ ^self].

	anElementMap := self preferredElementMapClass new.
	anElementMap name: theRelationship name.
	anElementMap viewElementsAdd: theRelationship.

	theElementMap subElementMapsAdd: anElementMap.

	aMapLogic := self preferredMapLogicClass new.
	aMapLogic name: aMapLogic class mapModeRelationshipSymbol asString.
	aMapLogic mapMode: aMapLogic class mapModeRelationshipSymbol.

	anElementMap mapLogic: aMapLogic.!

prePopulateFromViewType: theType  inMapsFolder: theMapsFolder
	
	| anElementMap aMapLogic someAttributes someRelationships |
	theType isNil ifTrue: [ ^self].
 
	anElementMap := self preferredElementMapClass new.
	anElementMap name: theType name.
	anElementMap viewElementsAdd: theType.

	theMapsFolder isNil ifFalse: [  theMapsFolder elementMapsAdd: anElementMap].

	aMapLogic := self preferredMapLogicClass new.
	aMapLogic name: aMapLogic class mapModeTypeSymbol asString.
	aMapLogic mapMode: aMapLogic class mapModeTypeSymbol.

	anElementMap mapLogic: aMapLogic.

	someAttributes := theType attributes.
	someAttributes do: [:anAttribute | self prePopulateFromViewAttribute: anAttribute inElementMap: anElementMap].

	someRelationships := theType relationships.
	someRelationships do: [:aRelationship | self prePopulateFromViewRelationship: aRelationship inElementMap: anElementMap].!

prePopulateNoCreateMapsFolder: theMapsFolder fromViewModule: theModule
	
	| someModules someTypes |
	theModule isNil ifTrue: [ ^self].

	someTypes := theModule types.
	someTypes do: [:aType | self prePopulateFromViewType: aType inMapsFolder: theMapsFolder].

	someModules := theModule subModules.
	someModules do: [:aModule | self prePopulateFromViewModule: aModule inMapsFolder: theMapsFolder].! !

!CODEMapLogic class publicMethodsFor: 'accessing'!

kind
	^#mapLogic! !

!CODEMapLogic class publicMethodsFor: 'constants'!

mapModeAttributeSymbol
	^#ATTRIBUTE!

mapModeRelationshipSymbol
	^#RELATIONSHIP!

mapModeSymbols
	^Array 
		with: self mapModeTypeSymbol
		with: self mapModeAttributeSymbol
		with: self mapModeRelationshipSymbol
		with: self mapModeUnknownSymbol!

mapModeTypeSymbol
	^#TYPE!

mapModeUnknownSymbol
	^#UNKNOWN!

mapModeVoidRelationshipSymbol
	^#voidmapRELATIONSHIP! !

!CODEMapLogic class publicMethodsFor: 'navigation'!

mapEditorSelectingFromSourceModelMETAPerspectives
	^self modelEditorMETAPerspectives!

mapEditorSelectingFromSourceModelMETASelectors
	^self modelEditorMETASelectors!

mapEditorSelectingFromSourceModelPathSelectors
	^self modelEditorPathSelectors!

modelEditorMETAPerspectives

	^super modelEditorMETAPerspectives, self modelEditorMETAPerspectivesMapLogic!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'IsDirty' 'MapMode')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesMapLogic

	^OrderedCollection new
		addLast:  ((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ElementMap'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'ElementMap' )));
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsMapLogic!

modelEditorMETASelectorsMapLogic

	"METAChildSpecAutoViewEditor openOn: CODEMapLogic selector: #modelEditorMETASelectorsMapLogic target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MapMode';
			basicSelector: #mapMode;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MapMode';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: 'TYPE RELATIONSHIP ATTRIBUTE';
			nlsApp: 'CODE';
			nlsGroup: 'MapLogic_Selectors';
			nlsItem: 'MapMode';
			nlsTranslation: 'ModoDeCorrespondencia';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ElementMap';
			basicSelector: #elementMap;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ElementMap';
			displaySelector: nil;
			objectClassName: #CODEElementMap;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'MapLogic_Selectors';
			nlsItem: 'ElementMap';
			nlsTranslation: 'Correspondencia';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsMapLogic.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsMapLogic

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('ElementMap' )! !

!CODEMapLogic publicMethodsFor: 'accessing'!

mapMode
	mapMode isNil
		ifTrue: [self initMapMode].
	^mapMode!

mapMode: aValue
	(self checkMapMode: aValue) ifFalse: [^aValue].
	mapMode := aValue.
	self markDirty.
	self changed: #mapMode! !

!CODEMapLogic publicMethodsFor: 'accessing-private'!

forzeMapMode: theMapMode
	mapMode := theMapMode isNil ifTrue:  [ nil] ifFalse: [ theMapMode asSymbol]! !

!CODEMapLogic publicMethodsFor: 'association initialize-release'!

elementMapRelease

	| |
	elementMap == nil
		ifFalse:
			[ elementMap := nil.
			self release.
				]! !

!CODEMapLogic publicMethodsFor: 'associations accessing'!

elementMap

	^elementMap!

elementMap: aValue

	(self checkElementMap: aValue) ifFalse: [^aValue].
	elementMap == aValue ifTrue: [ ^self].
	self elementMapRelease.
	elementMap := aValue.
	aValue == nil ifFalse: [aValue mapLogic: self].
	self changed: #elementMap! !

!CODEMapLogic publicMethodsFor: 'associations private'!

elementMapPrivate: aValue
	| aPrevValue |
	aPrevValue := elementMap.
	elementMap := aValue.
	(elementMap isNil and: [aPrevValue isNil not]) ifTrue: [ self release].
	self changed: #elementMap.! !

!CODEMapLogic publicMethodsFor: 'derived accessing'!

applicationConfiguration
	^self elementMap isNil 
		ifFalse: [ self elementMap applicationConfiguration]
		ifTrue: [nil]!

map
	^self model!

model
	^self elementMap isNil 
		ifFalse: [ self elementMap model]
		ifTrue: [nil]!

module
	^self elementMap isNil 
		ifFalse: [ self elementMap module]
		ifTrue: [nil]! !

!CODEMapLogic publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self elementMap isNil  ifFalse: [ self elementMap markDirtyOwner]].!

persistIfDirty
	^self elementMap isNil ifFalse: [ self elementMap persistIfDirty] ifTrue: [ nil]! !

!CODEMapLogic publicMethodsFor: 'initialize-release'!

initMapMode
	mapMode := self class mapModeUnknownSymbol!

release

	self changed: #objectDisconnectedOfTree.

	self elementMapRelease.

	super release! !

!CODEMapLogic publicMethodsFor: 'persistence-code'!

firstPersistenceIndexMapLogic
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexMapLogic.

	self forzeMapMode:	 			(theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]).!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS |
	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  mapMode ); cr.!

numberPersistenceEntriesMapLogic
	^1! !

!CODEMapLogic publicMethodsFor: 'semantic checking'!

checkElementMap: aValue

	^true!

checkMapMode: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEMapLogic publicMethodsFor: 'semantic links'!

elementMapCandidates

	^self elementMap isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self elementMap]!

elementMapCreate

	^nil!

elementMapLinkCreate

	| anObject |

	anObject := self elementMapCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self elementMap: anObject]!

elementMapLinkSelect

	| anObject |

	anObject := RTObjectServer new
		selectIn: self elementMapCandidates
		initially: self elementMap
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self elementMap: anObject.!

elementMapLinkSelectOrCreate

	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self elementMapCandidates
		initially: self elementMap
		label: 'Select Or Create ...'
		class: self elementMapCreate class
		ifUnchanged: [^self].
	self elementMap: anObject!

elementMapScope

	^nil! !

!CODEMapLogic publicMethodsFor: 'semantic links-custom'!

sourceElementsAttributeCandidates
	
	| anElementMap aSuperElementMap someSourceTypes someAttributes |

	self mapMode = self class mapModeAttributeSymbol ifFalse: [ ^nil ].

	anElementMap := self elementMap.
	anElementMap isNil ifTrue: [ ^nil].

	aSuperElementMap := anElementMap superElementMap.
	aSuperElementMap isNil ifTrue: [ ^nil].

	someSourceTypes := aSuperElementMap sourceElements.
	someSourceTypes isNil ifTrue: [ ^nil].

	someAttributes := IdentitySet new: someSourceTypes size * 3 + 1.
	someSourceTypes do: [:aType | someAttributes addAll: aType allEffectiveAttributes].
		
	^someAttributes!

sourceElementsAttributeLinkSelect

| anElementMap aSuperElementMap someAttributes aSelectedAttribute |

	self mapMode = self class mapModeAttributeSymbol ifFalse: [ ^nil ].

	anElementMap := self elementMap.
	anElementMap isNil ifTrue: [ 
		Dialog warn: 'MapLogic has no ElementMap to which to assign SourceElements' , self kind, '\' withCRs.
		^nil
	].

	aSuperElementMap := anElementMap superElementMap.
	aSuperElementMap isNil ifTrue: [ 
		Dialog warn: 'ElementMap with MapLogic mapMode = ATTRIBUTE must be a subElementMap of\'  withCRs, 
			'an ElementMap with MapLogic mapMode = TYPE'.
		^nil
	].


	someAttributes := self sourceElementsAttributeCandidates.
	(someAttributes isNil or: [ someAttributes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Attributes in SourceModel are candidate as SourceElement of ' , self mapMode, '\' withCRs, anElementMap name.
		^nil
	].

	someAttributes := someAttributes asSortedCollection: [:a :b | a name < b name].

	aSelectedAttribute := Dialog 
		choose: ('	Please, select an Attribute as SourceElement of ', self mapMode, '\' withCRs, anElementMap name) withCRs
		fromList: (someAttributes collect: [:aAttribute | 
			Object errorSignal
				handle: [:anException | anException returnWith: aAttribute name]
				do: [ aAttribute displayName ]]) 
		values: someAttributes 
		lines: (((someAttributes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedAttribute isNil ifTrue: [ ^nil].

	anElementMap sourceElementsAdd: aSelectedAttribute.

	^aSelectedAttribute!

sourceElementsLinkSelect

	| aMapMode |

	aMapMode := self mapMode.

	aMapMode = self class mapModeTypeSymbol ifTrue: [ ^self sourceElementsTypeLinkSelect ].
	aMapMode = self class mapModeAttributeSymbol ifTrue: [ ^self sourceElementsAttributeLinkSelect ].
	aMapMode = self class mapModeRelationshipSymbol ifTrue: [ ^self sourceElementsRelationshipLinkSelect ].

	Dialog warn: 'Can not assign SourceElements with MapLogic mapMode ', aMapMode printString.
	^nil!

sourceElementsRelationshipCandidates
	
	| anElementMap aSuperElementMap someSourceTypes someRelationships |

	self mapMode = self class mapModeRelationshipSymbol ifFalse: [ ^nil ].

	anElementMap := self elementMap.
	anElementMap isNil ifTrue: [ ^nil].

	aSuperElementMap := anElementMap superElementMap.
	aSuperElementMap isNil ifTrue: [ ^nil].

	someSourceTypes := aSuperElementMap sourceElements.
	someSourceTypes isNil ifTrue: [ ^nil].

	someRelationships := IdentitySet new: someSourceTypes size * 3 + 1.
	someSourceTypes do: [:aType | someRelationships addAll: aType allRelationships].
		
	^someRelationships!

sourceElementsRelationshipLinkSelect

| anElementMap aSuperElementMap someRelationships aSelectedRelationship |

	self mapMode = self class mapModeRelationshipSymbol ifFalse: [ ^nil ].

	anElementMap := self elementMap.
	anElementMap isNil ifTrue: [ 
		Dialog warn: 'MapLogic has no ElementMap to which to assign SourceElements' , self kind, '\' withCRs.
		^nil
	].

	aSuperElementMap := anElementMap superElementMap.
	aSuperElementMap isNil ifTrue: [ 
		Dialog warn: 'ElementMap with MapLogic mapMode = ATTRIBUTE must be a subElementMap of\'  withCRs, 
			'an ElementMap with MapLogic mapMode = TYPE'.
		^nil
	].


	someRelationships := self sourceElementsRelationshipCandidates.
	(someRelationships isNil or: [ someRelationships isEmpty]) ifTrue: [ 
		Dialog warn: 'No Relationships in SourceModel are candidate as SourceElement of ' , self mapMode, '\' withCRs, anElementMap name.
		^nil
	].

	someRelationships := someRelationships asSortedCollection: [:a :b | a name < b name].

	aSelectedRelationship := Dialog 
		choose: ('	Please, select an Relationship as SourceElement of ', self mapMode, '\' withCRs, anElementMap name) withCRs
		fromList: (someRelationships collect: [:aRelationship | 
			Object errorSignal
				handle: [:anException | anException returnWith: aRelationship name]
				do: [ aRelationship displayName ]]) 
		values: someRelationships 
		lines: (((someRelationships size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedRelationship isNil ifTrue: [ ^nil].

	anElementMap sourceElementsAdd: aSelectedRelationship.

	^aSelectedRelationship!

sourceElementsTypeCandidates
	
	| aMap aSourceModel someTypes |

	aMap := self model.
	aMap isNil ifTrue: [ ^nil].
	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	someTypes := aSourceModel allTypes.
	^someTypes!

sourceElementsTypeLinkSelect

| anElementMap someTypes aSelectedType |

	self mapMode = self class mapModeTypeSymbol ifFalse: [ ^nil ].

	anElementMap := self elementMap.
	anElementMap isNil ifTrue: [ 
		Dialog warn: 'MapLogic has no ElementMap to which to assign SourceElements' , self kind, '\' withCRs.
		^nil
	].

	someTypes := self sourceElementsTypeCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in SourceModel are candidate as SourceElement of ' , self kind, '\' withCRs, anElementMap name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a name < b name].

	aSelectedType := Dialog 
		choose: ('	Please, select a Type as SourceElement of \', anElementMap name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType displayName ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	anElementMap sourceElementsAdd: aSelectedType.

	^aSelectedType! !

!CODEMapsFolder class publicMethodsFor: 'accessing'!

kind
	^#mapsFolder! !

!CODEMapsFolder class publicMethodsFor: 'navigation'!

mapEditorSelectingFromSourceModelMETAPerspectives
	^self modelEditorMETAPerspectives!

mapEditorSelectingFromSourceModelMETASelectors

	| someMETASelectors someSubModulesMetaSelectors someMoreMETASelectors someSelectors |

	someMETASelectors := super modelEditorMETASelectors.
	someSubModulesMetaSelectors := self mapEditorSelectingFromSourceModelMETASelectorsSubModules.
	someMoreMETASelectors :=	self mapEditorSelectingFromSourceModelMETASelectorsMapsFolder.

	someSelectors := OrderedCollection new: someMETASelectors size + someMoreMETASelectors size.
	
	someMETASelectors do: [:aMETASelector |
		(someSubModulesMetaSelectors detect: [:aSMMS | 
			aSMMS name = aMETASelector name ] ifNone: [ nil]) isNil ifTrue: [ 
			someSelectors add: aMETASelector
		]
	].
	someSelectors addAll: someSubModulesMetaSelectors.
	someSelectors addAll: someMoreMETASelectors.
	^someSelectors!

mapEditorSelectingFromSourceModelMETASelectorsMapsFolder

	"METAChildSpecAutoViewEditor openOn: CODEMapsFolder selector: #modelEditorMETASelectorsMapsFolder target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ElementMaps';
			basicSelector: #elementMaps;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ElementMaps';
			displaySelector: #name;
			componentsClassName: #CODEElementMap;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			customAddSelector:  #elementMapsLinkCreateSelectingFromSourceModel;
			nlsApp: 'CODE';
			nlsGroup: 'MapsFolder_Selectors';
			nlsItem: 'ElementMaps';
			nlsTranslation: 'Correspondencias';
			yourself);
		yourself!

mapEditorSelectingFromSourceModelMETASelectorsSubModules

	"METAChildSpecAutoViewEditor openOn: CODEModule selector: #modelEditorMETASelectorsSubModules target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubMapsFolders';
			basicSelector: #subModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubMapsFolders';
			displaySelector: #name;
			componentsClassName: #CODEMapsFolder;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			customAddSelector:  #subModulesLinkCreateSelectingFromSourceModel;
			nlsApp: 'CODE';
			nlsGroup: 'MapsFolder_Selectors';
			nlsItem: 'SubMapsFolders';
			nlsTranslation: 'SubCarpetasDeCorrespondencias';
			yourself);
		yourself!

mapEditorSelectingFromSourceModelPathSelectors
	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #mapEditorSelectingFromSourceModelMETASelectors;
		pathSelectorsSelector: #mapEditorSelectingFromSourceModelPathSelectors;
		metaSelectorsToSelect: #('ElementMaps' 'SubMapsFolders' 'ItemTranslations')!

modelEditorMETAPerspectives

	^super modelEditorMETAPerspectives, self modelEditorMETAPerspectivesMapsFolder,
		self modelEditorMETAPerspectivesTranslation!

modelEditorMETAPerspectivesMapsFolder

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ElementMaps'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'ElementMaps')))
			nlsApp: 'CODE';
			nlsGroup: 'MapsFolder_Perspectives';
			nlsItem: 'ElementMaps';
			nlsTranslation: 'Correspondencias';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SubMapsFolders'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('SubMapsFolders' )))
			nlsApp: 'CODE';
			nlsGroup: 'Map_Perspectives';
			nlsItem: 'SubMapsFolders';
			nlsTranslation: 'CarpetasDeCorrespondencias';
			yourself);
		yourself!

modelEditorMETAPerspectivesSubModules

	^OrderedCollection new
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsMapsFolder!

modelEditorMETASelectorsMapsFolder

	"METAChildSpecAutoViewEditor openOn: CODEMapsFolder selector: #modelEditorMETASelectorsMapsFolder target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ElementMaps';
			basicSelector: #elementMaps;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ElementMaps';
			displaySelector: #name;
			componentsClassName: #CODEElementMap;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'MapsFolder_Selectors';
			nlsItem: 'ElementMaps';
			nlsTranslation: 'Correspondencias';
			yourself);
		yourself!

modelEditorMETASelectorsSubModules

	"METAChildSpecAutoViewEditor openOn: CODEModule selector: #modelEditorMETASelectorsSubModules target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubMapsFolders';
			basicSelector: #subModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Folders';
			displaySelector: #name;
			componentsClassName: #CODEMapsFolder;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'MapsFolder_Selectors';
			nlsItem: 'SubMapsFolders';
			nlsTranslation: 'SubCarpetasDeCorrespondencias';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsMapsFolder.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsMapsFolder

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('ElementMaps' 'SubMapsFolders')!

modelEditorPathSelectorsModule

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #()! !

!CODEMapsFolder publicMethodsFor: 'association initialize-release'!

elementMapsRelease
	"Generated by ISF/AD. Do not modify"
	self elementMaps do: [:each | self elementMapsRemove: each]!

initElementMaps
	elementMaps := OrderedCollection new.! !

!CODEMapsFolder publicMethodsFor: 'associations accessing'!

elementMaps
	"Generated by ISF/AD. Do not modify"
	^self elementMapsPrivate copy!

elementMapsAsArray
	"Generated by ISF/AD. Do not modify"
	^self elementMaps asArray! !

!CODEMapsFolder publicMethodsFor: 'associations modifying'!

elementMapsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkElementMapsAdd: aValue) ifFalse: [^aValue].
	(self elementMapsIncludes: aValue) ifTrue: [^self elementMapsMoveBottom: aValue].
	(self elementMapsPrivateAdd: aValue) mapsFolderPrivate: self.
	self changed: #elementMaps.
	^aValue!

elementMapsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	(self elementMapsIncludes: aValue) ifFalse: [^aValue].
	(self elementMaps indexOf: aValue) = self elementMapsSize ifTrue: [^aValue].
	self elementMapsPrivate remove: aValue.
	^self elementMapsPrivateAdd: aValue!

elementMapsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self elementMapsIncludes: aValue) ifFalse: [^aValue].
	(index := self elementMaps indexOf: aValue) = self elementMapsSize ifTrue: [^aValue].
	index = (self elementMapsSize -1)
		ifTrue:
			[self elementMapsPrivate remove: aValue.
			^self elementMapsPrivateAdd: aValue].
	^self elementMapsPrivateMove: aValue beforeIndex: index + 2!

elementMapsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self elementMapsIncludes: aValue) ifFalse: [^aValue].
	(self elementMaps indexOf: aValue) = 1 ifTrue: [^aValue].
	self elementMapsPrivateMove: aValue beforeIndex: 1!

elementMapsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self elementMapsIncludes: aValue) ifFalse: [^aValue].
	(index := self elementMaps indexOf: aValue) = 1 ifTrue: [^aValue].
	^self elementMapsPrivateMove: aValue beforeIndex: index - 1!

elementMapsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkElementMapsRemove: aValue) ifFalse: [^aValue].
	(self elementMapsPrivate remove: aValue ifAbsent: [^aValue]) mapsFolderPrivate: nil.
	self changed: #elementMaps.
	^aValue! !

!CODEMapsFolder publicMethodsFor: 'associations private'!

elementMapsPrivate
	"Generated by ISF/AD. Do not modify"
	elementMaps isNil
		ifTrue: [self initElementMaps].
	^elementMaps!

elementMapsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self elementMapsPrivate add: aValue.
	self markDirty.

	self changed: #elementMaps.
	^aValue!

elementMapsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self elementMaps at: anIndex.
	self elementMapsPrivate remove: aValue.
	self elementMapsPrivate add: aValue before: obj.
	self markDirty.

	self changed: #elementMaps.
	^aValue!

elementMapsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self elementMapsPrivate remove: aValue.
	self markDirty.

	self changed: #elementMaps.
	^aValue! !

!CODEMapsFolder publicMethodsFor: 'associations testing'!

elementMapsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^elementMaps isNil
		ifTrue: [false]
		ifFalse: [self elementMaps includes: aValue]!

elementMapsSize
	"Generated by ISF/AD. Do not modify"
	^elementMaps isNil
		ifTrue: [0]
		 ifFalse: [elementMaps size]! !

!CODEMapsFolder publicMethodsFor: 'build from source'!

createNLSForElementMap: theElementMap  viewType: theViewType

"	Create NLS in the Maps translation for the new ElementMap using the ItemTranslation of the new View Type
"
	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMapTranslation aMapTranslationItem aMap |

	theElementMap isNil ifTrue: [ ^nil].
	theViewType isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aMapTranslation := aMap nlsSolver.
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].


	(aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap nameNLSGroupName 
		item: theElementMap nameNLSItemName) isNil ifTrue: [ 

		aMapTranslationItem := aMapTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewType nameNLSGroupName 
			item: theViewType nameNLSItemName.
		aMapTranslationItem isNil ifFalse: [

			aMapTranslation 
				recordNLSGroup: theElementMap nameNLSGroupName 
				item: theElementMap nameNLSItemName
				translation: '%1 (T)' copy.

			aNewTranslationItem := aMapTranslation nlsLocalResolverItemGroupNoDefault: theElementMap  nameNLSGroupName
				item: theElementMap nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aMapTranslationItem
			]
		]
	].!

createNLSForMapsFolder: theMapsFolder  viewModule: theViewModule

"	Create NLS in the Maps translation for the new MapsFolder using the ItemTranslation of the new View Module
"
	| aViewModel aSourceModel aViewTranslation aNewTranslationItem aMapTranslation aMapTranslationItem aMap |

	theMapsFolder isNil ifTrue: [ ^nil].
	theViewModule isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aMapTranslation := aMap nlsSolver.
	(aMapTranslation isNil or: [ aMapTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aMapTranslation hasOrInheritsSuperApplicationTranslation: aViewTranslation) ifFalse: [ ^nil].


	(aMapTranslation nlsLocalResolverItemGroupNoDefault: theMapsFolder nameNLSGroupName 
		item: theMapsFolder nameNLSItemName) isNil ifTrue: [ 

		aMapTranslationItem := aMapTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theViewModule nameNLSGroupName 
			item: theViewModule nameNLSItemName.
		aMapTranslationItem isNil ifFalse: [

			aMapTranslation 
				recordNLSGroup: theMapsFolder nameNLSGroupName 
				item: theMapsFolder nameNLSItemName.

			aNewTranslationItem := aMapTranslation nlsLocalResolverItemGroupNoDefault: theMapsFolder  nameNLSGroupName
				item: theMapsFolder nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aMapTranslationItem
			]
		]
	].!

createNLSForViewModule: theViewModule  sourceModule: theSourceModule

"	Create (if it does not exists yet)  a new NLS in the Translation of the View Model,
		using the ItemTranslation of the source Module in the Source Model
"

	| aViewModel aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem aMap |
	theViewModule isNil ifTrue: [ ^nil].
	theSourceModule isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].

	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule nameNLSGroupName 
		item: theViewModule nameNLSItemName) isNil ifTrue: [ 

		aSourceTranslationItem := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceModule nameNLSGroupName 
			item: theSourceModule nameNLSItemName.
		aSourceTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewModule nameNLSGroupName 
				item: theViewModule nameNLSItemName.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewModule  nameNLSGroupName
				item: theViewModule nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem
			]
		]
	].!

createNLSForViewType: theViewType  sourceType: theSourceType

"	Create (if it does not exists yet)  a new NLS in the Translation of the View Model,
		using the ItemTranslation of the source Type in the Source Model
"

	| aViewModel aSourceModel aViewTranslation aSourceTranslation aSourceTranslationItem aNewTranslationItem aMap |

	theViewType isNil ifTrue: [ ^nil].
	theSourceType isNil ifTrue: [ ^nil].

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewTranslation := aViewModel nlsSolver.
	(aViewTranslation isNil or: [ aViewTranslation isVoidTranslation]) ifTrue: [ ^nil].

	aSourceTranslation := aSourceModel nlsSolver.
	(aSourceTranslation isNil or: [ aSourceTranslation isVoidTranslation]) ifTrue: [ ^nil].

	(aViewTranslation hasOrInheritsSuperApplicationTranslation: aSourceTranslation) ifFalse: [ ^nil].

	(aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewType nameNLSGroupName 
		item: theViewType nameNLSItemName) isNil ifTrue: [ 

		aSourceTranslationItem := aViewTranslation superApplicationTranslation 
			nlsFirstResolverItemGroupNoDefault: theSourceType nameNLSGroupName 
			item: theSourceType nameNLSItemName.
		aSourceTranslationItem isNil ifFalse: [

			aViewTranslation 
				recordNLSGroup: theViewType nameNLSGroupName 
				item: theViewType nameNLSItemName.

			aNewTranslationItem := aViewTranslation nlsLocalResolverItemGroupNoDefault: theViewType  nameNLSGroupName
				item: theViewType nameNLSItemName.
			aNewTranslationItem isNil ifFalse: [
				aNewTranslationItem usedItemTranslationsAdd: aSourceTranslationItem
			]
		]
	].!

elementMapsLinkCreateSelectedSourceType
	| someCandidateTypes aSelectedType someSortedTypes someCandidateTypeLabels |


	someCandidateTypes := self elementMapsLinkCreateSourceModelCandidates.
 
	(someCandidateTypes isNil or: [ someCandidateTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not Source Types candidates as  Source for new ElementMap'.
		^self
	].

	someSortedTypes := someCandidateTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateTypeLabels := someSortedTypes collect: [:aType | 
		aType nlsName, ' 	(', aType name ,')' 
	].


	aSelectedType := Dialog 
		choose: ('Please, select a Type as Source for new ElementMap') withCRs
		fromList: someCandidateTypeLabels 
		values: someSortedTypes 
		lines: (((someSortedTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	
	^aSelectedType!

elementMapsLinkCreateSelectingFromSourceModel
"Create a View Module from a Source Module, into the top Map
	1 - Create new View Type
	2 - Add the new View Type to the View Model
		as type of the view Module corresponding to this MapsFolder, 
		or if the MapsFolder has not a corresponding view Module (?), 
		then add the new view Type to the root view Model
	3 - Create new Element Map for the new View Type
	4 - Add the new ElementMap as elementMap of this MapsFolder
	5 - Create a new NLS in the Translation of the View Model, for the new Type
		using the ItemTranslation of the source Type in the Source Model
	6 - Create NLS in the Maps translation for the new ElementMap
		using the ItemTranslation of the new View Type
"
	| aSelectedType aViewModel aNewViewType aNewElementMap aNewMapLogic aMap aFullyQualifiedNameArray aViewModule |


	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSelectedType := self elementMapsLinkCreateSelectedSourceType.
	aSelectedType isNil ifTrue: [ ^nil].

"	1 - Create new View Type
"
	aNewViewType := self preferredTypeClass new.
	aNewViewType name: aSelectedType name copy.
	aNewViewType isAbstract: aSelectedType isAbstract == true.
	aNewViewType isEnumeration: aSelectedType isEnumeration == true.
	aNewViewType isPrimitive: aSelectedType isPrimitive == true.


"	2 - Add the new View Type to the View Model
		as type of the view Module corresponding to this MapsFolder, 
		or if the MapsFolder has not a corresponding view Module (?), 
		then add the new view Type to the root view Model
"

	aFullyQualifiedNameArray := self fullyQualifiedNameArray.
	aViewModule := aViewModel moduleNamedArray: aFullyQualifiedNameArray.
	aViewModule isNil ifTrue: [ aViewModule := aViewModel].

	aViewModule typesAdd: aNewViewType.


"	3 - Create new Element Map for the new View Type
"
	aNewElementMap := self preferredElementMapClass new.
	aNewElementMap name: aSelectedType name copy.
	aNewElementMap sourceElementsAdd: aSelectedType.
	aNewElementMap viewElementsAdd: aNewViewType.

	aNewMapLogic := self preferredMapLogicClass new.
	aNewMapLogic name: aNewMapLogic class mapModeTypeSymbol asString.
	aNewMapLogic mapMode: aNewMapLogic class mapModeTypeSymbol.

	aNewElementMap mapLogic: aNewMapLogic.


"	4 - Add the new ElementMap as elementMap of this Map
"
	self elementMapsAdd: aNewElementMap.


"	5 - Create a new NLS in the Translation of the View Model, for the new Type
		using the ItemTranslation of the source Type in the Source Model
"

	self createNLSForViewType: aNewViewType  sourceType: aSelectedType.


"	6 - Create NLS in the Maps translation for the new ElementMap
		using the ItemTranslation of the new View Type
"
	self createNLSForElementMap: aNewElementMap  viewType: aNewViewType.

	aNewViewType changed: #name.
	aNewElementMap changed: #name!

elementMapsLinkCreateSourceModelCandidates
	| aSourceModel aSomeSourceTypes someElementMaps someTypes aViewModel someMapsFolders aMap |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSomeSourceTypes := aSourceModel allTypes.
	(aSomeSourceTypes isNil or: [ aSomeSourceTypes isEmpty]) ifTrue: [ ^nil].

	someTypes := aSomeSourceTypes copy.
	someElementMaps := self elementMaps.
	(someElementMaps isNil not and: [ someElementMaps isEmpty not]) ifTrue: [ 
		someElementMaps do: [:anElementMap |  | someElementSourceTypes  |
			someElementSourceTypes := anElementMap allSourceTypes.
			(someElementSourceTypes isNil not and: [ someElementSourceTypes isEmpty not]) ifTrue: [ 
				someTypes removeAll: someElementSourceTypes
			]
		]
	].

	someMapsFolders := self subModules.
	(someMapsFolders isNil not and: [ someMapsFolders isEmpty not]) ifTrue: [ 
		someMapsFolders do: [:aMapFolder |  | someElementSourceTypes  |
			someElementSourceTypes := aMapFolder allSourceTypes.
			(someElementSourceTypes isNil not and: [ someElementSourceTypes isEmpty not]) ifTrue: [ 
				someTypes removeAll: someElementSourceTypes
			]
		]
	].

	^someTypes!

subModulesLinkCreateSelectedSourceModule
	| someCandidateModules aSelectedModule someCandidateModuleLabels someSortedModules |

	someCandidateModules := self subModulesLinkCreateSourceModelCandidates.

	(someCandidateModules isNil or: [ someCandidateModules isEmpty]) ifTrue: [ 
		Dialog warn: 'There are not Source Modules candidates as  Source for new MapsFolder'.
		^self
	].

	someSortedModules := someCandidateModules asSortedCollection: [:a :b | a nlsName < b nlsName].

	someCandidateModuleLabels := someSortedModules collect: [:aModule | 
		aModule nlsName, ' 	(', aModule name ,')' 
	].
	
	aSelectedModule := Dialog 
		choose: ('Please, select a Module as Source for new ElementMap') withCRs
		fromList: someCandidateModuleLabels 
		values: someSortedModules 
		lines: (((someSortedModules size + 1) max: 5) min: 18)
		cancel: [nil].

	^aSelectedModule!

subModulesLinkCreateSelectingFromSourceModel
"Create a View Module from a Source Module, into the top Map
	1 - Create new View Module
	2 - Add the new View Module to the View Model
		as subModule of the view Module corresponding to this MapsFolder, 
		or if the MapsFolder has not a corresponding view Module (?), 
		then add the new view Module to the root view Model
	3 - Create new MapsFolder for the new View Module
	4 - Add the new MapsFolder as subModule of this MapsFolder
	5 - Create a new NLS in the Translation of the View Model, for the new View Module,
		using the ItemTranslation of the source Module in the Source Model
	6 - Create NLS in the Maps translation,  for the new MapsFolder,
		using the ItemTranslation of the new View Module
"

	| aSourceModel aViewModel aSelectedModule aNewMapsFolder aNewViewModule aMap aViewModule aFullyQualifiedNameArray |


	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aViewModel := aMap viewModel.
	aViewModel isNil ifTrue: [ ^nil].

	aSelectedModule := self subModulesLinkCreateSelectedSourceModule.
	aSelectedModule isNil ifTrue: [ ^nil].

"	1 - Create new View Module
"
	aNewViewModule := self preferredViewModuleClass new.
	aNewViewModule name: aSelectedModule name copy.


"	2 - Add the new View Module to the View Model
		as subModule of the view Module corresponding to this MapsFolder, 
		or if the MapsFolder has not a corresponding view Module (?), 
		then add the new view Module to the root view Model
"

	aFullyQualifiedNameArray := self fullyQualifiedNameArray.
	aViewModule := aViewModel moduleNamedArray: aFullyQualifiedNameArray.
	aViewModule isNil ifTrue: [ aViewModule := aViewModel].

	aViewModule subModulesAdd: aNewViewModule.


"	3 - Create new MapsFolder for the new View Module
"
	aNewMapsFolder := self preferredMapsFolderClass new.
	aNewMapsFolder name: aSelectedModule name copy.


"	4 - Add the new MapsFolder as subModule of this MapsFolder
"
	self subModulesAdd: aNewMapsFolder.


"	5 - Create a new NLS in the Translation of the View Model, for the new View Module,
		using the ItemTranslation of the source Module in the Source Model
"
	self createNLSForViewModule: aNewViewModule  sourceModule: aSelectedModule.


"	6 - Create NLS in the Maps translation,  for the new MapsFolder,
		using the ItemTranslation of the new View Module
"
	self createNLSForMapsFolder: aNewMapsFolder  viewModule: aNewViewModule.

	aNewViewModule changed: #name.
	aNewMapsFolder changed: #name!

subModulesLinkCreateSourceModelCandidates
	| aSourceModel aSomeSourceModules someModules aSomeExistingMapFolderNames aMap |

	aMap := self map.
	aMap isNil ifTrue: [ ^nil].

	aSourceModel := aMap sourceModel.
	aSourceModel isNil ifTrue: [ ^nil].

	aSomeSourceModules := aSourceModel allModules.
	(aSomeSourceModules isNil or: [ aSomeSourceModules isEmpty]) ifTrue: [ ^nil].

	someModules := aSomeSourceModules copy.
	
	aSomeExistingMapFolderNames := self allFullyQualifiedMapFolderNames.
	(aSomeExistingMapFolderNames isNil not and: [ aSomeExistingMapFolderNames isEmpty not]) ifTrue: [ 
		aSomeExistingMapFolderNames do: [:aMapFolderFullyQualifiedName |    | aFoundModule |
			aFoundModule := someModules detect: [:aModule | aModule fullyQualifiedName = aMapFolderFullyQualifiedName] ifNone:[nil].
			aFoundModule isNil ifFalse: [
				someModules remove: aFoundModule
			]
		]
	].

	^someModules! !

!CODEMapsFolder publicMethodsFor: 'derived accessing'!

allFullyQualifiedMapFolderNames

	| someNames |
	someNames := OrderedCollection new: 8.

	self allFullyQualifiedMapFolderNamesInto: someNames.

	^someNames!

allFullyQualifiedMapFolderNamesInto: theNames

	| someMapsFolders |
	someMapsFolders := self subModules.

	(someMapsFolders isNil or: [ someMapsFolders isEmpty]) ifTrue: [ ^self].

	someMapsFolders do: [:aMapFolder |
		theNames add: aMapFolder fullyQualifiedName.
		aMapFolder allFullyQualifiedMapFolderNamesInto: theNames 
	].!

allSourceTypes
	| someTypes |
	someTypes := IdentitySet new: 13.
	self allSourceTypesInto: someTypes.
	^someTypes!

allSourceTypesInto: theTypes
	| someElementMaps someSubModules |
	someElementMaps := self elementMaps.
	(someElementMaps isNil or: [ someElementMaps isEmpty]) ifTrue: [ ^self].

	someElementMaps do: [:anElementMap |
		anElementMap allSourceTypesInto: theTypes
	].

	someSubModules := self subModules.
	(someSubModules isNil or: [ someSubModules isEmpty]) ifTrue: [ ^self].
	someSubModules do: [:aSubModule |
		aSubModule allSourceTypesInto: theTypes
	].!

map
	^self model! !

!CODEMapsFolder publicMethodsFor: 'initialize-release'!

release

	self changed: #objectDisconnectedOfTree.

	self elementMapsRelease.

	super release! !

!CODEMapsFolder publicMethodsFor: 'nls'!

nameNLSGroupName
	| aGroupName |
	aGroupName := self fullyQualifiedName, self class mapsFolderNameNLSGroupNamePostfix.
	^aGroupName!

nameNLSItemName
	| aItemName |
	aItemName := self name, self class mapsFolderNameNLSItemNamePostfix.
	^aItemName! !

!CODEMapsFolder publicMethodsFor: 'persistence-code'!

elementMapsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self elementMapsPrivate isNil not and: [ self elementMapsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class elementMapsPersistenceSymbol); cr
			].
			self elementMapsPrivate do:  [:aRel |
				aRel persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

firstPersistenceIndexMapsFolder
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		self numberPersistenceEntriesModule  +
		1!

initElementMapsFromValues: theValues 
	
	| someElementMaps |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someElementMaps := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someElementMaps isNil ifFalse: [ 
		self elementMapsPrivate addAll: someElementMaps.
		someElementMaps do: [:aEM | aEM mapsFolderPrivate: self]]!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexMapsFolder.

	theValues size < aFPI ifFalse: [ self initElementMapsFromValues: (theValues at: aFPI)].!

localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	self elementMapsPersistenceAsCodeStringOn: theStream indent: theIS.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 
self halt: 'Well, this seems to be used ..., see by whom ...'.
	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	self elementMapsPersistenceAsCodeStringOn: theStream indent: theIS.!

numberPersistenceEntriesMapsFolder
	^1!

persistenceRefToMethodAsCodeStringOn: theStream indent: theIS

	| aSep |
	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
		
	theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self class refToMapsFolderMethodKind);  
		nextPutAll: aSep; nextPutAll: self name printString;  
		nextPutAll: aSep; nextPutAll: (self pcForV: self storeMethodSelector); nextPutAll: aSep; nextPutAll: (self pcForV: self storeClassName);  
		nextPutAll: ' )' ; cr; cr.!

rebindToModelsFromSolver: theSolver
	
	self elementMapsPrivate do: [:anElementMap | anElementMap rebindToModelsFromSolver: theSolver].
	self subModulesPrivate do: [:aMapsFolder | aMapsFolder rebindToModelsFromSolver: theSolver].!

unbindFromModels
	
	self elementMapsPrivate do: [:anElementMap | anElementMap unbindFromModels].
	self subModulesPrivate do: [:aMapsFolder | aMapsFolder unbindFromModels].! !

!CODEMapsFolder publicMethodsFor: 'preferences'!

preferredModuleClass
	^self  preferredMapsFolderClass!

preferredViewModuleClass
	^super preferredModuleClass! !

!CODEMapsFolder publicMethodsFor: 'semantic checking'!

checkElementMapsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkElementMapsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEMapsFolder publicMethodsFor: 'semantic links'!

elementMapsCandidates
	"Generated by ISF/AD. Do not modify"
	^self elementMaps asArray!

elementMapsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

elementMapsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self elementMapsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self elementMapsAdd: anObject]!

elementMapsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self elementMapsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self elementMapsAdd: anObject.!

elementMapsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self elementMapsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self elementMapsCreate class
		ifUnchanged: [^self].
	self elementMapsAdd: anObject!

elementMapsScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEModel class publicMethodsFor: 'accessing'!

kind
	^#model! !

!CODEModel class publicMethodsFor: 'aspects'!

aspectToGenerateBrowser
	^'aspectToGenerateBrowser' copy!

aspectToGenerateMetamodelElements
	^'aspectToGenerateMetamodelElements' copy! !

!CODEModel class publicMethodsFor: 'examples'!

browseExample1
	"CODEModels browseExample1"

	METAScopedApplicationBrowser openForObject: CODEModel example1!

browseExample2
	"CODEModels browseExample2"

	METAScopedApplicationBrowser openForObject: CODEModel example2!

browseExample3
	"CODEModels browseExample3"

	METAScopedApplicationBrowser openForObject: CODEModel example3!

browseExample4
	"CODEModels browseExample4"

	METAScopedApplicationBrowser openForObject: CODEModel example4!

browseExample5
	"CODEModels browseExample5"

	METAScopedApplicationBrowser openForObject: CODEModel example5!

browseExample6
	"CODEModels browseExample6"

	METAScopedApplicationBrowser openForObject: CODEModel example6!

browseExample7
	"CODEModels browseExample7"

	METAScopedApplicationBrowser openForObject: CODEModel example7!

browseExampleBBU01
	"CODEModel  browseExampleBBU01"

	METAScopedApplicationBrowser openForObject: CODEModel exampleBBU01!

browseExampleCx01
	"CODEModels browseExampleCx01"

	METAScopedApplicationBrowser openForObject: CODEModel exampleCx01!

browseExampleCx01Browser
	"CODEModels browseExampleCx01Browser"

	METAScopedApplicationBrowser openForObject: CODEModel exampleCx01Browser!

browseExampleCxEdoc01
	"CODEModels browseExampleCxEdoc01"

	METAScopedApplicationBrowser openForObject: CODEModel exampleCxEdoc01!

browseExampleCxEdoc01Browser
	"CODEModels browseExampleCxEdoc01Browser"

	METAScopedApplicationBrowser openForObject: CODEModel exampleCxEdoc01Browser!

browseExampleEAIDynamic01
	"CODEModels browseExampleEAIDynamic01"

	METAScopedApplicationBrowser openForObject: CODEModel exampleEAIDynamic01!

browseExampleKit01
	"CODEModel  browseExampleKit01"

	METAScopedApplicationBrowser openForObject: CODEModel exampleKit01!

browseExampleKit01Browser
	"CODEModels browseExampleKit01Browser"

	METAScopedApplicationBrowser openForObject: CODEModel exampleKit01Browser!

browseExampleM3
	"CODEModels browseExampleM3"

	METAScopedApplicationBrowser openForObject: CODEModel exampleM3!

browseExampleM3Dynamic02
	"CODEModels browseExampleM3Dynamic02"

	METAScopedApplicationBrowser openForObject: CODEModel exampleM3Dynamic02!

browseExampleM3Model
	"CODEModels browseExampleM3Model"

	METAScopedApplicationBrowser openForObject: CODEModel exampleM3Model!

browseExampleMall01
	"CODEModel  browseExampleMall01"

	METAScopedApplicationBrowser openForObject: CODEModel exampleMall01!

browseExampleMall01Browser
	"CODEModels browseExampleMall01Browser"

	METAScopedApplicationBrowser openForObject: CODEModel exampleMall01Browser!

browseExampleProtoware01
	"CODEModel  browseExampleProtoware01"

	METAScopedApplicationBrowser openForObject: CODEModel exampleProtoware01!

browseExampleProtoware01Browser
	"CODEModels browseExampleProtoware01Browser"

	METAScopedApplicationBrowser openForObject: CODEModel exampleProtoware01Browser!

browseExampleRepostoryStore
	"CODEModel browseExampleRepostoryStore"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleRepostoryStore!

browseExampleSondaUseCases01
	"CODEModel  browseExampleSondaUseCases01"

	METAScopedApplicationBrowser openForObject: CODEModel exampleSondaUseCases01!

browseExampleSondaUseCases01Browser
	"CODEModels browseExampleSondaUseCases01Browser"

	METAScopedApplicationBrowser openForObject: CODEModel exampleSondaUseCases01Browser!

customPathBrowseExampleKit01
	"CODEModel customPathBrowseExampleKit01"

	CODEMModelPathFinderGenericBrowser openForObject: CODEModel exampleKit01!

example1
	"CODEModel example1"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'EAIMetamodel'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.eai.studio.metamodel'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'EAIMetamodelGenerated01Gen.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodelGenerated01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodelGenerated01\mySrc'.
	aModel typePrefix: 'EAI'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\EAIMM01.cdl'.
	^aModel!

example1CDLSource
^'//---------------------------------------------------------
// CDL Generated based on pending OMG UML to CDL specification (0.3)
// Source Model: Q:\BXS\EAI\Studio\EAIMetamodel01\docs\EAIMM01.mdl
// Generated CDL specification: Q:\BXS\EAI\Studio\EAIMetamodel01\docs\EAIMM01.cdl
// On 12/7/99 
//---------------------------------------------------------
#include <BocaFramework.cdl>
// Forward References
// Logical View
	type Project;
	type Package;
	type Process;
	type DocumentType;
	type Document;
	type Collaborator;
	type CollaboratorType;
	type Reception;
	type Machine;
	type DocumentElement;
	type DocumentFeature;
	type EmbeddedDocument;
	type Structure;
	type DocumentElementContainer;
	type TransformationType;
	type Factory;
	type State;
	type Transition;
	type Action;
	type Expression;
	type Active;
	type MachineAction;
	type ExpressionAction;
	type InterfaceType;
	type ClientType;
	type Send;
	type InputType;
	type OutputType;
	type Transformation;
	type Input;
	type Output;
	type MMElement;
//---------------------------------------------------------
// Specification
// Logical View
	type Project : MMElement {
		relationship package Aggregates 0..* Package inverse project ;
	}; // End: Project
	type Package : MMElement {
		relationship project IsPartOf 1..1 Project inverse package ;
		relationship superPackage References 0..1 Package inverse subPackage ;
		relationship subPackage Many 0..* Package inverse superPackage ;
		relationship processes Aggregates 0..* Process inverse package ;
		relationship collaboratorTypes Aggregates 0..* CollaboratorType inverse package ;
		relationship transformationTypes Aggregates 0..* TransformationType inverse package ;
		relationship documentTypes Aggregates 0..* DocumentType inverse package ;
	}; // End: Package
	type Process : MMElement {
		relationship behavior Aggregates 1..1 Machine inverse process ;
		relationship factory Aggregates 1..1 Factory inverse process ;
		relationship collaborators Aggregates 0..* Collaborator inverse process ;
		relationship clientType Aggregates 1..1 ClientType inverse process ;
		relationship documents Aggregates 0..* Document inverse process ;
		relationship package IsPartOf 1..1 Package inverse processes ;
	}; // End: Process
	type DocumentType : DocumentElementContainer {
		relationship documents Many 0..* Document inverse documentType ;
		relationship package IsPartOf 1..1 Package inverse documentTypes ;
		relationship typeOfInput Many 0..* InputType inverse documentType ;
		relationship typeOfOutput Many 0..* OutputType inverse documentType ;
		relationship embeddedDocuments Many 0..* EmbeddedDocument inverse documentType ;
		relationship triggerOf Many 0..* Transition inverse trigger ;
		relationship triggerOfFactories Many 0..* Factory inverse trigger ;
		relationship receivedInReceptions Many 0..* Reception inverse receive ;
		relationship resultInReceptions Many 0..* Reception inverse results ;
	}; // End: DocumentType
	type Document : MMElement {
		relationship process IsPartOf 1..1 Process inverse documents ;
		relationship documentType References 1..1 DocumentType inverse documents ;
		relationship sends Many 0..* Send inverse document ;
		relationship inputs Many 0..* Input inverse document ;
		relationship outputs Many 0..* Output inverse document ;
	}; // End: Document
	type Collaborator : MMElement {
		relationship process IsPartOf 1..1 Process inverse collaborators ;
		relationship collaboratorType References 1..1 CollaboratorType inverse collaborators ;
		relationship sends Many 0..* Send inverse collaborator ;
	}; // End: Collaborator
	type CollaboratorType : InterfaceType {
		relationship collaborators Many 0..* Collaborator inverse collaboratorType ;
		relationship clientType References 0..1 ClientType inverse collaboratorTypes ;
		relationship package IsPartOf 1..1 Package inverse collaboratorTypes ;
	}; // End: CollaboratorType
	type Reception : MMElement {
		relationship receive References 1..1 DocumentType inverse receivedInReceptions ;
		relationship results Many 0..* DocumentType inverse resultInReceptions ;
		relationship interfaceType IsPartOf 1..1 InterfaceType inverse receptions ;
	}; // End: Reception
	type Machine : MMElement {
		relationship process IsPartOf 1..1 Process inverse behavior ;
		relationship states Aggregates 0..* State inverse machine ;
		relationship action References 1..1 MachineAction inverse machines ;
		relationship transitions Aggregates 0..* Transition inverse machine ;
	}; // End: Machine
	type DocumentElement : MMElement {
		attribute int minMultiplicity;
		attribute int maxMultiplicity;
		relationship container IsPartOf 0..1 DocumentElementContainer inverse contents ;
	}; // End: DocumentElement
	type DocumentFeature : DocumentElement {
		attribute String type;
	}; // End: DocumentFeature
	type EmbeddedDocument : DocumentElement {
		relationship documentType References 1..1 DocumentType inverse embeddedDocuments ;
	}; // End: EmbeddedDocument
	type Structure : DocumentElementContainer {
	}; // End: Structure
	type DocumentElementContainer : DocumentElement {
		relationship contents Aggregates 1..* DocumentElement inverse container ;
	}; // End: DocumentElementContainer
	type TransformationType : Expression {
		relationship package IsPartOf 1..1 Package inverse transformationTypes ;
		relationship inputs Many 0..* InputType inverse transformationType ;
		relationship outputs Many 0..* OutputType inverse transformationType ;
		relationship transformations Many 0..* Transformation inverse transformationType ;
	}; // End: TransformationType
	type Factory : MMElement {
		relationship process IsPartOf 1..1 Process inverse factory ;
		relationship guard Aggregates 0..1 Expression inverse guardOfFactory ;
		relationship trigger References 1..1 DocumentType inverse triggerOfFactories ;
	}; // End: Factory
	type State : Active {
		relationship machine IsPartOf 1..1 Machine inverse states ;
		relationship outgoing Many 0..* Transition inverse source ;
		relationship incoming Many 0..* Transition inverse target ;
	}; // End: State
	type Transition : Active {
		relationship source References 1..1 State inverse outgoing ;
		relationship target References 1..1 State inverse incoming ;
		relationship machine IsPartOf 1..1 Machine inverse transitions ;
		relationship guard Aggregates 0..1 Expression inverse guardOfTransition ;
		relationship trigger References 1..1 DocumentType inverse triggerOf ;
	}; // End: Transition
	type Action : MMElement {
		relationship active References 1..1 Active inverse action ;
	}; // End: Action
	type Expression : MMElement {
		relationship action IsPartOf 0..1 ExpressionAction inverse expressions ;
		relationship guardOfTransition IsPartOf 0..1 Transition inverse guard ;
		relationship guardOfFactory IsPartOf 0..1 Factory inverse guard ;
	}; // End: Expression
	type Active : MMElement {
		relationship action References 0..1 Action inverse active ;
	}; // End: Active
	type MachineAction : Action {
		attribute boolean concurent;
		relationship machines Many 1..* Machine inverse action ;
	}; // End: MachineAction
	type ExpressionAction : Action {
		relationship expressions Aggregates 0..* Expression inverse action ;
	}; // End: ExpressionAction
	type InterfaceType : MMElement {
		relationship receptions Aggregates 0..* Reception inverse interfaceType ;
	}; // End: InterfaceType
	type ClientType : InterfaceType {
		relationship process IsPartOf 1..1 Process inverse clientType ;
		relationship collaboratorTypes Many 0..* CollaboratorType inverse clientType ;
	}; // End: ClientType
	type Send : Expression {
		relationship collaborator References 1..1 Collaborator inverse sends ;
		relationship document References 1..1 Document inverse sends ;
	}; // End: Send
	type InputType : MMElement {
		relationship transformationType References 1..1 TransformationType inverse inputs ;
		relationship documentType References 1..1 DocumentType inverse typeOfInput ;
		relationship inputs Many 0..* Input inverse inputType ;
	}; // End: InputType
	type OutputType : MMElement {
		relationship transformationType References 1..1 TransformationType inverse outputs ;
		relationship documentType References 1..1 DocumentType inverse typeOfOutput ;
		relationship outputs Many 0..* Output inverse outputType ;
	}; // End: OutputType
	type Transformation : Expression {
		relationship transformationType References 0..1 TransformationType inverse transformations ;
		relationship inputs Many 0..* Input inverse transformation ;
		relationship outputs Many 0..* Output inverse transformation ;
	}; // End: Transformation
	type Input : MMElement {
		relationship inputType References 0..1 InputType inverse inputs ;
		relationship transformation References 1..1 Transformation inverse inputs ;
		relationship document References 1..1 Document inverse inputs ;
	}; // End: Input
	type Output : MMElement {
		relationship transformation References 1..1 Transformation inverse outputs ;
		relationship outputType References 0..1 OutputType inverse outputs ;
		relationship document References 1..1 Document inverse outputs ;
	}; // End: Output
	type MMElement {
	}; // End: MMElement' copy!

example2
	"CODEModel example2"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'EAIUMLGenerated'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.eai.studio.metamodeluml'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'EAIUMLGenerated01Gen.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\EAIUMLGenerated01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\EAIUMLGenerated01\mySrc'.
	aModel typePrefix: 'EAI'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

example3
	"CODEModel example3"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'M3Generated'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.eai.studio.m3'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'M3Generated01Gen.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\M3Generated01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\M3Generated01\mySrc'.
	aModel typePrefix: 'M3'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234563'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\M3.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

example4
	"CODEModel example1"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'EAIMetamodel'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.eai.studio.metamodel'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'EAIMetamodelGenerated01Gen.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodelGenerated01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodelGenerated01\mySrc'.
	aModel typePrefix: 'EAI'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\EAIMMwUmlActions02.cdl'.
	^aModel!

example5
	"CODEModel example5"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'EAIActionsGenerated'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.eai.studio.actions'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'EAIUMLGenerated01Gen.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\EAIActionsGenerated01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\EAIActionsGenerated01\mySrc'.
	aModel typePrefix: 'EAI'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '43211234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\UMLBocaActions01.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

example6
	"CODEModel example6"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'Cx01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.cx'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'Cx01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\Cx01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\Cx01\mySrc'.
	aModel typePrefix: 'Cx'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '78911234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Cx01\\docs\Cx01.cdl'.
	^aModel!

example7
	"CODEModel example7"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'Cv01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.zerocode.cv'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'Cx01GenKK.jpr'.
	aModel projectDirectory: 'Q:\Ego\Cv01\'.
	aModel outputDirectory: 'Q:\Ego\Cv01\mySrc'.
	aModel typePrefix: 'CV'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '54311234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\Ego\Cv01\docs\Cv01.cdl'.
	^aModel!

exampleBBU01
	"CODEModel exampleBBU01"
	| aModel |
	aModel := CODEModel new.
	aModel rootTypeName: 'BBU'.
	aModel m3FactoryName: 'M3'.
	aModel name: 'BBU01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.bbu'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'BBU01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\BBU01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\BBU01\mySrc'.
	aModel typePrefix: 'BBU'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '33311236452'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\BBU01\docs\BBU01.cdl'.
	^aModel!

exampleBBU01Browser
	"CODEModel exampleBBU01Browser"
	| aModel |
	aModel := CODEModel new.

	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.dosmil_e.browserbase'.
	aModel rootTypeName: 'BBU'.
	aModel generateSeparateActions: true.

	aModel name: 'BBUBrowser01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.bbu'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'BBUBrowser01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\BBUBrowser01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\BBUBrowser01\mySrc'.
	aModel typePrefix: 'BBU'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '13411438752'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\BBU01\docs\BBU01.cdl'.
	^aModel!

exampleCx01
	"CODEModel exampleCx01"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'Cx01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.cx'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'Cx01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\Cx01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\Cx01\mySrc'.
	aModel typePrefix: 'Cx'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '78911234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Cx01\\docs\Cx01.cdl'.
	^aModel!

exampleCx01Browser
	"CODEModel exampleCx01Browser"
	| aModel |
	aModel := CODEModel new.

	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.d_a_t.eai.studio.browser'.
	aModel rootTypeName: 'Project'.

	aModel name: 'CxBrowser01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.cx'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'CxBrowser01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\CxBrowser01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\CxBrowser01\mySrc'.
	aModel typePrefix: 'Cx'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '78911234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Cx01\docs\Cx01.cdl'.
	^aModel!

exampleCxEdoc01
	"CODEModel exampleCxEdoc01"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'CxEdoc01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.cx'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'CxEdoc01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\CxEdoc01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\CxEdoc01\mySrc'.
	aModel typePrefix: 'Cx'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '78911234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullPubClassName: 'com.d_a_t.eai.studio.metamodel.pub.EAIMMElementPub'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\CxEdoc01\docs\CxEdocPhysical02.cdl'.
	^aModel!

exampleCxEdoc01Browser
	"CODEModel exampleCx01Browser"
	| aModel |
	aModel := CODEModel new.

	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.d_a_t.eai.studio.browser'.
	aModel rootTypeName: 'Project'.

	aModel name: 'CxEdocBrowser01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.cx'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'CxEdocBrowser01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\CxEdocBrowser01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\CxEdocBrowser01\mySrc'.
	aModel typePrefix: 'Cx'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '67811234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullPubClassName: 'com.d_a_t.eai.studio.metamodel.pub.EAIMMElementPub'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\CxEdoc01\docs\CxEdocPhysical02.cdl'.
	^aModel!

exampleEAIDynamic01
	"CODEModel exampleEAIDynamic01"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'EAIMetamodel'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.eai.studio.metamodel'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templatesdynamic'.
	aModel projectName: 'EAIDynamicGenerated01Gen.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\EAIDynamicGenerated01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\EAIDynamicGenerated01\mySrc'.
	aModel typePrefix: 'EAI'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullPubClassName: 'com.d_a_t.eai.studio.metamodel.pub.EAIMMElementPub'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIDynamicGenerated01\docs\EAIDynamic01.cdl'.
	^aModel!

exampleKit01
	"CODEModel exampleKit01"
	| aModel |
	aModel := CODEModel new.
	aModel rootTypeName: 'Project'.
	aModel m3FactoryName: 'M3'.
	aModel name: 'Kit01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel skipModules: (Array with: 'usecases' with: 'TravelSample').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.kit'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'Kit01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\Kit01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\Kit01\mySrc'.
	aModel typePrefix: 'Kit'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '33311234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Kit01\docs\KitScenarios09.cdl'.
	^aModel!

exampleKit01Browser
	"CODEModel exampleKit01Browser"
	| aModel |
	aModel := CODEModel new.

	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.dosmil_e.browserbase'.
	aModel rootTypeName: 'Project'.
	aModel generateSeparateActions: true.

	aModel name: 'KitBrowser01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel skipModules: (Array with: 'usecases' with: 'TravelSample').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.kit'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'KitBrowser01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\KitBrowser01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\KitBrowser01\mySrc'.
	aModel typePrefix: 'Kit'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '44411234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Kit01\docs\KitScenarios09.cdl'.
	^aModel!

exampleM3
	"CODEModel exampleM3"
	| aModel |
	aModel := CODEModel new.
	aModel name: 'M3Generated'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.d_a_t.eai.studio.m3'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIMetamodel01\templates'.
	aModel projectName: 'M3Generated01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\M3Generated01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\M3Generated01\mySrc'.
	aModel typePrefix: 'M3'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234563'.
	aModel defaultSuperTypeFullBaseClassName: 'com.d_a_t.eai.studio.metamodel.base.EAIMMElementBase'.
	aModel defaultSuperTypeFullIfcClassName: 'com.d_a_t.eai.studio.metamodel.ifc.EAIMMElementIfc'.
	aModel defaultSuperTypeFullPrivClassName: 'com.d_a_t.eai.studio.metamodel.priv.EAIMMElementPriv'.
	aModel defaultSuperTypeFullPubClassName: 'com.d_a_t.eai.studio.metamodel.pub.EAIMMElementPub'.
	aModel defaultSuperTypeFullTrxClassName: 'com.d_a_t.eai.studio.metamodel.trx.EAIMMElementTrx'.

	aModel frameworkPackage: 'com.d_a_t.eai.studio.metamodel'.
	aModel metaPackage: 'com.d_a_t.eai.studio.m3'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'D:\SaveAcvp02_03110215\ACVP01Contents\Q_CDMASTER\BXS\EAI\Studio\EAIModelBase01\docs\M303.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

exampleM3Dynamic02
	"CODEModel exampleM3Dynamic02"
	| aModel |
	aModel := CODEModel new.
	aModel generationStyle: CODEModel generationStyleStatic.
	aModel rootTypeName: 'Model'.
	aModel m3FactoryName: 'M3'.
	aModel isM3: true.
	aModel name: 'M3Dynamic02'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.m3'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templates'.
	aModel projectName: 'M3Dynamic02Gen.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\M3Dynamic02\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\M3Dynamic02\mySrc'.
	aModel typePrefix: 'M3'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234563'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIModelBase01\docs\M302.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

exampleM3Dynamic02Browser
	"CODEModel exampleM3Dynamic02Browser"
	| aModel |
	aModel := CODEModel new.
	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.dosmil_e.browserbase'.
	aModel rootTypeName: 'Model'.
	aModel generateSeparateActions: true.

	aModel isM3: true.
	aModel name: 'M3Dynamic02Browser'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.m3'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'M3Dynamic02Gen.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\M3DynamicBrowser02\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\M3DynamicBrowser02\mySrc'.
	aModel typePrefix: 'M3'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234563'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIModelBase01\docs\M302.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

exampleM3Model
	"CODEModel exampleM3Model"
	| aModel |
	aModel := CODEModel new.
	aModel generationStyle: CODEModel generationStyleStatic.
	aModel rootTypeName: 'Model'.
	aModel m3FactoryName: 'M3'.
	aModel isM3: true.
	aModel name: 'M3Model'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.yourml.repostory.m3model'.
	aModel templatesDirectory: 'C:\works\YourML\ModelGenerationTemplates\src\templates'.
	aModel projectName: 'M3Model.jpr'.
	aModel projectDirectory: 'C:\works\YourML\M3Model\'.
	aModel outputDirectory: 'C:\works\YourML\M3Model\src'.
	aModel typePrefix: 'M3'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234563'.
	aModel defaultSuperTypeFullBaseClassName: 'com.yourml.repostory.m3model.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.yourml.repostory.m3model.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.yourml.repostory.m3model.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.yourml.repostory.m3model.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.yourml.repostory.m3model.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.yourml.repostory.m3model.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.yourml.repostory.modelbase'.
	aModel metaPackage: 'com.yourml.repostory.m3model.core'.
	aModel metaMetaPackage: 'com.yourml.repostory.m3model.meta'.
	aModel metaTraversalPackage: 'com.yourml.repostory.m3model.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'C:\works\YourML\M3Model\M302.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

exampleM3ModelBrowser
	"CODEModel exampleM3ModelBrowser"
	| aModel |
	aModel := CODEModel new.
	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.yourml.repostory.browserbase'.
	aModel rootTypeName: 'Model'.
	aModel generateSeparateActions: true.

	aModel isM3: true.
	aModel name: 'M3ModelBrowser'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.yourml.repostory.m3model'.
	aModel templatesDirectory: 'C:\works\YourML\ModelGenerationTemplatesDRA\src\templatesdynamicreducedACTIONS'.
	aModel projectName: 'M3Model.jpr'.
	aModel projectDirectory: 'C:\works\YourML\M3ModelBrowser\'.
	aModel outputDirectory: 'C:\works\YourML\M3ModelBrowser\src'.
	aModel typePrefix: 'M3'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '12341234563'.
	aModel defaultSuperTypeFullBaseClassName: 'com.yourml.repostory.m3model.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.yourml.repostory.m3model.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.yourml.repostory.m3model.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.yourml.repostory.m3model.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.yourml.repostory.m3model.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.yourml.repostory.m3model.withm3.trx.MMElementWithM3Trx'.
	
	aModel frameworkPackage: 'com.yourml.repostory.modelbase'.
	aModel metaPackage: 'com.yourml.repostory.m3model.core'.
	aModel metaMetaPackage: 'com.yourml.repostory.m3model.meta'.
	aModel metaTraversalPackage: 'com.yourml.repostory.m3model.traversal'.
	aModel metaVariablePrefix: 'vm3'.

	aModel fromFileNamed: 'C:\works\YourML\M3Model\M302.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

exampleMall01
	"CODEModel exampleMall01"
	| aModel |
	aModel := CODEModel new.
	aModel rootTypeName: 'Mall'.
	aModel m3FactoryName: 'M3'.
	aModel name: 'Mall01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.mall'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'Mall01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\Mall01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\Mall01\mySrc'.
	aModel typePrefix: 'Mall'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '33311236452'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Mall01\docs\Mall01.cdl'.
	^aModel!

exampleMall01Browser
	"CODEModel exampleMall01Browser"
	| aModel |
	aModel := CODEModel new.

	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.dosmil_e.browserbase'.
	aModel rootTypeName: 'Mall'.
	aModel generateSeparateActions: true.

	aModel name: 'MallBrowser01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.mall'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'MallBrowser01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\MallBrowser01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\MallBrowser01\mySrc'.
	aModel typePrefix: 'Mall'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '13411438752'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Mall01\docs\Mall01.cdl'.
	^aModel!

exampleProtoware01
	"CODEModel exampleProtoware01"
	| aModel |
	aModel := CODEModel new.
	aModel rootTypeName: 'NotariesBase'.
	aModel m3FactoryName: 'M3'.
	aModel name: 'Proto01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.protoware'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreduced'.
	aModel projectName: 'Protoware01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\Protoware01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\Protoware01\mySrc'.
	aModel typePrefix: 'Pro'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '33311236890'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Protoware01\docs\ProtowareNoBoca01.cdl'.
	^aModel!

exampleProtoware01Browser
	"CODEModel exampleProtoware01Browser "
	| aModel |
	aModel := CODEModel new.

	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.dosmil_e.browserbase'.
	aModel rootTypeName: 'NotariesBase'.
	aModel generateSeparateActions: true.

	aModel name: 'ProtowareBrowser01'.
	aModel skipTypes: (Array with: 'MMElement').
	"aModel skipModules: (Array with: 'usecases' with: 'TravelSample')."
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.protoware'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'ProtowareBrowser01GenKK.jpr'.
	aModel projectDirectory: 'Q:\BXS\EAI\Studio\ProtowareBrowser01\'.
	aModel outputDirectory: 'Q:\BXS\EAI\Studio\ProtowareBrowser01\mySrc'.
	aModel typePrefix: 'Pro'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '44411238652'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\BXS\EAI\Studio\Protoware01\docs\ProtowareNoBoca01.cdl'.
	^aModel!

exampleRepostoryGrove
	"CODEModel exampleRepostoryGrove"
	| aModel |
	aModel := CODEElement newFromPersistenceAsCode: EDOCSimpleMetaInfoHolder repostoryGroveSimpleStore.
	aModel generationStyle: CODEModel generationStyleStatic.
	aModel rootTypeName: 'Domain'.
	aModel m3FactoryName: 'M3'.
	aModel isM3: true.
	aModel name: 'GroveModel'.
	aModel skipTypes: (Array with: 'MMElement' with: 'Object' with: 'Boolean').
	aModel expansionDelimiter: $$.
	aModel package: 'com.yourml.repostory.grove'.
	aModel templatesDirectory: 'C:\works\YourML\ModelGenerationTemplates\src\templates'.
	aModel projectName: 'GroveModel.jpr'.
	aModel projectDirectory: 'C:\works\YourML\Repostory01\'.
	aModel outputDirectory: 'C:\works\YourML\Repostory01\src'.
	aModel typePrefix: 'GR'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '314159'.
	aModel defaultSuperTypeFullBaseClassName: 'com.yourml.repostory.m3model.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.yourml.repostory.m3model.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.yourml.repostory.m3model.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.yourml.repostory.m3model.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.yourml.repostory.m3model.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.yourml.repostory.m3model.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.yourml.repostory.modelbase'.
	aModel metaPackage: 'com.yourml.repostory.m3model.core'.
	aModel metaMetaPackage: 'com.yourml.repostory.m3model.meta'.
	aModel metaTraversalPackage: 'com.yourml.repostory.m3model.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	

"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

exampleRepostoryStore
	"CODEModel exampleRepostoryStore"
	| aModel |
	aModel := CODEModel new.
	aModel generationStyle: CODEModel generationStyleStatic.
	aModel rootTypeName: 'Domain'.
	aModel m3FactoryName: 'M3'.
	aModel isM3: true.
	aModel name: 'StoreModel'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.yourml.repostory.store'.
	aModel templatesDirectory: 'C:\works\YourML\ModelGenerationTemplates\src\templates'.
	aModel projectName: 'StoreModel.jpr'.
	aModel projectDirectory: 'C:\works\YourML\StoreModel\'.
	aModel outputDirectory: 'C:\works\YourML\StoreModel\src'.
	aModel typePrefix: 'RS'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '314159'.
	aModel defaultSuperTypeFullBaseClassName: 'com.yourml.repostory.m3model.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.yourml.repostory.m3model.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.yourml.repostory.m3model.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.yourml.repostory.m3model.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.yourml.repostory.m3model.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.yourml.repostory.m3model.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.yourml.repostory.modelbase'.
	aModel metaPackage: 'com.yourml.repostory.m3model.core'.
	aModel metaMetaPackage: 'com.yourml.repostory.m3model.meta'.
	aModel metaTraversalPackage: 'com.yourml.repostory.m3model.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'C:\works\YourML\StoreModel\StoreModel.cdl'.


"	Object errorSignal 
		handle: [:anEx | Transcript show: anEx printString;cr]
		do: [ aModel fromFileNamed: 'Q:\BXS\EAI\Studio\EAIMetamodel01\docs\BxsBocaUml.cdl'].
"	^aModel!

exampleRepostoryStoreBrowser
	"CODEModel exampleRepostoryStoreBrowser"
	| aModel |
	aModel := CODEModel new.

	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.yourml.repostory.browserbase'.
	aModel rootTypeName: 'Domain'.
	aModel generateSeparateActions: true.

	aModel name: 'StoreModelBrowser'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.yourml.repostory.store'.
	aModel templatesDirectory: 'C:\works\YourML\ModelGenerationTemplatesDRA\src\templatesdynamicreducedACTIONS'.
	aModel projectName: 'StoreModelBrowser.jpr'.
	aModel projectDirectory: 'C:\works\YourML\StoreModelBrowser\'.
	aModel outputDirectory: 'C:\works\YourML\StoreModelBrowser\src'.
	aModel typePrefix: 'RS'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '44411234561'.
	aModel defaultSuperTypeFullBaseClassName: 'com.yourml.repostory.m3model.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.yourml.repostory.m3model.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.yourml.repostory.m3model.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.yourml.repostory.m3model.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.yourml.repostory.m3model.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.yourml.repostory.m3model.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.yourml.repostory.modelbase'.
	aModel metaPackage: 'com.yourml.repostory.m3model.core'.
	aModel metaMetaPackage: 'com.yourml.repostory.m3model.meta'.
	aModel metaTraversalPackage: 'com.yourml.repostory.m3model.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'C:\works\YourML\StoreModel\StoreModel.cdl'.
	^aModel!

exampleSondaUseCases01
	"CODEModel exampleSonda01"
	| aModel |
	aModel := CODEModel new.
	aModel rootTypeName: 'UseSystemSuperUseCase'.
	aModel m3FactoryName: 'M3'.
	aModel name: 'SondaUseCases01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.sonda.simple.usecases'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'Sonda01GenKK.jpr'.
	aModel projectDirectory: 'Q:\Crawl\SondaUseCases01\'.
	aModel outputDirectory: 'Q:\Crawl\SondaUseCases01\mySrc'.
	aModel typePrefix: 'SONU'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '33311236468'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\Crawl\SondaUseCases01\docs\SondaUseCases01.cdl'.
	^aModel!

exampleSondaUseCases01Browser
	"CODEModel exampleSonda01Browser"
	| aModel |
	aModel := CODEModel new.

	aModel aspectToGenerate: self aspectToGenerateBrowser.
	aModel browserFrameworkPackage: 'com.dosmil_e.browserbase'.
	aModel rootTypeName: 'UseSystemSuperUseCase'.
	aModel generateSeparateActions: true.

	aModel name: 'SondaUseCasesBrowser01'.
	aModel skipTypes: (Array with: 'MMElement').
	aModel expansionDelimiter: $$.
	aModel package: 'com.dosmil_e.sonda.simple.usecases'.
	aModel templatesDirectory: 'Q:\BXS\EAI\Studio\EAIModelBase01\templatesdynamicreducedACTIONS'.
	aModel projectName: 'SondaBrowser01GenKK.jpr'.
	aModel projectDirectory: 'Q:\Crawl\SondaUseCasesBrowser01\'.
	aModel outputDirectory: 'Q:\Crawl\SondaUseCasesBrowser01\mySrc'.
	aModel typePrefix: 'SONU'.
	aModel relationshipVariablePrefix: 'vr'.
	aModel attributeVariablePrefix: 'va'.
	aModel enumVariablePrefix: ''.
	aModel serialVersionUIDPrefix: '13411438798'.
	aModel defaultSuperTypeFullBaseClassName: 'com.dosmil_e.m3.withm3.base.MMElementWithM3Base'.
	aModel defaultSuperTypeFullIfcClassName: 'com.dosmil_e.m3.withm3.ifc.MMElementWithM3Ifc'.
	aModel defaultSuperTypeFullImplClassName: 'com.dosmil_e.m3.withm3.impl.MMElementWithM3Impl'.
	aModel defaultSuperTypeFullPubClassName: 'com.dosmil_e.m3.withm3.pub.MMElementWithM3Pub'.
	aModel defaultSuperTypeFullPrivClassName: 'com.dosmil_e.m3.withm3.priv.MMElementWithM3Priv'.
	aModel defaultSuperTypeFullTrxClassName: 'com.dosmil_e.m3.withm3.trx.MMElementWithM3Trx'.

	aModel frameworkPackage: 'com.dosmil_e.modelbase'.
	aModel metaPackage: 'com.dosmil_e.m3.core'.
	aModel metaMetaPackage: 'com.dosmil_e.m3.meta'.
	aModel metaTraversalPackage: 'com.dosmil_e.m3.traversal'.
	aModel metaVariablePrefix: 'vm3'.
	
	aModel fromFileNamed: 'Q:\Crawl\SondaUseCases01\docs\SondaUseCases01.cdl'.
	^aModel!

generateExample1
	"CODEModel generateExample1"
	CODEModel example1 generate!

generateExample2
	"CODEModel generateExample2"
	CODEModel example2 generate!

generateExample3
	"CODEModel generateExample3"
	CODEModel example3 generate!

generateExample4
	"CODEModel generateExample4"
	CODEModel example4 generate!

generateExample5
	"CODEModel generateExample5"
	CODEModel example5 generate!

generateExample6
	"CODEModel generateExample6"
	CODEModel example6 generate!

generateExample7
	"CODEModel generateExample7"
	CODEModel example7 generate!

generateExampleBBU01
	"CODEModel generateExampleBBU01"
	CODEModel exampleBBU01 generate!

generateExampleBBU01Browser
	"CODEModel generateExampleBBU01Browser"
	CODEModel exampleBBU01Browser generate!

generateExampleCx01
	"CODEModel generateExampleCx01"
	CODEModel exampleCx01 generate!

generateExampleCx01Browser
	"CODEModel generateExampleCx01Browser"
	CODEModel exampleCx01Browser generate!

generateExampleCxEdoc01
	"CODEModel generateExampleCxEdoc01"
	CODEModel exampleCxEdoc01 generate!

generateExampleCxEdoc01Browser
	"CODEModel generateExampleCxEdoc01Browser"
	CODEModel exampleCxEdoc01Browser generate!

generateExampleEAIDynamic01
	"CODEModel generateExampleEAIDynamic01"
	CODEModel exampleEAIDynamic01 generate!

generateExampleKit01
	"CODEModel generateExampleKit01"
	CODEModel exampleKit01 generate!

generateExampleKit01Browser
	"CODEModel generateExampleKit01Browser"
	CODEModel exampleKit01Browser generate!

generateExampleM3
	"CODEModel generateExampleM3"
	CODEModel exampleM3 generate!

generateExampleM3Dynamic02
	"CODEModel generateExampleM3Dynamic02"
	CODEModel exampleM3Dynamic02 generate!

generateExampleM3Dynamic02Browser
	"CODEModel generateExampleM3Dynamic02Browser"
	CODEModel exampleM3Dynamic02Browser generate!

generateExampleM3Model
	"CODEModel generateExampleM3Model"
	CODEModel exampleM3Model generate!

generateExampleM3ModelBrowser
	"CODEModel generateExampleM3ModelBrowser"
	CODEModel exampleM3ModelBrowser generate!

generateExampleMall01
	"CODEModel generateExampleMall01"
	CODEModel exampleMall01 generate!

generateExampleMall01Browser
	"CODEModel generateExampleMall01Browser"
	CODEModel exampleMall01Browser generate!

generateExampleProtoware01
	"CODEModel generateExampleProtoware01"
	CODEModel exampleProtoware01 generate!

generateExampleProtoware01Browser
	"CODEModel generateExampleProtoware01Browser"
	CODEModel exampleProtoware01Browser generate!

generateExampleRepostoryGrove
	"CODEModel generateExampleRepostoryGrove"
	CODEModel exampleRepostoryGrove generate!

generateExampleRepostoryStore
	"CODEModel generateExampleRepostoryStore"
	CODEModel exampleRepostoryStore generate!

generateExampleRepostoryStoreBrowser
	"CODEModel generateExampleRepostoryStoreBrowser"
	CODEModel exampleRepostoryStoreBrowser generate!

generateExampleSondaUseCases01
	"CODEModel generateExampleSondaUseCases01"
	CODEModel exampleSondaUseCases01 generate!

generateExampleSondaUseCases01Browser
	"CODEModel generateExampleSondaUseCases01Browser"
	CODEModel exampleSondaUseCases01Browser generate!

pathBrowseExample1
	"CODEModels pathBrowseExample1"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel example1!

pathBrowseExample2
	"CODEModels pathBrowseExample2"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel example2!

pathBrowseExample3
	"CODEModels pathBrowseExample3"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel example3!

pathBrowseExample4
	"CODEModels pathBrowseExample4"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel example4!

pathBrowseExample5
	"CODEModels pathBrowseExample5"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel example5!

pathBrowseExample6
	"CODEModel pathBrowseExample6"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel example6!

pathBrowseExample7
	"CODEModel pathBrowseExample7"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel example7!

pathBrowseExampleBBU01
	"CODEModel pathBrowseExampleBBU01"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleBBU01!

pathBrowseExampleCx01
	"CODEModel pathBrowseExampleCx01"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleCx01!

pathBrowseExampleCx01Browser
	"CODEModel pathBrowseExampleCx01Browser"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleCx01Browser!

pathBrowseExampleCxEdoc01
	"CODEModel pathBrowseExampleCxEdoc01"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleCxEdoc01!

pathBrowseExampleCxEdoc01Browser
	"CODEModel pathBrowseExampleCxEdoc01Browser"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleCxEdoc01Browser!

pathBrowseExampleEAIDynamic01
	"CODEModel pathBrowseExampleEAIDynamic01"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleEAIDynamic01!

pathBrowseExampleKit01
	"CODEModel pathBrowseExampleKit01"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleKit01!

pathBrowseExampleKit01Browser
	"CODEModel pathBrowseExampleKit01Browser"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleKit01Browser!

pathBrowseExampleM3
	"CODEModel  pathBrowseExampleM3"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleM3!

pathBrowseExampleM3Dynamic02
	"CODEModel  pathBrowseExampleM3Dynamic02"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleM3Dynamic02!

pathBrowseExampleM3Dynamic02Browser
	"CODEModel  pathBrowseExampleM3Dynamic02Browser"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleM3Dynamic02Browser!

pathBrowseExampleM3Model
	"CODEModel  pathBrowseExampleM3Model"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleM3Model!

pathBrowseExampleMall01
	"CODEModel pathBrowseExampleMall01"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleMall01!

pathBrowseExampleMall01Browser
	"CODEModel pathBrowseExampleMall01Browser"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleMall01Browser!

pathBrowseExampleProtoware01
	"CODEModel pathBrowseExampleProtoware01"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleProtoware01!

pathBrowseExampleProtoware01Browser
	"CODEModel pathBrowseExampleProtoware01Browser"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleProtoware01Browser!

pathBrowseExampleRepostoryGrove
	"CODEModel pathBrowseExampleRepostoryGrove"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleRepostoryGrove!

pathBrowseExampleRepostoryStore
	"CODEModel pathBrowseExampleRepostoryStore"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleRepostoryStore!

pathBrowseExampleSondaUseCases01
	"CODEModel pathBrowseExampleSondaUseCases01"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleSondaUseCases01!

pathBrowseExampleSondaUseCases01Browser
	"CODEModel pathBrowseExampleSondaUseCases01Browser"

	METAPathFinderScopedApplicationBrowser openForObject: CODEModel exampleSondaUseCases01Browser! !

!CODEModel class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEModel class publicMethodsFor: 'modelElements persistence'!

codeModelStorage

	"(CODEElement newFromPersistenceAsCode: CODEModel codeModelStorage) browsePath"

	self ojoModel.

	^   #( model 'CODEcore'
	nil nil
	nil
	nil
	CODEModel codeModelStorage
	nil
	(submodules
	  ( module 'Core'
		nil nil
		(definedAspects
		  ( aspect 'a'
			nil nil
		   )

		 )
		nil
		nil nil
		(types
		  ( type 'Element'
			nil nil
			nil
			nil
			true false false
			nil nil
			CODEElement
			false false false false
			nil
			nil
			nil
			nil
			nil
		   )

		  ( type 'Comment'
			nil nil
			nil
			nil
			false false false
			nil nil
			CODEComment
			false false false false
			#(#supertypes #(#refToType 'Element' 'Core'))
			nil
			(attributes
			  ( relationship 'element'
				nil nil
				nil
				nil
				isAGGREGATED nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'comments'  ( refToType 'CommentedElement' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'element'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'comments'  ( refToType 'CommentedElement' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'CommentedElement'
			nil nil
			nil
			nil
			true false false
			nil nil
			CODECommentedElement
			false false false false
			#(#supertypes #(#refToType 'Element' 'Core'))
			nil
			(attributes
			  ( relationship 'comments'
				nil nil
				nil
				nil
				AGGREGATES nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'element'  ( refToType 'Comment' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'comments'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'element'  ( refToType 'Comment' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Parameter'
			nil nil
			nil
			nil
			false false false
			nil nil
			CODEParameter
			false false false false
			#(#supertypes #(#refToType 'CommentedElement' 'Core'))
			nil
			(attributes
			  ( relationship 'element'
				nil nil
				nil
				nil
				isAGGREGATED nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'parameters'  ( refToType 'ParametrizedElement' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'element'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'parameters'  ( refToType 'ParametrizedElement' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'ParametrizedElement'
			nil nil
			nil
			nil
			true false false
			nil nil
			CODEParametrizedElement
			false false false false
			#(#supertypes #(#refToType 'CommentedElement' 'Core'))
			nil
			(attributes
			  ( relationship 'parameters'
				nil nil
				nil
				nil
				AGGREGATES nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'element'  ( refToType 'Parameter' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'parameters'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'element'  ( refToType 'Parameter' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Module'
			nil nil
			nil
			nil
			false false false
			nil nil
			CODEModule
			false false false false
			#(#supertypes #(#refToType 'ParametrizedElement' 'Core'))
			nil
			(attributes
			  ( relationship 'subModules'
				nil nil
				nil
				nil
				AGGREGATES 'subModules'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'superModule'  ( refToType 'Module' 'Core'  )  ) 
			   )

			  ( relationship 'superModule'
				nil nil
				nil
				nil
				isAGGREGATED 'superModule'
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'subModules'  ( refToType 'Module' 'Core'  )  ) 
			   )

			  ( relationship 'types'
				nil nil
				nil
				nil
				AGGREGATES 'types'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'module'  ( refToType 'Type' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'superModule'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'subModules'  ( refToType 'Module' 'Core'  )  ) 
			   )

			  ( relationship 'subModules'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'superModule'  ( refToType 'Module' 'Core'  )  ) 
			   )

			  ( relationship 'types'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'module'  ( refToType 'Type' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Model'
			nil nil
			nil
			nil
			false false false
			nil nil
			CODEModel
			false false false false
			#(#supertypes #(#refToType 'Module' 'Core'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'Attribute'
			nil nil
			nil
			(aspects
			   ( refToAspect 'a' 'Core'  ) 
			 )
			false false false
			nil nil
			CODEAttribute
			false false false false
			#(#supertypes #(#refToType 'ParametrizedElement' 'Core'))
			nil
			(attributes
			  ( relationship 'type'
				nil nil
				nil
				nil
				isAGGREGATED 'type'
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributes'  ( refToType 'Type' 'Core'  )  ) 
			   )

			  ( relationship 'attributeRefinements'
				nil nil
				nil
				nil
				REFERENCES 'attributeRefinements'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'refinedAttributes'  ( refToType 'AttributeRefinement' 'Core'  )  ) 
			   )

			  ( relationship 'valueType'
				nil nil
				nil
				nil
				REFERENCES 'valueType'
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'typeOfValues'  ( refToType 'Type' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'attributeRefinements'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'refinedAttributes'  ( refToType 'AttributeRefinement' 'Core'  )  ) 
			   )

			  ( relationship 'type'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributes'  ( refToType 'Type' 'Core'  )  ) 
			   )

			  ( relationship 'valueType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'typeOfValues'  ( refToType 'Type' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'AttributeRefinement'
			nil nil
			nil
			nil
			false false false
			nil nil
			CODEAttributeRefinement
			false false false false
			#(#supertypes #(#refToType 'Attribute' 'Core'))
			nil
			(attributes
			  ( relationship 'refinedAttributes'
				nil nil
				nil
				nil
				REFERENCES 'refinedAttributes'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributeRefinements'  ( refToType 'Attribute' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'refinedAttributes'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributeRefinements'  ( refToType 'Attribute' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Relationship'
			nil nil
			nil
			nil
			false false false
			nil nil
			CODERelationship
			false false false false
			#(#supertypes #(#refToType 'ParametrizedElement' 'Core'))
			nil
			(attributes
			  ( relationship 'type'
				nil nil
				nil
				nil
				isAGGREGATED 'type'
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relationships'  ( refToType 'Type' 'Core'  )  ) 
			   )

			  ( relationship 'relationshipRefinements'
				nil nil
				nil
				nil
				REFERENCES 'relationshipRefinements'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'refinedRelationships'  ( refToType 'RelationshipRefinement' 'Core'  )  ) 
			   )

			  ( relationship 'inverse'
				nil nil
				nil
				nil
				REFERENCES nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverse'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			  ( relationship 'inverse'
				nil nil
				nil
				nil
				REFERENCES nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverse'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			  ( relationship 'relatedType'
				nil nil
				nil
				nil
				REFERENCES 'relatedType'
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relatedWith'  ( refToType 'Type' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverse'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverse'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			  ( relationship 'relationshipRefinements'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'refinedRelationships'  ( refToType 'RelationshipRefinement' 'Core'  )  ) 
			   )

			  ( relationship 'type'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relationships'  ( refToType 'Type' 'Core'  )  ) 
			   )

			  ( relationship 'relatedType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relatedWith'  ( refToType 'Type' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'RelationshipRefinement'
			nil nil
			nil
			nil
			false false false
			nil nil
			CODERelationshipRefinement
			false false false false
			#(#supertypes #(#refToType 'Relationship' 'Core'))
			nil
			(attributes
			  ( relationship 'refinedRelationships'
				nil nil
				nil
				nil
				REFERENCES 'refinedRelationships'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relationshipRefinements'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'refinedRelationships'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relationshipRefinements'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Type'
			nil nil
			nil
			nil
			false false false
			nil nil
			CODEType
			false false false false
			#(#supertypes #(#refToType 'ParametrizedElement' 'Core'))
			nil
			(attributes
			  ( relationship 'module'
				nil nil
				nil
				nil
				isAGGREGATED 'module'
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'types'  ( refToType 'Module' 'Core'  )  ) 
			   )

			  ( relationship 'relationships'
				nil nil
				nil
				nil
				AGGREGATES 'relationships'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			  ( relationship 'attributes'
				nil nil
				nil
				nil
				AGGREGATES 'attributes'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'Attribute' 'Core'  )  ) 
			   )

			  ( relationship 'superTypes'
				nil nil
				nil
				nil
				REFERENCES 'superTypes'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'subTypes'  ( refToType 'Type' 'Core'  )  ) 
			   )

			  ( relationship 'subTypes'
				nil nil
				nil
				nil
				REFERENCES 'subTypes'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'superTypes'  ( refToType 'Type' 'Core'  )  ) 
			   )

			  ( relationship 'relatedWith'
				nil nil
				nil
				nil
				REFERENCES 'relatedWith'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relatedType'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			  ( relationship 'typeOfValues'
				nil nil
				nil
				nil
				REFERENCES 'typeOfValues'
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'valueType'  ( refToType 'Attribute' 'Core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'module'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'types'  ( refToType 'Module' 'Core'  )  ) 
			   )

			  ( relationship 'attributes'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'Attribute' 'Core'  )  ) 
			   )

			  ( relationship 'typeOfValues'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'valueType'  ( refToType 'Attribute' 'Core'  )  ) 
			   )

			  ( relationship 'relationships'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			  ( relationship 'relatedWith'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relatedType'  ( refToType 'Relationship' 'Core'  )  ) 
			   )

			  ( relationship 'subTypes'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'superTypes'  ( refToType 'Type' 'Core'  )  ) 
			   )

			  ( relationship 'superTypes'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'subTypes'  ( refToType 'Type' 'Core'  )  ) 
			   )

			 )
			nil
		   )

		 )
		nil
	   )

	  ( module 'DataTypes'
		nil nil
		nil
		nil
		nil nil
		(types
		  ( type 'String'
			nil nil
			nil
			nil
			false false true
			nil nil
			nil
			false false false false
			nil
			nil
			nil
			nil
			nil
		   )

		  ( type 'Symbol'
			nil nil
			nil
			nil
			false false true
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'String' 'DataTypes'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'Boolean'
			nil nil
			nil
			nil
			false false true
			nil nil
			nil
			false false false false
			nil
			nil
			nil
			nil
			nil
		   )

		 )
		nil
	   )

	 )
	nil nil
   )!

m303ModelStorage

	"(CODEElement newFromPersistenceAsCode: CODEModel m303ModelStorage) browsePath"

	self ojoModel.

	^   #( model 'M3Generated'
	nil nil
	nil
	nil
	CODEModel m303ModelStorage
	nil
	(submodules
	  ( module 'traversal'
		nil nil
		nil
		nil
		nil nil
		(types
		  ( type 'RootTypeNodeConfig'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'TypeNodeConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'rootTypeNodeConfigs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'rootTypeNodeMgr'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFrootTypeNodeMgr'  ( refToType 'RootTypeNodeMgr' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'rootTypeNodeConfigs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'rootTypeNodeMgr'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFrootTypeNodeMgr'  ( refToType 'RootTypeNodeMgr' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'NodeConfig'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'PushConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'branchConfigs'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFbranchConfigs'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'nodeConfigs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'attributeConfigs'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFattributeConfigs'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'metaType'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaType'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'metaNodeMgr'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaNodeMgr'  ( refToType 'NodeMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFnodeConfig'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'nodeConfig'  ( refToType 'TypeNodeConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'branchConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFbranchConfigs'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFnodeConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'nodeConfig'  ( refToType 'TypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'nodeConfigs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'attributeConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFattributeConfigs'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'metaNodeMgr'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaNodeMgr'  ( refToType 'NodeMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'metaType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaType'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'BranchConfig'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'PushConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'inverseOFbranchConfigs'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'branchConfigs'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'metaRelationship'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaRelationship'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'typeNodeConfigs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'branchConfig'  ( refToType 'RelatedTypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'branchConfigs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'metaBranchMgr'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaBranchMgr'  ( refToType 'BranchMgr' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOFbranchConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'branchConfigs'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'typeNodeConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'branchConfig'  ( refToType 'RelatedTypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'branchConfigs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'metaBranchMgr'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaBranchMgr'  ( refToType 'BranchMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'metaRelationship'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaRelationship'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'TypeNodeConfig'
			nil nil
			nil
			nil
			true false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'PushConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'metaType'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverse1OFmetaType'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'nodeConfig'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFnodeConfig'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'filter'
				nil nil
				nil
				nil
				AGGREGATES nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'container'  ( refToType 'RelationshipConstraint' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'nodeConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFnodeConfig'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'filter'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'container'  ( refToType 'RelationshipConstraint' 'traversal'  )  ) 
			   )

			  ( relationship 'metaType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverse1OFmetaType'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'RelatedTypeNodeConfig'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'TypeNodeConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'branchConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'typeNodeConfigs'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'branchConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'typeNodeConfigs'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'TraversalConfig'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'rootTypeNodeConfigs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'RootTypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'branchConfigs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'nodeConfigs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'attributeConfigs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'pushedFromConfigElement'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'pushedTraversalConfig'  ( refToType 'PushConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'model'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfigs'  ( refToType 'Model' 'core'  )  ) 
			   )

			  ( relationship 'fieldMgrs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'FieldMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'branchMgrs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'BranchMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'nodeMgrs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'NodeMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'rootTypeNodeMgrs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'RootTypeNodeMgr' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'rootTypeNodeConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'RootTypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'nodeConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'branchConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'attributeConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'pushedFromConfigElement'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'pushedTraversalConfig'  ( refToType 'PushConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'nodeMgrs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'NodeMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'branchMgrs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'BranchMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'fieldMgrs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'FieldMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'rootTypeNodeMgrs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfig'  ( refToType 'RootTypeNodeMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'model'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'traversalConfigs'  ( refToType 'Model' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'AttributeConfig'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'PushConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'inverseOFattributeConfigs'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributeConfigs'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributeConfigs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'metaAttribute'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaAttribute'  ( refToType 'Attribute' 'core'  )  ) 
			   )

			  ( relationship 'metaFieldMgr'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaFieldMgr'  ( refToType 'FieldMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'typeNodeConfigs'
				nil nil
				nil
				nil
				AGGREGATES nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributeConfig'  ( refToType 'AttributeTypeNodeConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOFattributeConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributeConfigs'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributeConfigs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'metaFieldMgr'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaFieldMgr'  ( refToType 'FieldMgr' 'traversal'  )  ) 
			   )

			  ( relationship 'typeNodeConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributeConfig'  ( refToType 'AttributeTypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'metaAttribute'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFmetaAttribute'  ( refToType 'Attribute' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'PushConfig'
			nil nil
			nil
			nil
			true false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'ConfigOverride' 'traversal'))
			nil
			(attributes
			  ( relationship 'pushedTraversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'pushedFromConfigElement'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'pushedTraversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'pushedFromConfigElement'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'NodeMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'inverseOFmetaNodeMgr'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaNodeMgr'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'nodeMgrs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOFmetaNodeMgr'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaNodeMgr'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'nodeMgrs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'BranchMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'inverseOFmetaBranchMgr'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaBranchMgr'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'branchMgrs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOFmetaBranchMgr'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaBranchMgr'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'branchMgrs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'FieldMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'inverseOFmetaFieldMgr'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaFieldMgr'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'fieldMgrs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'fieldMgrs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFmetaFieldMgr'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaFieldMgr'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'RelationshipConstraint'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Behavior' 'behavior'))
			nil
			(attributes
			  ( relationship 'container'
				nil nil
				nil
				nil
				isAGGREGATED nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'filter'  ( refToType 'TypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'conditions'
				nil nil
				nil
				nil
				AGGREGATES nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'constraint'  ( refToType 'RelationshipMembershipCondition' 'traversal'  )  ) 
			   )

			  ( relationship 'initializations'
				nil nil
				nil
				nil
				AGGREGATES nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'constraint'  ( refToType 'RelationshipNewMemberInitialization' 'traversal'  )  ) 
			   )

			  ( relationship 'candidatesTraversal'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'candidatesTraversalOfConstraint'  ( refToType 'RelationshipCandidateMemberTraversal' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'container'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'filter'  ( refToType 'TypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'conditions'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'constraint'  ( refToType 'RelationshipMembershipCondition' 'traversal'  )  ) 
			   )

			  ( relationship 'initializations'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'constraint'  ( refToType 'RelationshipNewMemberInitialization' 'traversal'  )  ) 
			   )

			  ( relationship 'candidatesTraversal'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'candidatesTraversalOfConstraint'  ( refToType 'RelationshipCandidateMemberTraversal' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'RootTypeNodeMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'inverseOFrootTypeNodeMgr'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'rootTypeNodeMgr'  ( refToType 'RootTypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'rootTypeNodeMgrs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOFrootTypeNodeMgr'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'rootTypeNodeMgr'  ( refToType 'RootTypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'traversalConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'rootTypeNodeMgrs'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'AttributeTypeNodeConfig'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'TypeNodeConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'attributeConfig'
				nil nil
				nil
				nil
				isAGGREGATED nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'typeNodeConfigs'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'attributeConfig'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'typeNodeConfigs'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'ConfigOverride'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'overridenConfigElement'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOfOverridenConfigElement'  ( refToType 'ConfigOverride' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOfOverridenConfigElement'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'overridenConfigElement'  ( refToType 'ConfigOverride' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOfOverridenConfigElement'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'overridenConfigElement'  ( refToType 'ConfigOverride' 'traversal'  )  ) 
			   )

			  ( relationship 'overridenConfigElement'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOfOverridenConfigElement'  ( refToType 'ConfigOverride' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'RelationshipMembershipCondition'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'constraint'
				nil nil
				nil
				nil
				isAGGREGATED nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'conditions'  ( refToType 'RelationshipConstraint' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'constraint'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'conditions'  ( refToType 'RelationshipConstraint' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'RelationshipNewMemberInitialization'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'constraint'
				nil nil
				nil
				nil
				isAGGREGATED nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'initializations'  ( refToType 'RelationshipConstraint' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'constraint'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'initializations'  ( refToType 'RelationshipConstraint' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'RelationshipCandidateMemberTraversal'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'candidatesTraversalOfConstraint'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'candidatesTraversal'  ( refToType 'RelationshipConstraint' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'candidatesTraversalOfConstraint'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'candidatesTraversal'  ( refToType 'RelationshipConstraint' 'traversal'  )  ) 
			   )

			 )
			nil
		   )

		 )
		nil
	   )

	  ( module 'replication'
		nil nil
		nil
		nil
		nil nil
		(types
		  ( type 'ReplicateBranchMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'BranchMgr' 'traversal'))
			nil
			(attributes
			  ( relationship 'replicatedMetaRelationship'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFreplicatedMetaRelationship'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'replicatedMetaRelationship'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFreplicatedMetaRelationship'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'ReplicateNodeMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'NodeMgr' 'traversal'))
			nil
			(attributes
			  ( relationship 'replicatedMetaType'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFreplicatedMetaType'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'replicatedMetaType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFreplicatedMetaType'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'CopyFieldMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'FieldMgr' 'traversal'))
			nil
			(attributes
			  ( relationship 'copiedMetaAttribute'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFcopiedMetaAttribute'  ( refToType 'Attribute' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'copiedMetaAttribute'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFcopiedMetaAttribute'  ( refToType 'Attribute' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'ReplicateRootTypeNodeMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'RootTypeNodeMgr' 'traversal'))
			nil
			nil
			nil
			nil
		   )

		 )
		nil
	   )

	  ( module 'projection'
		nil nil
		nil
		nil
		nil nil
		(types
		  ( type 'ProjectionConfig'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'TraversalConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'targetToTransfomations'
				nil nil
				nil
				nil
				References nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFtargetToTransfomations'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'projectionToOriginals'
				nil nil
				nil
				nil
				References nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFprojectionToOriginals'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'projectedToProjections'
				nil nil
				nil
				nil
				References nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFprojectedToProjections'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'transformationToSources'
				nil nil
				nil
				nil
				References nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFtransformationToSources'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'transformationToSubTransformations'
				nil nil
				nil
				nil
				References nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFtransformationToSubTransformations'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'targetToTransfomations'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFtargetToTransfomations'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'projectionToOriginals'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFprojectionToOriginals'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'projectedToProjections'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFprojectedToProjections'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'transformationToSources'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFtransformationToSources'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'transformationToSubTransformations'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverseOFtransformationToSubTransformations'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			 )
			nil
		   )

		 )
		nil
	   )

	  ( module 'core'
		nil nil
		nil
		nil
		nil nil
		(types
		  ( type 'Model'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Module' 'core'))
			nil
			(attributes
			  ( relationship 'treeRootType'
				nil nil
				nil
				nil
				References nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'rootTypeOfModel'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'traversalConfigs'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'model'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'traversalConfigs'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'model'  ( refToType 'TraversalConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'treeRootType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'rootTypeOfModel'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Module'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Element' 'core'))
			nil
			(attributes
			  ( relationship 'superModule'
				nil nil
				nil
				nil
				IsPartOf nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'subModules'  ( refToType 'Module' 'core'  )  ) 
			   )

			  ( relationship 'subModules'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'superModule'  ( refToType 'Module' 'core'  )  ) 
			   )

			  ( relationship 'types'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'module'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'subModules'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'superModule'  ( refToType 'Module' 'core'  )  ) 
			   )

			  ( relationship 'superModule'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'subModules'  ( refToType 'Module' 'core'  )  ) 
			   )

			  ( relationship 'types'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'module'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Type'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Element' 'core'))
			nil
			(attributes
			  ( relationship 'inverseOFmetaType'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaType'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverse1OFmetaType'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaType'  ( refToType 'TypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFreplicatedMetaType'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'replicatedMetaType'  ( refToType 'ReplicateNodeMgr' 'replication'  )  ) 
			   )

			  ( relationship 'module'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'types'  ( refToType 'Module' 'core'  )  ) 
			   )

			  ( relationship 'attributes'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'Attribute' 'core'  )  ) 
			   )

			  ( relationship 'typeOfValues'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'valueType'  ( refToType 'Attribute' 'core'  )  ) 
			   )

			  ( relationship 'superTypes'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'subTypes'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'subTypes'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'superTypes'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'relationships'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'relatedWith'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relatedType'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'rootTypeOfModel'
				nil nil
				nil
				nil
				References nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'treeRootType'  ( refToType 'Model' 'core'  )  ) 
			   )

			  ( relationship 'candidateSets'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'CandidateSet' 'candidates'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOFmetaType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaType'  ( refToType 'NodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverse1OFmetaType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaType'  ( refToType 'TypeNodeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFreplicatedMetaType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'replicatedMetaType'  ( refToType 'ReplicateNodeMgr' 'replication'  )  ) 
			   )

			  ( relationship 'rootTypeOfModel'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'treeRootType'  ( refToType 'Model' 'core'  )  ) 
			   )

			  ( relationship 'module'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'types'  ( refToType 'Module' 'core'  )  ) 
			   )

			  ( relationship 'subTypes'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'superTypes'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'superTypes'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'subTypes'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'relationships'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'relatedWith'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relatedType'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'attributes'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'Attribute' 'core'  )  ) 
			   )

			  ( relationship 'typeOfValues'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'valueType'  ( refToType 'Attribute' 'core'  )  ) 
			   )

			  ( relationship 'candidateSets'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'type'  ( refToType 'CandidateSet' 'candidates'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Relationship'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'StructuralFeature' 'core'))
			nil
			(attributes
			  ( relationship 'inverseOFmetaRelationship'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaRelationship'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFreplicatedMetaRelationship'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'replicatedMetaRelationship'  ( refToType 'ReplicateBranchMgr' 'replication'  )  ) 
			   )

			  ( relationship 'inverseOFtargetToTransfomations'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'targetToTransfomations'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverseOFprojectionToOriginals'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'projectionToOriginals'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverseOFprojectedToProjections'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'projectedToProjections'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverseOFtransformationToSources'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'transformationToSources'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverseOFtransformationToSubTransformations'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'transformationToSubTransformations'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverse'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverse'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'type'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relationships'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'relatedType'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relatedWith'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'candidateSets'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relationship'  ( refToType 'CandidateSet' 'candidates'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOFmetaRelationship'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaRelationship'  ( refToType 'BranchConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFreplicatedMetaRelationship'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'replicatedMetaRelationship'  ( refToType 'ReplicateBranchMgr' 'replication'  )  ) 
			   )

			  ( relationship 'inverseOFtargetToTransfomations'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'targetToTransfomations'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverseOFprojectionToOriginals'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'projectionToOriginals'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverseOFprojectedToProjections'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'projectedToProjections'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverseOFtransformationToSources'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'transformationToSources'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'inverseOFtransformationToSubTransformations'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'transformationToSubTransformations'  ( refToType 'ProjectionConfig' 'projection'  )  ) 
			   )

			  ( relationship 'type'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relationships'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'relatedType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relatedWith'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'inverse'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'inverse'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			  ( relationship 'candidateSets'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'relationship'  ( refToType 'CandidateSet' 'candidates'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'StructuralFeature'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Element' 'core'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'Attribute'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'StructuralFeature' 'core'))
			nil
			(attributes
			  ( relationship 'inverseOFmetaAttribute'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaAttribute'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFcopiedMetaAttribute'
				nil nil
				nil
				nil
				Many nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'copiedMetaAttribute'  ( refToType 'CopyFieldMgr' 'replication'  )  ) 
			   )

			  ( relationship 'type'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributes'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'valueType'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'typeOfValues'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'inverseOFmetaAttribute'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'metaAttribute'  ( refToType 'AttributeConfig' 'traversal'  )  ) 
			   )

			  ( relationship 'inverseOFcopiedMetaAttribute'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'copiedMetaAttribute'  ( refToType 'CopyFieldMgr' 'replication'  )  ) 
			   )

			  ( relationship 'type'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'attributes'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'valueType'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'typeOfValues'  ( refToType 'Type' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Parameter'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Element' 'core'))
			nil
			(attributes
			  ( relationship 'element'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'parameters'  ( refToType 'Element' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'element'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'parameters'  ( refToType 'Element' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Comment'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Element' 'core'))
			nil
			(attributes
			  ( relationship 'element'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'comments'  ( refToType 'Element' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'element'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'comments'  ( refToType 'Element' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Element'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'parameters'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'element'  ( refToType 'Parameter' 'core'  )  ) 
			   )

			  ( relationship 'comments'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'element'  ( refToType 'Comment' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'parameters'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'element'  ( refToType 'Parameter' 'core'  )  ) 
			   )

			  ( relationship 'comments'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'element'  ( refToType 'Comment' 'core'  )  ) 
			   )

			 )
			nil
		   )

		 )
		nil
	   )

	  ( module 'observe'
		nil nil
		nil
		nil
		nil nil
		(types
		  ( type 'ObserverBranchMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'BranchMgr' 'traversal') #(#refToType 'AbstractObserver' 'observe'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'ObserverNodeMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'NodeMgr' 'traversal') #(#refToType 'AbstractObserver' 'observe'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'ObserverFieldMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'FieldMgr' 'traversal') #(#refToType 'AbstractObserver' 'observe'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'InterestRegistration'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'TraversalConfig' 'traversal'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'ObserverRootTypeNodeMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'RootTypeNodeMgr' 'traversal') #(#refToType 'AbstractObserver' 'observe'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'AbstractObserver'
			nil nil
			nil
			nil
			true false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'BehaviorOwner' 'behavior'))
			nil
			nil
			nil
			nil
		   )

		 )
		nil
	   )

	  ( module 'candidates'
		nil nil
		nil
		nil
		nil nil
		(types
		  ( type 'CandidateSet'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'TraversalConfig' 'traversal'))
			nil
			(attributes
			  ( relationship 'type'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'candidateSets'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'relationship'
				nil nil
				nil
				nil
				References nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'candidateSets'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'type'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'candidateSets'  ( refToType 'Type' 'core'  )  ) 
			   )

			  ( relationship 'relationship'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'candidateSets'  ( refToType 'Relationship' 'core'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'CandidateBranchMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'BranchMgr' 'traversal') #(#refToType 'CandidateSelector' 'candidates'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'CandidateFieldMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'FieldMgr' 'traversal') #(#refToType 'CandidateSelector' 'candidates'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'CandidateNodeMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'NodeMgr' 'traversal') #(#refToType 'CandidateSelector' 'candidates'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'CandidateRootTypeNodeMgr'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'RootTypeNodeMgr' 'traversal') #(#refToType 'CandidateSelector' 'candidates'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'CandidateSelector'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'BehaviorOwner' 'behavior'))
			nil
			nil
			nil
			nil
		   )

		 )
		nil
	   )

	  ( module 'behavior'
		nil nil
		nil
		nil
		nil nil
		(types
		  ( type 'Behavior'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'behaviorOwner'
				nil nil
				nil
				nil
				IsPartOf nil
				#'1' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'behaviors'  ( refToType 'BehaviorOwner' 'behavior'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'behaviorOwner'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'behaviors'  ( refToType 'BehaviorOwner' 'behavior'  )  ) 
			   )

			 )
			nil
		   )

		  ( type 'Scriptable'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Behavior' 'behavior'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'Executable'
			nil nil
			nil
			nil
			false false false
			nil nil
			nil
			false false false false
			#(#supertypes #(#refToType 'Behavior' 'behavior'))
			nil
			nil
			nil
			nil
		   )

		  ( type 'BehaviorOwner'
			nil nil
			nil
			nil
			true false false
			nil nil
			nil
			false false false false
			nil
			nil
			(attributes
			  ( relationship 'behaviors'
				nil nil
				nil
				nil
				Aggregates nil
				#'0' #*
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'behaviorOwner'  ( refToType 'Behavior' 'behavior'  )  ) 
			   )

			 )
			(relationships
			  ( relationship 'behaviors'
				nil nil
				nil
				nil
				REFERENCES nil
				#'0' #'1'
				false false true false false true true
				NOCOMPUTATION
				''
				''
				''
				''
				( refToInverseRelationship 'behaviorOwner'  ( refToType 'Behavior' 'behavior'  )  ) 
			   )

			 )
			nil
		   )

		 )
		nil
	   )

	 )
	nil nil
   )!

ojoModel! !

!CODEModel class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^super modelEditorMETAPerspectives , self modelEditorMETAPerspectivesModel!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'IsDirty' 'StoreClassName' 'StoreMethodSelector'  'DefaultApplicationTranslationStoreClassName'  'DefaultApplicationTranslationStoreMethodSelector')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesModel

	^OrderedCollection new
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsModel!

modelEditorMETASelectorsModel

	"METAChildSpecAutoViewEditor openOn: CODEModel selector: #modelEditorMETASelectorsModel target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'DefaultApplicationTranslationStoreClassName';
			basicSelector: #defaultApplicationTranslationStoreClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'DefaultApplicationTranslationStoreClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'DefaultApplicationTranslationStoreClassName';
			nlsTranslation: 'NombreDeClaseDeGrabacionDeTraduccion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'DefaultApplicationTranslationStoreMethodSelector';
			basicSelector: #defaultApplicationTranslationStoreMethodSelector;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'DefaultApplicationTranslationStoreMethodSelector';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'DefaultApplicationTranslationStoreMethodSelector';
			nlsTranslation: 'SelectorDeGrabacionDeTraduccion';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsModel.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsModel

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #()!

modelEditorPathSelectorsModule

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('SubModules' 'Types'  'AllTypes' 'AllNonAbstractTypes')!

xmetaSelectors

	"METAChildSpecAutoViewEditor openOn: CODEModel selector: #metaSelectors target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 10)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Name';
			basicSelector: #name;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Name';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SourceFileName';
			basicSelector: #sourceFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SourceFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ExpansionDelimiterString';
			basicSelector: #expansionDelimiterString;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ExpansionDelimiterString';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Package';
			basicSelector: #package;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Package';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TemplatesDirectory';
			basicSelector: #templatesDirectory;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TemplatesDirectory';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'OutputDirectory';
			basicSelector: #outputDirectory;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'OutputDirectory';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypePrefix';
			basicSelector: #typePrefix;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypePrefix';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelationshipVariablePrefix';
			basicSelector: #relationshipVariablePrefix;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelationshipVariablePrefix';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AttributeVariablePrefix';
			basicSelector: #attributeVariablePrefix;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AttributeVariablePrefix';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Modules';
			basicSelector: #subModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Modules';
			displaySelector: #name;
			componentsClassName: #CODEModule;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Types';
			basicSelector: #types;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RootTypes';
			basicSelector: #rootTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types without Supertypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllTypes';
			basicSelector: #allTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'All the Types in the Model and modules';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		yourself! !

!CODEModel class publicMethodsFor: 'persistence examples'!

persistenceExample01
	"CODEModel persistenceExample01"
	"CODEModel persistenceExample01 browsePath"

	| unModel unModuleGeneral unTypeConceptoGeneral unTypeComparecenciaGeneral unTypeGestionGeneral unTypeParticipacionGeneral unValorEntero unValorDecimal unValorMoneda unValorFecha unValorHora unValorLetras unValorLogico unModuleClinica unTypeConceptoClinico unTypeComparecenciaClinico unTypeGestionClinico unTypeParticipacionClinico unModuleFinanciera unTypeConceptoFinanciero unTypeComparecenciaFinanciero unTypeGestionFinanciero unTypeParticipacionFinanciero unModuleControl unTypeConceptoControl unTypeComparecenciaControl unTypeGestionControl unTypeParticipacionControl unModuleIncidencia unTypeConceptoIncidencia unTypeComparecenciaIncidencia unTypeGestionIncidencia unTypeParticipacionIncidencia |
	unModel := CODEModel new name: 'Clinicas'.
	unModuleGeneral := CODEModule new name: 'General'.
	unModel subModulesAdd: unModuleGeneral.

	unTypeConceptoGeneral := CODEType new name: 'ConceptoGeneral'.
	unModuleGeneral typesAdd: unTypeConceptoGeneral.
	unTypeComparecenciaGeneral := CODEType new name: 'ComparecenciaGeneral'.
	unModuleGeneral typesAdd: unTypeComparecenciaGeneral.
	unTypeGestionGeneral := CODEType new name: 'GestionGeneral'.
	unModuleGeneral typesAdd: unTypeGestionGeneral.
	unTypeParticipacionGeneral := CODEType new name: 'ParticipacionGeneral'.
	unModuleGeneral typesAdd: unTypeParticipacionGeneral.

	unValorEntero := CODEType new name: 'Entero'.
	unModuleGeneral typesAdd: unValorEntero.
	unValorDecimal := CODEType new name: 'Decimal'.
	unModuleGeneral typesAdd: unValorDecimal.
	unValorMoneda := CODEType new name: 'Moneda'.
	unModuleGeneral typesAdd: unValorMoneda.
	unValorFecha := CODEType new name: 'Fecha'.
	unModuleGeneral typesAdd: unValorFecha.
	unValorHora := CODEType new name: 'Hora'.
	unModuleGeneral typesAdd: unValorHora.
	unValorLetras := CODEType new name: 'Letras'.
	unModuleGeneral typesAdd: unValorLetras.
	unValorLogico := CODEType new name: 'Logico'.
	unModuleGeneral typesAdd: unValorLogico.



	unModuleClinica := CODEModule new name: 'Clinica'.
	unModel subModulesAdd: unModuleClinica.

	unTypeConceptoClinico := CODEType new name: 'ConceptoClinica'.
	unModuleClinica typesAdd: unTypeConceptoClinico.
	unTypeComparecenciaClinico := CODEType new name: 'ComparecenciaClinica'.
	unModuleClinica typesAdd: unTypeComparecenciaClinico.
	unTypeGestionClinico := CODEType new name: 'GestionClinica'.
	unModuleClinica typesAdd: unTypeGestionClinico.
	unTypeParticipacionClinico := CODEType new name: 'ParticipacionClinica'.
	unModuleClinica typesAdd: unTypeParticipacionClinico.

	unTypeConceptoGeneral subTypesAdd: unTypeConceptoClinico.
	unTypeComparecenciaGeneral subTypesAdd: unTypeComparecenciaClinico.
	unTypeGestionGeneral subTypesAdd: unTypeGestionClinico.
	unTypeParticipacionGeneral subTypesAdd: unTypeParticipacionClinico.

	unModuleFinanciera := CODEModule new name: 'Financiera'.
	unModel subModulesAdd: unModuleFinanciera.

	unTypeConceptoFinanciero := CODEType new name: 'ConceptoFinanciero'.
	unModuleFinanciera typesAdd: unTypeConceptoFinanciero.
	unTypeComparecenciaFinanciero := CODEType new name: 'ComparecenciaFinanciera'.
	unModuleFinanciera typesAdd: unTypeComparecenciaFinanciero.
	unTypeGestionFinanciero := CODEType new name: 'GestionFinanciera'.
	unModuleFinanciera typesAdd: unTypeGestionFinanciero.
	unTypeParticipacionFinanciero := CODEType new name: 'ParticipacionFinanciera'.
	unModuleFinanciera typesAdd: unTypeParticipacionFinanciero.

	unTypeConceptoGeneral subTypesAdd: unTypeConceptoFinanciero.
	unTypeComparecenciaGeneral subTypesAdd: unTypeComparecenciaFinanciero.
	unTypeGestionGeneral subTypesAdd: unTypeGestionFinanciero.
	unTypeParticipacionGeneral subTypesAdd: unTypeParticipacionFinanciero.

	unModuleControl := CODEModule new name: 'Control'.
	unModel subModulesAdd: unModuleControl.

	unTypeConceptoControl := CODEType new name: 'ConceptoControl'.
	unModuleControl typesAdd: unTypeConceptoControl.
	unTypeComparecenciaControl := CODEType new name: 'ComparecenciaControl'.
	unModuleControl typesAdd: unTypeComparecenciaControl.
	unTypeGestionControl := CODEType new name: 'GestionControl'.
	unModuleControl typesAdd: unTypeGestionControl.
	unTypeParticipacionControl := CODEType new name: 'ParticipacionControl'.
	unModuleControl typesAdd: unTypeParticipacionControl.

	unTypeConceptoGeneral subTypesAdd: unTypeConceptoControl.
	unTypeComparecenciaGeneral subTypesAdd: unTypeComparecenciaControl.
	unTypeGestionGeneral subTypesAdd: unTypeGestionControl.
	unTypeParticipacionGeneral subTypesAdd: unTypeParticipacionControl.

	unModuleIncidencia := CODEModule new name: 'Incidencia'.
	unModel subModulesAdd: unModuleIncidencia.

	unTypeConceptoIncidencia := CODEType new name: 'ConceptoIncidencia'.
	unModuleIncidencia typesAdd: unTypeConceptoIncidencia.
	unTypeComparecenciaIncidencia := CODEType new name: 'ComparecenciaIncidencia'.
	unModuleIncidencia typesAdd: unTypeComparecenciaIncidencia.
	unTypeGestionIncidencia := CODEType new name: 'GestionIncidencia'.
	unModuleIncidencia typesAdd: unTypeGestionIncidencia.
	unTypeParticipacionIncidencia := CODEType new name: 'ParticipacionIncidencia'.
	unModuleIncidencia typesAdd: unTypeParticipacionIncidencia.

	unTypeConceptoGeneral subTypesAdd: unTypeConceptoIncidencia.
	unTypeComparecenciaGeneral subTypesAdd: unTypeComparecenciaIncidencia.
	unTypeGestionGeneral subTypesAdd: unTypeGestionIncidencia.
	unTypeParticipacionGeneral subTypesAdd: unTypeParticipacionIncidencia.
	
	
	^unModel!

persistenceExample02
	"CODEModel persistenceExample02"
	"CODEModel persistenceExample02 browsePath"


	| unModel unType_01_01 unType_01_02 unType_02_01 unType_02_02 unAttrib_01_01_01 unAttrib_01_01_02 unModule_01 unModule_02 unModule_03 unType_03_01 unType_03_02 unAttrib_03_01_01 unAttrib_03_01_02 unModule_04 unType_04_01 unType_04_02 unaRel_04_01_03_01 unaRel_03_01_04_01 unaRel_01_01_03_01 unaRel_04_01_01_01 |

	unModel := CODEModel new name: 'Model01'.
	unModel storeClassName: #CODEModel.
	unModel storeMethodSelector: #testStoreModelExample02.


	unModule_01 := CODEModule new name: 'Module_01'.
	unModel subModulesAdd: unModule_01.

	unType_01_01 := CODEType new name: 'Type_01_01'.
	unModule_01 typesAdd: unType_01_01.


	unType_01_02 := CODEType new name: 'Type_01_02'.
	unModule_01 typesAdd: unType_01_02.

	unModule_02 := CODEModule new name: 'Module_02'.
	unModel subModulesAdd: unModule_02.

	unType_02_01 := CODEType new name: 'Type_02_01'.
	unModule_02 typesAdd: unType_02_01.
	unType_02_02 := CODEType new name: 'Type_02_02'.
	unModule_02 typesAdd: unType_02_02.

	
	unAttrib_01_01_01 := CODEAttribute new name: 'Attrib_01_01_01'.
	unType_01_01 attributesAdd: unAttrib_01_01_01.
	unAttrib_01_01_01 valueType: unType_02_01.
	unAttrib_01_01_02 := CODEAttribute new name: 'Attrib_01_01_02'.
	unType_01_01 attributesAdd: unAttrib_01_01_02.
	unAttrib_01_01_02 valueType: unType_02_02.


	unModule_03 := CODEModule new name: 'Module_03'.
	unModel subModulesAdd: unModule_03.

	unType_03_01 := CODEType new name: 'Type_03_01'.
	unModule_03 typesAdd: unType_03_01.
	unType_03_02 := CODEType new name: 'Type_03_02'.
	unModule_03 typesAdd: unType_03_02.


	unAttrib_03_01_01 := CODEAttribute new name: 'Attrib_03_01_01'.
	unType_03_01 attributesAdd: unAttrib_03_01_01.
	unAttrib_03_01_01 valueType: unType_01_01.
	unAttrib_03_01_02 := CODEAttribute new name: 'Attrib_03_01_02'.
	unType_03_01 attributesAdd: unAttrib_03_01_02.
	unAttrib_03_01_02 valueType: unType_01_02.

	unType_03_01 superTypesAdd: unType_01_01.
	unType_03_01 superTypesAdd: unType_01_02.
	unType_03_02 superTypesAdd: unType_01_01.
	unType_03_02 superTypesAdd: unType_01_02.

	unModule_04 := CODEModule new name: 'Module_04'.
	unModel subModulesAdd: unModule_04.

	unType_04_01 := CODEType new name: 'Type_04_01'.
	unModule_04 typesAdd: unType_04_01.
	unType_04_02 := CODEType new name: 'Type_04_02'.
	unModule_04 typesAdd: unType_04_02.


	unaRel_04_01_03_01 := CODERelationship new name: 'Rel_04_01_03_01'.
	unaRel_04_01_03_01 type: unType_04_01.
	unaRel_04_01_03_01 relatedType: unType_03_01.
	unaRel_04_01_03_01 relationshipKind: CODERelationship aggregatesRelationshipKind.
	unaRel_04_01_03_01 minMult: CODERelationship minMultOptional.
	unaRel_04_01_03_01 maxMult: CODERelationship maxMultMany.

	unaRel_03_01_04_01 := CODERelationship new name: 'Rel_03_01_04_01'.
	unaRel_03_01_04_01 type: unType_03_01.
	unaRel_03_01_04_01 relatedType: unType_04_01.
	unaRel_03_01_04_01 relationshipKind: CODERelationship isAggregatedRelationshipKind.
	unaRel_03_01_04_01 minMult: CODERelationship minMultRequired.
	unaRel_03_01_04_01 maxMult: CODERelationship maxMultRequired.

	unaRel_04_01_03_01 inverse: unaRel_03_01_04_01.

	
	unaRel_01_01_03_01 := CODERelationship new name: 'Rel_01_01_03_01'.
	unaRel_01_01_03_01 type: unType_01_01.
	unaRel_01_01_03_01 relatedType: unType_04_01.
	unaRel_01_01_03_01 relationshipKind: CODERelationship isAggregatedRelationshipKind.
	unaRel_01_01_03_01 minMult: CODERelationship minMultOptional.
	unaRel_01_01_03_01 maxMult: CODERelationship maxMultMany.

	unaRel_04_01_01_01 := CODERelationship new name: 'Rel_04_01_01_01'.
	unaRel_04_01_01_01 type: unType_04_01.
	unaRel_04_01_01_01 relatedType: unType_01_01.
	unaRel_04_01_01_01 relationshipKind: CODERelationship isAggregatedRelationshipKind.
	unaRel_04_01_01_01 minMult: CODERelationship minMultRequired.
	unaRel_04_01_01_01 maxMult: CODERelationship maxMultRequired.

	unaRel_01_01_03_01 inverse: unaRel_04_01_01_01.

	^unModel!

persistEx02
	"CODEModel persistEx02 first at: 2"

	^CODEModel persistenceExample02 persistenceAsCodeStringChunksFilter: #source doSubChunks: true!

persistEx03
	"CODEModel persistEx03 first at: 2"

	^CODEModel persistenceExample02 persistenceAsCodeString!

persistEx04
	"CODEModel persistEx04 "

	^CODEGenInstaller  persistModel: CODEModel persistenceExample02 filter: #source! !

!CODEModel class publicMethodsFor: 'persistence-utils'!

allModelsClassesAndStoreSelectorsInSystem
	"CODEModel allModelsClassesAndStoreSelectorsInSystem"

	| someCandidates |

	someCandidates := OrderedCollection new: 32.
Cursor wait showWhile: [
	Smalltalk allClassesDo: [:aClass |

		(((aClass  class whichSelectorsReferTo: 'ojoModel' asSymbol) reject: [:aSelector | 
			aSelector = 'ojoModel' asSymbol or: [aSelector numArgs > 0]
		]) do: [:aSelector |  | aMethodReturnValue |
			aMethodReturnValue := nil.
			Signal errorSignal handle: [:anException | ] do: [ aMethodReturnValue := aClass perform: aSelector].
			(aMethodReturnValue isNil not and: [(aMethodReturnValue isKindOf: Array) and: [ 
				aMethodReturnValue first = CODEModel kind and: [ 
					(aMethodReturnValue at: 7) = aClass name and: [ 
						(aMethodReturnValue at: 8) = aSelector
					]
				]
			]]) ifTrue: [
				someCandidates add: (Array with: aClass with: aSelector)	
			]
		]).

	].
].
	^someCandidates!

allModelsInSystem
	"CODEModel allModelsInSystem"

	| someCandidates |

	someCandidates := OrderedCollection new: 32.
Cursor wait showWhile: [
	Smalltalk allClassesDo: [:aClass |

		(((aClass  class whichSelectorsReferTo: 'ojoModel' asSymbol) reject: [:aSelector | 
			aSelector = 'ojoModel' asSymbol or: [aSelector numArgs > 0]
		]) do: [:aSelector |  | aMethodReturnValue aModel |
			aMethodReturnValue := nil.
			Signal errorSignal handle: [:anException | ] do: [ aMethodReturnValue := aClass perform: aSelector].
			(aMethodReturnValue isNil not and: [(aMethodReturnValue isKindOf: Array) and: [ 
				aMethodReturnValue first = CODEModel kind and: [ 
					(aMethodReturnValue at: 7) = aClass name and: [ 
						(aMethodReturnValue at: 8) = aSelector and: [ 
						aModel := nil.
						Signal errorSignal handle: [:anException | ] do: [ 
							aModel := CODEElement newFromPersistenceAsCode: aMethodReturnValue
						].
						aModel isNil not and: [ (aModel isKindOf: CODEModel) and: [ 
							aModel storeClassName = aClass name and: [ aModel storeMethodSelector = aSelector]]]
						]
				]]
			]]) ifTrue: [ someCandidates add: aModel]
		]).

	].
].
	^someCandidates! !

!CODEModel class publicMethodsFor: 'symbols'!

generationStyleDynamic
	^'dynamic' copy!

generationStyleDynamicReduced
	^'dynamicreduced' copy!

generationStyles
	^Array with: self generationStyleDynamic with: self generationStyleDynamicReduced!

generationStyleStatic
	^'static' copy! !

!CODEModel class publicMethodsFor: 'utils'!

insertCloneBaseMethodInFile: theFileName
	
	| aFilename aStream aSource aWriteStream aBackupFileName aBackupFilename |
	theFileName isNil ifTrue: [ ^self].

	Transcript show: 'insertCloneBaseMethodInFile: ', theFileName; cr.

	aFilename := theFileName asFilename.
	aFilename exists ifFalse: [ 
		Transcript show: 'insertCloneBaseMethodInFile: ', theFileName , ' does not exists'; cr.
		^self].


	aFilename isDirectory ifTrue: [ 
		^self insertCloneBaseMethodInFolder: theFileName].


	aStream := nil.
	aSource := nil.
	[ 
		aStream := aFilename readStream.
		aSource := aStream contents
	]
		valueNowOrOnUnwindDo: [
		aStream isNil ifFalse: [ aStream close]
	].
	
	aSource isNil ifTrue: [ ^self].

	aBackupFileName := theFileName ,'.bak'.
	aBackupFilename := aBackupFileName asFilename.
	aBackupFilename exists ifTrue: [ 
		Transcript show: 'Deleting', aBackupFileName; cr.
		aBackupFilename delete].

	aFilename renameTo: aBackupFileName.

	aWriteStream := nil.
	[ 
		aWriteStream := aFilename writeStream.
		self insertCloneBaseMethodInStream: aWriteStream from: aSource
	]
		valueNowOrOnUnwindDo: [
		aWriteStream isNil ifFalse: [ aWriteStream close]
	].!

insertCloneBaseMethodInFolder: theFolderName
	"CODEModel insertCloneBaseMethodInFolder: 'Q:\BXS\EAI\Studio\EAIBrowser01\mySrc\com\d_a_t\eai\studio\browser\custommgrs'"

	| aFilename someContents |
	theFolderName isNil ifTrue: [ ^self].

	Transcript show: 'insertCloneBaseMethodInFolder: ', theFolderName; cr.

	aFilename := theFolderName asFilename.
	aFilename exists ifFalse: [ 
		Transcript show: 'insertCloneBaseMethodInFolder: ', theFolderName , ' does not exists'; cr.
		^self].

	aFilename isDirectory ifFalse: [ 
		^self insertCloneBaseMethodInFile: theFolderName].

	someContents := aFilename directoryContents.
	someContents isNil ifTrue: [ ^self].

	someContents do: [:aContentFileName | | aContentPathName |
		('*.java' match: aContentFileName) ifTrue: [ 
			aContentPathName := aFilename constructString: aContentFileName.
			self insertCloneBaseMethodInFile: aContentPathName].
	].!

insertCloneBaseMethodInStream: theWriteStream from: theSource
	
	| aStream aStart  anInsert  |
	anInsert := 
'        public EAIActionIfc cloneBase() throws CloneNotSupportedException {
		  @ anAction = new @( vTargetNode);
		  anAction.setIcon( getIcon());
		  anAction.setName( getName());
		  return anAction;
		}
'.
	theWriteStream isNil ifTrue: [ ^self].
	theSource 		isNil ifTrue: [ ^self].

	aStream := ReadStream on: theSource.
	aStart := 'protected class extends' size.

	[ aStream atEnd] whileFalse: [ | aLine someTokens aNewInsert |

		aLine := aStream upTo: Character cr.
		theWriteStream nextPutAll: aLine; cr.
		(aLine findString: 'EAIAction' startingAt: aStart) > 0 
			ifTrue: [ 
				someTokens := aLine asArrayOfSubstrings.
				(someTokens size = 6 and: [
					 someTokens first = 'protected' and: [
						(someTokens at: 2) = 'class' and: [
						(someTokens at: 4) = 'extends' and: [
						(someTokens at: 5) = 'EAIAction' and: [
						(someTokens at: 6) = '{' ]]]]])
					ifTrue: [ 
						aNewInsert := anInsert copyReplaceAll: '@' with: (someTokens at: 3).
						theWriteStream nextPutAll: aNewInsert.

						Transcript show: 'INSERTED ' , (someTokens at: 3); cr
					]

		]
	]! !

!CODEModel publicMethodsFor: 'accessing'!

aspectToGenerate
	"Generated by ISF/AD. Do not modify"
	aspectToGenerate isNil
		ifTrue: [self initAspectToGenerate].
	^aspectToGenerate!

aspectToGenerate: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAspectToGenerate: aValue) ifFalse: [^aValue].
	aspectToGenerate := aValue.
	self changed: #aspectToGenerate!

attributeVariablePrefix
	"Generated by ISF/AD. Do not modify"
	attributeVariablePrefix isNil
		ifTrue: [self initAttributeVariablePrefix].
	^attributeVariablePrefix!

attributeVariablePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAttributeVariablePrefix: aValue) ifFalse: [^aValue].
	attributeVariablePrefix := aValue.
	self changed: #attributeVariablePrefix!

browserFrameworkPackage
	"Generated by ISF/AD. Do not modify"
	browserFrameworkPackage isNil
		ifTrue: [self initBrowserFrameworkPackage].
	^browserFrameworkPackage!

browserFrameworkPackage: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkBrowserFrameworkPackage: aValue) ifFalse: [^aValue].
	browserFrameworkPackage := aValue.
	self changed: #browserFrameworkPackage!

checkM3FactoryName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

defaultSuperTypeFullBaseClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullBaseClassName isNil
		ifTrue: [self initDefaultSuperTypeFullBaseClassName].
	^defaultSuperTypeFullBaseClassName!

defaultSuperTypeFullBaseClassName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDefaultSuperTypeFullBaseClassName: aValue) ifFalse: [^aValue].
	defaultSuperTypeFullBaseClassName := aValue.
	self changed: #defaultSuperTypeFullBaseClassName!

defaultSuperTypeFullIfcClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullIfcClassName isNil
		ifTrue: [self initDefaultSuperTypeFullIfcClassName].
	^defaultSuperTypeFullIfcClassName!

defaultSuperTypeFullIfcClassName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDefaultSuperTypeFullIfcClassName: aValue) ifFalse: [^aValue].
	defaultSuperTypeFullIfcClassName := aValue.
	self changed: #defaultSuperTypeFullIfcClassName!

defaultSuperTypeFullImplClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullImplClassName isNil
		ifTrue: [self initDefaultSuperTypeFullImplClassName].
	^defaultSuperTypeFullImplClassName!

defaultSuperTypeFullImplClassName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDefaultSuperTypeFullImplClassName: aValue) ifFalse: [^aValue].
	defaultSuperTypeFullImplClassName := aValue.
	self changed: #defaultSuperTypeFullImplClassName!

defaultSuperTypeFullPrivClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullPrivClassName isNil
		ifTrue: [self initDefaultSuperTypeFullPrivClassName].
	^defaultSuperTypeFullPrivClassName!

defaultSuperTypeFullPrivClassName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDefaultSuperTypeFullPrivClassName: aValue) ifFalse: [^aValue].
	defaultSuperTypeFullPrivClassName := aValue.
	self changed: #defaultSuperTypeFullPrivClassName!

defaultSuperTypeFullPubClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullPubClassName isNil
		ifTrue: [self initDefaultSuperTypeFullPubClassName].
	^defaultSuperTypeFullPubClassName!

defaultSuperTypeFullPubClassName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDefaultSuperTypeFullPubClassName: aValue) ifFalse: [^aValue].
	defaultSuperTypeFullPubClassName := aValue.
	self changed: #defaultSuperTypeFullPubClassName!

defaultSuperTypeFullTrxClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullTrxClassName isNil
		ifTrue: [self initDefaultSuperTypeFullTrxClassName].
	^defaultSuperTypeFullTrxClassName!

defaultSuperTypeFullTrxClassName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDefaultSuperTypeFullTrxClassName: aValue) ifFalse: [^aValue].
	defaultSuperTypeFullTrxClassName := aValue.
	self changed: #defaultSuperTypeFullTrxClassName!

enumVariablePrefix
	"Generated by ISF/AD. Do not modify"
	enumVariablePrefix isNil
		ifTrue: [self initEnumVariablePrefix].
	^enumVariablePrefix!

enumVariablePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkEnumVariablePrefix: aValue) ifFalse: [^aValue].
	enumVariablePrefix := aValue.
	self changed: #enumVariablePrefix!

expansionDelimiter
	"Generated by ISF/AD. Do not modify"
	expansionDelimiter isNil
		ifTrue: [self initExpansionDelimiter].
	^expansionDelimiter!

expansionDelimiter: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkExpansionDelimiter: aValue) ifFalse: [^aValue].
	expansionDelimiter := aValue.
	self changed: #expansionDelimiter!

expansionDelimiterString
	^String with: self expansionDelimiter!

expansionDelimiterString: aValue
	| aChar |
	aValue isNil ifTrue: [ ^self].
	aValue isEmpty ifTrue: [ ^self].
	
	aChar := aValue first.
	self expansionDelimiter: aChar!

frameworkPackage
	"Generated by ISF/AD. Do not modify"
	frameworkPackage isNil
		ifTrue: [self initFrameworkPackage].
	^frameworkPackage!

frameworkPackage: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkFrameworkPackage: aValue) ifFalse: [^aValue].
	frameworkPackage := aValue.
	self changed: #frameworkPackage!

generateSeparateActions
	"Generated by ISF/AD. Do not modify"
	generateSeparateActions isNil
		ifTrue: [self initGenerateSeparateActions].
	^generateSeparateActions!

generateSeparateActions: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkGenerateSeparateActions: aValue) ifFalse: [^aValue].
	generateSeparateActions := aValue.
	self changed: #generateSeparateActions!

generationStyle
	"Generated by ISF/AD. Do not modify"
	generationStyle isNil
		ifTrue: [self initGenerationStyle].
	^generationStyle!

generationStyle: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkGenerationStyle: aValue) ifFalse: [^aValue].
	generationStyle := aValue.
	self changed: #generationStyle!

isM3
	"Generated by ISF/AD. Do not modify"
	isM3 isNil
		ifTrue: [self initIsM3].
	^isM3!

isM3: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsM3: aValue) ifFalse: [^aValue].
	isM3 := aValue.
	self changed: #isM3!

m3FactoryName
	"Generated by ISF/AD. Do not modify"
	m3FactoryName isNil
		ifTrue: [self initM3FactoryName].
	^m3FactoryName!

m3FactoryName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkM3FactoryName: aValue) ifFalse: [^aValue].
	m3FactoryName := aValue.
	self changed: #m3FactoryName!

metaMetaPackage
	"Generated by ISF/AD. Do not modify"
	metaMetaPackage isNil
		ifTrue: [self initMetaMetaPackage].
	^metaMetaPackage!

metaMetaPackage: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMetaMetaPackage: aValue) ifFalse: [^aValue].
	metaMetaPackage := aValue.
	self changed: #metaMetaPackage!

metaPackage
	"Generated by ISF/AD. Do not modify"
	metaPackage isNil
		ifTrue: [self initMetaPackage].
	^metaPackage!

metaPackage: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMetaPackage: aValue) ifFalse: [^aValue].
	metaPackage := aValue.
	self changed: #metaPackage!

metaTraversalPackage
	"Generated by ISF/AD. Do not modify"
	metaTraversalPackage isNil
		ifTrue: [self initMetaTraversalPackage].
	^metaTraversalPackage!

metaTraversalPackage: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMetaTraversalPackage: aValue) ifFalse: [^aValue].
	metaTraversalPackage := aValue.
	self changed: #metaTraversalPackage!

metaVariablePrefix
	"Generated by ISF/AD. Do not modify"
	metaVariablePrefix isNil
		ifTrue: [self initMetaVariablePrefix].
	^metaVariablePrefix!

metaVariablePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMetaVariablePrefix: aValue) ifFalse: [^aValue].
	metaVariablePrefix := aValue.
	self changed: #metaVariablePrefix!

outputDirectory
	"Generated by ISF/AD. Do not modify"
	outputDirectory isNil
		ifTrue: [self initOutputDirectory].
	^outputDirectory!

outputDirectory: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOutputDirectory: aValue) ifFalse: [^aValue].
	outputDirectory := aValue.
	self changed: #outputDirectory!

package
	"Generated by ISF/AD. Do not modify"
	package isNil
		ifTrue: [self initPackage].
	^package!

package: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkPackage: aValue) ifFalse: [^aValue].
	package := aValue.
	self changed: #package!

projectDirectory
	"Generated by ISF/AD. Do not modify"
	projectDirectory isNil
		ifTrue: [self initProjectDirectory].
	^projectDirectory!

projectDirectory: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkProjectDirectory: aValue) ifFalse: [^aValue].
	projectDirectory := aValue.
	self changed: #projectDirectory!

projectName
	"Generated by ISF/AD. Do not modify"
	projectName isNil
		ifTrue: [self initProjectName].
	^projectName!

projectName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkProjectName: aValue) ifFalse: [^aValue].
	projectName := aValue.
	self changed: #projectName!

relationshipVariablePrefix
	"Generated by ISF/AD. Do not modify"
	relationshipVariablePrefix isNil
		ifTrue: [self initRelationshipVariablePrefix].
	^relationshipVariablePrefix!

relationshipVariablePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRelationshipVariablePrefix: aValue) ifFalse: [^aValue].
	relationshipVariablePrefix := aValue.
	self changed: #relationshipVariablePrefix!

rootTypeName
	"Generated by ISF/AD. Do not modify"
	rootTypeName isNil
		ifTrue: [self initRootTypeName].
	^rootTypeName!

rootTypeName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRootTypeName: aValue) ifFalse: [^aValue].
	rootTypeName := aValue.
	self changed: #rootTypeName!

serialVersionUIDPrefix
	"Generated by ISF/AD. Do not modify"
	serialVersionUIDPrefix isNil
		ifTrue: [self initSerialVersionUIDPrefix].
	^serialVersionUIDPrefix!

serialVersionUIDPrefix: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSerialVersionUIDPrefix: aValue) ifFalse: [^aValue].
	serialVersionUIDPrefix := aValue.
	self changed: #serialVersionUIDPrefix!

skipModules
	"Generated by ISF/AD. Do not modify"
	skipModules isNil
		ifTrue: [self initSkipModules].
	^skipModules!

skipModules: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSkipModules: aValue) ifFalse: [^aValue].
	skipModules := aValue.
	self changed: #skipModules!

skipTypes
	"Generated by ISF/AD. Do not modify"
	skipTypes isNil
		ifTrue: [self initSkipTypes].
	^skipTypes!

skipTypes: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSkipTypes: aValue) ifFalse: [^aValue].
	skipTypes := aValue.
	self changed: #skipTypes!

sourceFileName
	"Generated by ISF/AD. Do not modify"
	sourceFileName isNil
		ifTrue: [self initSourceFileName].
	^sourceFileName!

sourceFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSourceFileName: aValue) ifFalse: [^aValue].
	sourceFileName := aValue.
	self changed: #sourceFileName!

templatesDirectory
	"Generated by ISF/AD. Do not modify"
	templatesDirectory isNil
		ifTrue: [self initTemplatesDirectory].
	^templatesDirectory!

templatesDirectory: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTemplatesDirectory: aValue) ifFalse: [^aValue].
	templatesDirectory := aValue.
	self changed: #templatesDirectory!

typePrefix
	"Generated by ISF/AD. Do not modify"
	typePrefix isNil
		ifTrue: [self initTypePrefix].
	^typePrefix!

typePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypePrefix: aValue) ifFalse: [^aValue].
	typePrefix := aValue.
	self changed: #typePrefix! !

!CODEModel publicMethodsFor: 'accessing-private'!

forzeDefaultApplicationTranslationStoreClassName: theValue
	defaultApplicationTranslationStoreClassName := theValue!

forzeDefaultApplicationTranslationStoreMethodSelector: theValue
	defaultApplicationTranslationStoreMethodSelector := theValue! !

!CODEModel publicMethodsFor: 'associations accessing'!

types
	"Generated by ISF/AD. Do not modify"
	^self typesPrivate copy!

typesAsArray
	"Generated by ISF/AD. Do not modify"
	^self types asArray! !

!CODEModel publicMethodsFor: 'associations modifying'!

typesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesAdd: aValue) ifFalse: [^aValue].
	(self typesIncludes: aValue) ifTrue: [^self typesMoveBottom: aValue].
	(self typesPrivateAdd: aValue) modulePrivate: self.
	self changed: #types.
	^aValue!

typesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	self typesPrivate remove: aValue.
	^self typesPrivateAdd: aValue!

typesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	index = (self typesSize -1)
		ifTrue:
			[self typesPrivate remove: aValue.
			^self typesPrivateAdd: aValue].
	^self typesPrivateMove: aValue beforeIndex: index + 2!

typesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = 1 ifTrue: [^aValue].
	self typesPrivateMove: aValue beforeIndex: 1!

typesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = 1 ifTrue: [^aValue].
	^self typesPrivateMove: aValue beforeIndex: index - 1!

typesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesRemove: aValue) ifFalse: [^aValue].
	(self typesPrivate remove: aValue ifAbsent: [^aValue]) modulePrivate: nil.
	self changed: #types.
	^aValue! !

!CODEModel publicMethodsFor: 'associations private'!

typesPrivate
	"Generated by ISF/AD. Do not modify"
	types isNil
		ifTrue: [self initTypes].
	^types!

typesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate add: aValue.
	self changed: #types.
	^aValue!

typesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self types at: anIndex.
	self typesPrivate remove: aValue.
	self typesPrivate add: aValue before: obj.
	self changed: #types.
	^aValue!

typesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate remove: aValue.
	self changed: #types.
	^aValue! !

!CODEModel publicMethodsFor: 'associations testing'!

typesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [false]
		ifFalse: [self types includes: aValue]!

typesSize
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [0]
		 ifFalse: [types size]! !

!CODEModel publicMethodsFor: 'derived accessing'!

allModules
	^super allModules!

allModulesInto: theModules
	^super allModulesInto: theModules!

allPackageNames
	^'' copy!

definitionsHolderClass
	^nil!

definitionsHolderClassForInstances
	
	| aClassName aClass |
	aClassName := self definitionsHolderClassNameForInstances.
	(aClassName isNil or: [ aClassName isEmpty]) ifTrue: [  
		^self class defaultDefinitionsHolderClassForInstances
	].

	aClass := Smalltalk at: aClassName asSymbol ifAbsent: [nil].
	aClass  isBehavior ifFalse: [ ^nil].
	^aClass!

fullyQualifiedNameArray

	^Array new!

model
	^self!

packagesAsArray 
	^(self package copyReplaceAll: '.' with: ' ') asArrayOfSubstrings!

treeRootType
	rootType isNil ifFalse: [ ^rootType].
	rootTypeSearched == true ifTrue: [ ^nil].
 
	rootType := super treeRootType.
	rootTypeSearched := true.
	^rootType! !

!CODEModel publicMethodsFor: 'dirty'!

markDirty
	super markDirty.!

markDirtyOwner
	self mustStore 
		ifTrue: [ self markDirty]!

persistIfDirty
	| aNLSSolver |
	CODEGenInstaller persistModel: self  filter: #source.
	self cleanDirtyMark.

	aNLSSolver := self nlsSolver.
	aNLSSolver isNil ifFalse: [ aNLSSolver persistIfDirty].! !

!CODEModel publicMethodsFor: 'generate'!

generate

	self aspectToGenerate = CODEModel aspectToGenerateBrowser 
		ifFalse: [ 
			[ 
				self generateMetamodel.
				self generateWholeTraversalConfigFactory.
				self generateWholeReplicationConfigFactory.
			]
				valueNowOrOnUnwindDo:
			[
				prjOutStream isNil ifFalse: [ prjOutStream close. prjOutStream := nil].
				metamodelOutStream isNil ifFalse: [ metamodelOutStream close. metamodelOutStream := nil].
				wholeTraversalConfigOutStream isNil ifFalse: [ wholeTraversalConfigOutStream close. wholeTraversalConfigOutStream := nil].
			]	
		]
		ifTrue: [ 
			[ 
				self generateWholeTreeConfigFactory.
			]
				valueNowOrOnUnwindDo:
			[
				wholeTreeConfigOutStream isNil ifFalse: [ wholeTreeConfigOutStream close. wholeTreeConfigOutStream := nil].
			].
		].

	super generate!

generateM3ModelPhase1Initialization
	self metamodelOutStream
		tab; tab;
		nextPutAll: ' vm3Model = (',self metaModelFullIfcPrefixedClassName,') theCtxt.getMMFactory("', self m3FactoryName, 
			'").createMMElementOfType( theCtxt, "Model", "core",',
			'"', self name, '");';cr.

	self generateM3ModelPhase1InitializationSetAttr: 'typePrefix' value: self typePrefix.
	self generateM3ModelPhase1InitializationSetAttr: 'relationshipVariablePrefix' value: self relationshipVariablePrefix.
	self generateM3ModelPhase1InitializationSetAttr: 'attributeVariablePrefix' value: self attributeVariablePrefix.
	self generateM3ModelPhase1InitializationSetAttr: 'enumVariablePrefix' value: self enumVariablePrefix.
	self generateM3ModelPhase1InitializationSetAttr: 'metaVariablePrefix' value: self metaVariablePrefix.
	self generateM3ModelPhase1InitializationSetAttr: 'metaPackageName' value: self metaPackage.
	self generateM3ModelPhase1InitializationSetAttr: 'frameworkPackageName' value: self frameworkPackage.
	self generateM3ModelPhase1InitializationSetAttr: 'fromSpecificationFileNamed' value: self sourceFileName.
	self generateM3ModelPhase1InitializationSetAttr: 'packageName' value: self package.
	self generateM3ModelPhase1InitializationSetAttr: 'templatesDirectoryName' value: self templatesDirectory.
	self generateM3ModelPhase1InitializationSetAttr: 'projectName' value: self projectName.
	self generateM3ModelPhase1InitializationSetAttr: 'projectDirectoryName' value: self projectDirectory.
	self generateM3ModelPhase1InitializationSetAttr: 'outputDirectoryName' value: self outputDirectory.
	self generateM3ModelPhase1InitializationSetAttr: 'serialVersionUIDPrefix' value: self serialVersionUIDPrefix.
	self generateM3ModelPhase1InitializationSetAttr: 'skipTypes' value: self skipTypes.
	self generateM3ModelPhase1InitializationSetAttr: 'skipModules' value: self skipModules.
	self generateM3ModelPhase1InitializationSetAttr: 'defaultSuperTypeFullBaseClassName' value: self defaultSuperTypeFullBaseClassName.
	self generateM3ModelPhase1InitializationSetAttr: 'defaultSuperTypeFullIfcClassName' value: self defaultSuperTypeFullIfcClassName.
	self generateM3ModelPhase1InitializationSetAttr: 'defaultSuperTypeFullPrivClassName' value: self defaultSuperTypeFullPrivClassName.
	self generateM3ModelPhase1InitializationSetAttr: 'defaultSuperTypeFullPubClassName' value: self defaultSuperTypeFullPubClassName.
	self generateM3ModelPhase1InitializationSetAttr: 'defaultSuperTypeFullTrxClassName' value: self defaultSuperTypeFullTrxClassName.

	self metamodelOutStream cr.
	
"//    vm3Model = new com.d_a_t.eai.studio.m3.ifc.M3ModelImpl( new EAIMMName( 'EAIMetamodel'));
"!

generateM3ModelPhase1InitializationSetAttr: theAttrName value: theValue
	| aValue |
	theValue isNil ifTrue: [ ^self].

	aValue := self toSetAttributeArgumentValue: theValue.

	self metamodelOutStream
		tab; tab;
		nextPutAll: ' vm3Model.set';
		nextPutAll: (self toUpperInitial: theAttrName);
		nextPutAll: '( theCtxt, ';
		nextPutAll: aValue;
		nextPutAll: ');'; 
		cr!

generateM3ModelPhase2Initialization
	"self types do: [:aType |
		aType skip ifFalse: [ 
			self metamodelOutStream
				tab; tab;
				nextPutAll: ' vm3Model.addTypes( theCtxt, '; 
				nextPutAll: (aType expand: 'FullImplPrefixedClassName');
				nextPutAll: '.vm3Type);'; 
				cr
		]
	].

	self metamodelOutStream cr."
"
	vm3Model.addTypes( theCtxt, com.d_a_t.eai.studio.metamodel.impl.EAIProjectImpl.vm3Type);
	vm3Model.addTypes( theCtxt, com.d_a_t.eai.studio.metamodel.impl.EAIPackageImpl.vm3Type);
"!

generateM3ModuleInitialization
	| aPreviousPackage |
	aPreviousPackage := nil.
	self packagesAsArray do: [:aPackage |

		self  metamodelOutStream 
			tab; tab;
			nextPutAll:  'vm3Module', (self toUpperInitial: aPackage);
			nextPutAll: ' = (',self metaModuleFullIfcPrefixedClassName,') theCtxt.getMMFactory("', self m3FactoryName, 
			'").createMMElementOfType( theCtxt, "Module", "core",',
			'"', aPackage, '");';cr.

		aPreviousPackage isNil 
			ifTrue: [ 	
				self  metamodelOutStream 
					tab; tab;
					nextPutAll:  'vm3RootModule = vm3Module';
					nextPutAll: (self toUpperInitial: aPackage);
					nextPutAll: ';';
					cr.
				self  metamodelOutStream 
					tab; tab;
					nextPutAll:  'vm3Model.addSubModules( theCtxt, vm3Module';
					nextPutAll: (self toUpperInitial: aPackage);
					nextPutAll: ');';
					cr

			]
			ifFalse: [
			self  metamodelOutStream 
				tab; tab;
				nextPutAll:  'vm3Module', (self toUpperInitial: aPreviousPackage);
				nextPutAll: '.addSubModules( theCtxt, ';
				nextPutAll:  'vm3Module', (self toUpperInitial: aPackage);
				nextPutAll: ');';
				cr.
		].

		aPreviousPackage := aPackage
	].

	self  metamodelOutStream cr.

	self generateM3TypesInModuleInitializations.
	self metamodelOutStream cr.

	self subModules do: [:aModule | aModule generateM3ModuleInitialization].
	self metamodelOutStream cr.!

generateM3ModulesInitializations
	self generateM3ModuleInitialization.!

generateM3ModulesStorageDefinitions
 
	self allModules do: [:aModule | aModule generateM3StorageDefinition].
	self metamodelOutStream cr.!

generateM3StorageDefinition

	self packagesAsArray do: [:aPackage |
		self  metamodelOutStream 
			tab;
			nextPutAll: 'public static ', self metaModuleFullIfcPrefixedClassName, ' ';
			nextPutAll: 'vm3Module' , (self toUpperInitial: aPackage);
			nextPutAll: ';';
			cr; cr
"  public static com.d_a_t.eai.studio.m3.ifc.M3ModuleIfc vm3ComModule;
"
	]!

generateM3TraversalsInitializations

self  metamodelOutStream 
	tab; tab;
			nextPutAll: self metaTraversalConfigFullIfcPrefixedClassName,' aTraversalConfig = '; cr; 
			tab; tab;tab;nextPutAll: 'new ';nextPutAll: (self expand: 'FullPrefixedWholeTraversalConfig');
			nextPutAll: '( theCtxt, '; cr; 
			tab; tab;tab;nextPutAll: ' ',   (self expand: 'FullPrefixedWholeTraversalConfig'), 
				'.gTraversalConfigName, vm3Model);'; cr;
	tab; tab; nextPutAll: 'vm3Model.addTraversalConfigs( theCtxt, aTraversalConfig);'; cr; cr.

self  metamodelOutStream 
	tab; tab;
			nextPutAll:  self metaTraversalConfigFullIfcPrefixedClassName,' aReplicationConfig = '; cr; 
			tab; tab;tab;nextPutAll:  'new ';nextPutAll:  (self expand: 'FullPrefixedWholeReplicationConfig');
			nextPutAll: '( theCtxt, '; cr; 
			tab; tab;tab;nextPutAll: ' ',  (self expand: 'FullPrefixedWholeReplicationConfig'), 
				'.gTraversalConfigName, vm3Model);'; cr;
	tab; tab; nextPutAll: 'vm3Model.addTraversalConfigs( theCtxt, aReplicationConfig);'; cr; cr.!

generateMetamodel
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'metamodel'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self metamodelOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'M3ModelPhase1Initialization'
				ifTrue: [ self generateM3ModelPhase1Initialization]
				ifFalse: [
			aKey = 'M3TypesPhase1Initializations'
				ifTrue: [ self generateM3TypesPhase1Initializations]
				ifFalse: [ 
			aKey = 'M3ModulesStorageDefinitions'
				ifTrue: [ self generateM3ModulesStorageDefinitions]
				ifFalse: [ 
			aKey = 'M3ModelPhase2Initialization'
				ifTrue: [ self generateM3ModelPhase2Initialization]
				ifFalse: [
			aKey = 'M3TypesPhase2Initializations'
				ifTrue: [ self generateM3TypesPhase2Initializations]
				ifFalse: [ 
			aKey = 'M3ModulesInitializations'
				ifTrue: [ self generateM3ModulesInitializations]
				ifFalse: [ 

			aKey = 'M3TraversalsInitializations'
				ifTrue: [ self generateM3TraversalsInitializations]
				ifFalse: [ 

			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self metamodelOutStream nextPutAll: anExpansion]]]]]]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateNMgrBMgrConfigs
	super generateNMgrBMgrConfigs!

generateNMgrBmgrStaticDeclarations
	super generateNMgrBmgrStaticDeclarations!

generateProject
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'project'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self prjOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'ProjectNodeDeclarations'
				ifTrue: [ self generateProjectNodeDeclarations]
				ifFalse: [
			aKey = 'ProjectNodeParameters'
				ifTrue: [ self generateProjectNodeParameters]
				ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self prjOutStream nextPutAll: anExpansion]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateProjectNodeDeclarations
	| anStartIndex |
	anStartIndex := self startProjectNodeIndex.
	anStartIndex := self generateProjectNodeModuleDeclarations: anStartIndex.
	anStartIndex := self generateProjectNodeTypeDeclarations: anStartIndex.!

generateProjectNodeModuleDeclarations: theStartIndex
	| anStartIndex anStream |
	anStartIndex := theStartIndex.

	self typesSize > 0  ifTrue: [ 
		self baseOutPrjNdx: anStartIndex.
		self implOutPrjNdx: anStartIndex + 1.
		self ifcOutPrjNdx: anStartIndex + 2.
		self trxOutPrjNdx: anStartIndex + 3.
		self privOutPrjNdx: anStartIndex + 4.

		anStartIndex := anStartIndex + 5.

		anStream := self prjOutStream.
		anStream isNil ifTrue: [ ^anStartIndex].

		anStream nextPutAll: '#' , self baseOutPrjNdx printString, '=', self projectNodeBaseDeclarationName; cr.
		anStream nextPutAll: '#' , self implOutPrjNdx printString, '=',  self projectNodeImplDeclarationName; cr.
		anStream nextPutAll: '#' , self ifcOutPrjNdx printString, '=',  self projectNodeIfcDeclarationName; cr.
		anStream nextPutAll: '#' , self trxOutPrjNdx printString, '=',  self projectNodeTrxDeclarationName; cr.
		anStream nextPutAll: '#' , self privOutPrjNdx printString, '=',  self projectNodePrivDeclarationName; cr.
	].

	anStartIndex := self subModules inject: anStartIndex into:[:anIndex :aModule | 
		aModule generateProjectNodeModuleDeclarations: anIndex].
	^anStartIndex!

generateProjectNodeModuleParameters
	| anStream |

	self typesSize > 0 ifTrue: [ 
		anStream := self prjOutStream.
		anStream isNil ifFalse: [

			anStream nextPutAll: 'sys[' , self baseOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self baseOutPrjNdx printString, '].Type=Folder'; cr.
			anStream nextPutAll: 'sys[' , self implOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self implOutPrjNdx printString, '].Type=Folder'; cr.
			anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].Type=Folder'; cr.
			anStream nextPutAll: 'sys[' , self trxOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self trxOutPrjNdx printString, '].Type=Folder'; cr.
			anStream nextPutAll: 'sys[' , self privOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self privOutPrjNdx printString, '].Type=Folder'; cr.	
		]
	].

	self subModules do:[:aModule |  aModule generateProjectNodeModuleParameters].!

generateProjectNodeParameters

	self generateProjectNodeModuleParameters.
	self generateProjectNodeTypeParameters.!

generateRootNodeConfigs
	super generateRootNodeConfigs!

generateWholeReplicationConfigFactory
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'wholeReplicationConfigFactory'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	generatingReplicationTraversalConfig := true.
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self wholeTraversalConfigOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'TraversalRootTypeNodeCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalRootTypeNodeCfgsStaticDeclarations]
				ifFalse: [
			aKey = 'TraversalNodeCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalNodeCfgsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalNodeMgrsStaticDeclarations'
				ifTrue: [ self generateTraversalNodeMgrsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalBranchCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalBranchCfgsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalBranchMgrsStaticDeclarations'
				ifTrue: [ self generateTraversalBranchMgrsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalRelatedTypeNodeCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalRelatedTypeNodeCfgsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalAttributeCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalAttributeCfgsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalFieldMgrsStaticDeclarations'
				ifTrue: [ self generateTraversalFieldMgrsStaticDeclarations]
				ifFalse: [ 
			
			aKey = 'TraversalRootTypeNodeCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalRootTypeNodeCfgsStaticInstantiations]
				ifFalse: [
			aKey = 'TraversalNodeCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalNodeCfgsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalNodeMgrsStaticInstantiations'
				ifTrue: [ self generateTraversalNodeMgrsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalBranchCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalBranchCfgsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalBranchMgrsStaticInstantiations'
				ifTrue: [ self generateTraversalBranchMgrsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalRelatedTypeNodeCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalRelatedTypeNodeCfgsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalAttributeCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalAttributeCfgsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalFieldMgrsStaticInstantiations'
				ifTrue: [ self generateTraversalFieldMgrsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalNodeCfgsStaticInitializations'
				ifTrue: [ self generateTraversalNodeCfgsStaticInitializations]
				ifFalse: [ 
			aKey = 'TraversalBranchCfgsStaticInitializations'
				ifTrue: [ self generateTraversalBranchCfgsStaticInitializations]
				ifFalse: [ 
			
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self wholeTraversalConfigOutStream nextPutAll: anExpansion]]]]]]]]]]]]]]]]]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	wholeTraversalConfigOutStream isNil ifFalse: [ wholeTraversalConfigOutStream close. wholeTraversalConfigOutStream := nil].

	aTemplateStream isNil ifFalse: [ aTemplateStream close].
	generatingReplicationTraversalConfig := false
]!

generateWholeTraversalConfigFactory
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'wholeTraversalConfigFactory'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	generatingReplicationTraversalConfig := false.

	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self wholeTraversalConfigOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'TraversalRootTypeNodeCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalRootTypeNodeCfgsStaticDeclarations]
				ifFalse: [
			aKey = 'TraversalNodeCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalNodeCfgsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalNodeMgrsStaticDeclarations'
				ifTrue: [ self generateTraversalNodeMgrsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalBranchCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalBranchCfgsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalBranchMgrsStaticDeclarations'
				ifTrue: [ self generateTraversalBranchMgrsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalRelatedTypeNodeCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalRelatedTypeNodeCfgsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalAttributeCfgsStaticDeclarations'
				ifTrue: [ self generateTraversalAttributeCfgsStaticDeclarations]
				ifFalse: [ 
			aKey = 'TraversalFieldMgrsStaticDeclarations'
				ifTrue: [ self generateTraversalFieldMgrsStaticDeclarations]
				ifFalse: [ 
			
			aKey = 'TraversalRootTypeNodeCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalRootTypeNodeCfgsStaticInstantiations]
				ifFalse: [
			aKey = 'TraversalNodeCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalNodeCfgsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalNodeMgrsStaticInstantiations'
				ifTrue: [ self generateTraversalNodeMgrsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalBranchCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalBranchCfgsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalBranchMgrsStaticInstantiations'
				ifTrue: [ self generateTraversalBranchMgrsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalRelatedTypeNodeCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalRelatedTypeNodeCfgsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalAttributeCfgsStaticInstantiations'
				ifTrue: [ self generateTraversalAttributeCfgsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalFieldMgrsStaticInstantiations'
				ifTrue: [ self generateTraversalFieldMgrsStaticInstantiations]
				ifFalse: [ 
			aKey = 'TraversalNodeCfgsStaticInitializations'
				ifTrue: [ self generateTraversalNodeCfgsStaticInitializations]
				ifFalse: [ 
			aKey = 'TraversalBranchCfgsStaticInitializations'
				ifTrue: [ self generateTraversalBranchCfgsStaticInitializations]
				ifFalse: [ 
			
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self wholeTraversalConfigOutStream nextPutAll: anExpansion]]]]]]]]]]]]]]]]]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	wholeTraversalConfigOutStream isNil ifFalse: [ wholeTraversalConfigOutStream close. wholeTraversalConfigOutStream := nil].

	aTemplateStream isNil ifFalse: [ aTemplateStream close].
	generatingReplicationTraversalConfig := false.

]!

generateWholeTreeConfigFactory
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'wholeTreeConfigFactory'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self wholeTreeConfigOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'NMgrBmgrStaticDeclarations'
				ifTrue: [ self generateNMgrBmgrStaticDeclarations]
				ifFalse: [
			aKey = 'RootNodeConfigs'
				ifTrue: [ self generateRootNodeConfigs]
				ifFalse: [ 
			aKey = 'NMgrBMgrNodeConfigs'
				ifTrue: [ self generateNMgrBMgrConfigs]
				ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self wholeTreeConfigOutStream nextPutAll: anExpansion]]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

parentModuleNames
	^''! !

!CODEModel publicMethodsFor: 'generate-streams'!

initWholeReplicationConfigOutFileName
	wholeReplicationConfigOutFileName := self typePrefix, 'ReplicationConfig.java'!

initWholeTraversalConfigOutFileName
	wholeTraversalConfigOutFileName := self typePrefix, 'TraversalConfig.java'!

initWholeTreeConfigOutFileName
	wholeTreeConfigOutFileName := self typePrefix, self rootTypeName , 'TreeConfigFactory.java'!

metamodelOutStream	
	metamodelOutStream isNil ifTrue: [ self openMetamodelOutStream].
	^metamodelOutStream!

openMetamodelOutStream
	| aFileName aPath |

	aFileName := self name, '.java'.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self outputDirectoryWithPackageAndFolder: 'meta'),
		(String with: Filename separator), aFileName.
	metamodelOutStream := aPath asFilename writeStream.!

openPrjOutStream
	| aPath |

	aPath := self projectDirectory , (String with: Filename separator) , self projectName.
	prjOutStream := aPath asFilename writeStream.!

openWholeTraversalConfigOutStream
	| aFileName aPath aConfigsPath |

	aFileName := self generatingReplicationTraversalConfig 
		ifTrue: [ self wholeReplicationConfigOutFileName] 
		ifFalse: [ self wholeTraversalConfigOutFileName].

	aFileName isNil ifTrue: [ ^nil].

	aConfigsPath := (self outputDirectoryWithPackageAndFolder: 'meta').
	aConfigsPath asFilename exists ifFalse: [ aConfigsPath asFilename makeDirectory].

	aPath := aConfigsPath, (String with: Filename separator), aFileName.
	wholeTraversalConfigOutStream := aPath asFilename writeStream.!

openWholeTreeConfigOutStream
	| aFileName aPath aCustomConfigsPath |

	aFileName := self wholeTreeConfigOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aCustomConfigsPath := (self outputDirectoryWithPackageAndFolder: 'browser'), (String with: Filename separator), 'customconfigs'.
	aCustomConfigsPath asFilename exists ifFalse: [ aCustomConfigsPath asFilename makeDirectory].

	aPath := aCustomConfigsPath, (String with: Filename separator), aFileName.
	wholeTreeConfigOutStream := aPath asFilename writeStream.!

prjOutStream	
	prjOutStream isNil ifTrue: [ self openPrjOutStream].
	^prjOutStream!

wholeReplicationConfigOutFileName
	"Generated by ISF/AD. Do not modify"
	wholeReplicationConfigOutFileName isNil
		ifTrue: [self initWholeReplicationConfigOutFileName].
	^wholeReplicationConfigOutFileName!

wholeTraversalConfigOutFileName
	"Generated by ISF/AD. Do not modify"
	wholeTraversalConfigOutFileName isNil
		ifTrue: [self initWholeTraversalConfigOutFileName].
	^wholeTraversalConfigOutFileName!

wholeTraversalConfigOutStream	
	wholeTraversalConfigOutStream isNil ifTrue: [ self openWholeTraversalConfigOutStream].
	^wholeTraversalConfigOutStream!

wholeTreeConfigOutFileName
	"Generated by ISF/AD. Do not modify"
	wholeTreeConfigOutFileName isNil
		ifTrue: [self initWholeTreeConfigOutFileName].
	^wholeTreeConfigOutFileName!

wholeTreeConfigOutStream	
	wholeTreeConfigOutStream isNil ifTrue: [ self openWholeTreeConfigOutStream].
	^wholeTreeConfigOutStream! !

!CODEModel publicMethodsFor: 'generate-support'!

errorLineKind
	^errorLineKind!

errorLineName
	^errorLineName!

expand: theKey
	expansionInitialized == true ifFalse: [ self initializeExpansions].

	^self expansions at: theKey ifAbsent: [
		(String with:self model expansionDelimiter) , theKey , (String with:self model expansionDelimiter)]!

fullPackageName
	^self package!

generatingReplicationTraversalConfig
	^generatingReplicationTraversalConfig == true!

initializeExpansions
	
	| aMetaVariableName somePackages aPackage |
	aMetaVariableName := 'vm3Model'.
	somePackages := self packagesAsArray.
	(somePackages isNil not and: [ somePackages size > 0]) ifTrue: [ 
		aPackage := somePackages last.
		aPackage isNil ifFalse: [ 
			aMetaVariableName := 	'vm3Module', (self toUpperInitial: aPackage)
		]
	].

	self expansion: 'MetaVariableName' value: aMetaVariableName.

	self expansion: 'ProjectFileName' value: self projectFileName.
	self expansion: 'FullPrefixedM3ModelName' value: self package , '.meta.', self name.
	self expansion: 'PrefixedM3ModelName' value: self name.
	self expansion: 'FullPackageName' value: self fullPackageName.
	self expansion: 'RootTypeName' value: self rootTypeName.
	self expansion: 'PrefixedWholeTreeConfigFactory' value: 
		(self typePrefix, self rootTypeName , 'TreeConfigFactory').	
	self expansion: 'FullPrefixedWholeTreeConfigFactory' value: 
		(self fullPackageName, '.browser.customconfigs.', self typePrefix, self rootTypeName , 'TreeConfigFactory').

	self expansion: 'PrefixedWholeTraversalConfigFactory' value: 
		(self typePrefix, 'TraversalConfigFactory').	
	self expansion: 'FullPrefixedWholeTraversalConfigFactory' value: 
		(self fullPackageName, '.traversal.customconfigs.', self typePrefix,  'TraversalConfigFactory').

	self expansion: 'PrefixedWholeTraversalConfig' value: 
		(self typePrefix, 'TraversalConfig').	
	self expansion: 'FullPrefixedWholeTraversalConfig' value: 
		(self fullPackageName, '.meta.', self typePrefix, 'TraversalConfig').

	self expansion: 'PrefixedWholeReplicationConfig' value: 
		(self typePrefix, 'ReplicationConfig').	
	self expansion: 'FullPrefixedWholeReplicationConfig' value: 
		(self fullPackageName, '.meta.', self typePrefix, 'ReplicationConfig').

	self expansion: 'MetaModelFullIfcPrefixedClassName' value: self metaModelFullIfcPrefixedClassName.
	self expansion: 'MetaModelFullImplPrefixedClassName' value: self metaModelFullImplPrefixedClassName.
	self expansion: 'MetaModuleFullIfcPrefixedClassName' value: self model metaModuleFullIfcPrefixedClassName.
	self expansion: 'MetaModuleFullImplPrefixedClassName' value: self model  metaModuleFullImplPrefixedClassName.
	self expansion: 'TypePrefix' value: self  typePrefix.
	self expansion: 'M3ModelName' value: self typePrefix.

	self expansion: 'MetaTraversalConfigFullIfcPrefixedClassName' value: self metaTraversalConfigFullIfcPrefixedClassName.!

initNativeAttributesMap
	nativeAttributesMap := Dictionary new: 11.
 
	nativeAttributesMap at:  'String' put: 'java.lang.String'. 
	nativeAttributesMap at:  'Name' put: 'java.lang.String'.
	nativeAttributesMap at:  'Boolean' put: 'boolean'.
	nativeAttributesMap at:  'Integer' put: 'int'.
	nativeAttributesMap at:  'UnlimitedInteger' put: 'long'.
	nativeAttributesMap at:  'Time' put: 'java.util.Time'.
	nativeAttributesMap at:  'Date' put: 'java.util.Date'.
	nativeAttributesMap at:  'Geometry' put: 'java.awt.Shape'.
	nativeAttributesMap at:  'Mapping' put: 'java.lang.String'.
	nativeAttributesMap at:  'LocationReference' put: 'Object'.
	nativeAttributesMap at:  'Object' put: 'Object'.!

initNativeAttributesSet
	nativeAttributesSet := Set new: 11.
 
	nativeAttributesSet add: 'boolean'.
	nativeAttributesSet add: 'int'.
	nativeAttributesSet add: 'long'.
	nativeAttributesSet add: 'float'.
	nativeAttributesSet add: 'double'.!

isGenerationStyleDynamic
	^self generationStyle = self class generationStyleDynamic!

isGenerationStyleDynamicReduced
	^self generationStyle = self class generationStyleDynamicReduced!

isNativeAttributeName: theAttributeName
	| aSet |
	aSet := self nativeAttributesSet. 
	aSet isNil ifTrue: [ ^false].
	^aSet includes: theAttributeName!

metaAttributeFullIfcPrefixedClassName
	^self metaPackage, '.ifc.', 'M3AttributeIfc'!

metaAttributeFullImplPrefixedClassName
	^self isM3 
		ifFalse: [ self metaPackage, '.impl.', 'M3AttributeImpl']
		ifTrue: [ self metaPackage, '.base.', 'M3AttributeBase']!

metaModelFullIfcPrefixedClassName
	^self metaPackage, '.ifc.', 'M3ModelIfc'!

metaModelFullImplPrefixedClassName
	^self isM3 
		ifFalse: [ self metaPackage, '.impl.', 'M3ModelImpl']
		ifTrue: [ self metaPackage, '.base.', 'M3ModelBase']!

metaModuleFullIfcPrefixedClassName
	^self metaPackage, '.ifc.', 'M3ModuleIfc'!

metaModuleFullImplPrefixedClassName
	^self isM3 
		ifFalse: [ self metaPackage, '.impl.', 'M3ModuleImpl']
		ifTrue: [ self metaPackage, '.base.', 'M3ModuleBase']!

metaRelationshipFullIfcPrefixedClassName
	^self metaPackage, '.ifc.', 'M3RelationshipIfc'!

metaRelationshipFullImplPrefixedClassName
	^self isM3 
		ifFalse: [ self metaPackage, '.impl.', 'M3RelationshipImpl']
		ifTrue: [ self metaPackage, '.base.', 'M3RelationshipBase']!

metaTraversalConfigFullIfcPrefixedClassName
	^self  metaTraversalPackage, '.ifc.', 'M3TraversalConfigIfc'!

metaTypeFullIfcPrefixedClassName
	^self metaPackage, '.ifc.', 'M3TypeIfc'!

metaTypeFullImplPrefixedClassName
	^self isM3 
		ifFalse: [ self metaPackage, '.impl.', 'M3TypeImpl']
		ifTrue: [ self metaPackage, '.base.', 'M3TypeBase']!

metaTypeFullPubPrefixedClassName
	^self metaPackage, '.pub.', 'M3TypePub'!

mmElementWithM3FullIfcPrefixedClassName
	^self metaMetaPackage, '.', 'MMElementWM3Ifc'!

nativeAttributeName: theAttributeName
	| aMap |
	aMap := self nativeAttributesMap. 
	aMap isNil ifTrue: [ ^nil].
	^aMap at: theAttributeName ifAbsent: [ nil]!

nativeAttributeNullValue: theAttributeName
	^theAttributeName = 'int' ifTrue: [ '0'] ifFalse: [
	theAttributeName = 'boolean' ifTrue: [ 'true'] ifFalse: [
	theAttributeName = 'float' ifTrue: [ '0.0'] ifFalse: [
	theAttributeName = 'double' ifTrue: [ '0.0'] ifFalse: [
		'null'
	]]]]!

nativeAttributesMap
	nativeAttributesMap isNil ifTrue: [ self initNativeAttributesMap].
	^nativeAttributesMap!

nativeAttributesSet
	nativeAttributesSet isNil ifTrue: [ self initNativeAttributesSet].
	^nativeAttributesSet!

packageAsPath
	| aPackage aPath |
	aPackage := self package.
	aPath := aPackage copyReplaceAll: '.' with: (String with: Filename separator).
	^aPath!

projectFileName
	^self projectName!

projectToOutputDirectoryPath
	| aProjectDirectory anOutputDirectory |
	aProjectDirectory := self projectDirectory.
	anOutputDirectory := self outputDirectory.
	
	
	(anOutputDirectory findString: aProjectDirectory startingAt: 1) = 1 ifFalse: [ ^'.'].
	^anOutputDirectory copyFrom: aProjectDirectory size + 1 to: anOutputDirectory size!

startProjectNodeIndex
	^550!

templateFileNameFor: theAspect
	
	| aTemplateDirectory aFileName |
	theAspect = 'project' ifTrue: [ 
		aTemplateDirectory := self templatesDirectory.
		aFileName := aTemplateDirectory , (String with: Filename separator), 'template.prj'.
		^aFileName].

	theAspect = 'metamodel' ifTrue: [ 
		aTemplateDirectory := self templatesDirectory.
		aFileName := aTemplateDirectory , (String with: Filename separator), 'M3Model.java'.
		^aFileName].

	theAspect = 'wholeTreeConfigFactory' ifTrue: [ 
		aTemplateDirectory := self templatesDirectory.
		aFileName := aTemplateDirectory , (String with: Filename separator), 'WholeTreeConfigFactory.java'.
		^aFileName].

	theAspect = 'wholeTraversalConfigFactory' ifTrue: [ 
		aTemplateDirectory := self templatesDirectory.
		aFileName := aTemplateDirectory , (String with: Filename separator), 'WholeTraversalConfig.java'.
		^aFileName].

	theAspect = 'wholeReplicationConfigFactory' ifTrue: [ 
		aTemplateDirectory := self templatesDirectory.
		aFileName := aTemplateDirectory , (String with: Filename separator), 'WholeReplicationConfig.java'.
		^aFileName].


	^nil!

typeIndex: theType
	| someTypes |
	someTypes := self typesAsArray.
	someTypes isNil ifTrue: [ ^0].
	^someTypes indexOf: theType! !

!CODEModel publicMethodsFor: 'generate-traversals'!

generateTraversalAttributeCfgsStaticDeclarations
	super generateTraversalAttributeCfgsStaticDeclarations!

generateTraversalAttributeCfgsStaticInstantiations
	super generateTraversalAttributeCfgsStaticInstantiations!

generateTraversalBranchCfgsStaticDeclarations
	super generateTraversalBranchCfgsStaticDeclarations!

generateTraversalBranchCfgsStaticInitializations
	super generateTraversalBranchCfgsStaticInitializations!

generateTraversalBranchCfgsStaticInstantiations
	super generateTraversalBranchCfgsStaticInstantiations!

generateTraversalBranchMgrsStaticDeclarations
	super generateTraversalBranchMgrsStaticDeclarations!

generateTraversalBranchMgrsStaticInstantiations
	super generateTraversalBranchMgrsStaticInstantiations!

generateTraversalFieldMgrsStaticDeclarations
	super generateTraversalFieldMgrsStaticDeclarations!

generateTraversalFieldMgrsStaticInstantiations
	super generateTraversalFieldMgrsStaticInstantiations!

generateTraversalNodeCfgsStaticDeclarations
	super generateTraversalNodeCfgsStaticDeclarations!

generateTraversalNodeCfgsStaticInitializations
	super generateTraversalNodeCfgsStaticInitializations!

generateTraversalNodeCfgsStaticInstantiations
	super generateTraversalNodeCfgsStaticInstantiations!

generateTraversalNodeMgrsStaticDeclarations
	super generateTraversalNodeMgrsStaticDeclarations!

generateTraversalNodeMgrsStaticInstantiations
	super generateTraversalNodeMgrsStaticInstantiations!

generateTraversalRelatedTypeNodeCfgsStaticDeclarations
	super generateTraversalRelatedTypeNodeCfgsStaticDeclarations!

generateTraversalRelatedTypeNodeCfgsStaticInstantiations
	super generateTraversalRelatedTypeNodeCfgsStaticInstantiations!

generateTraversalRootTypeNodeCfgsStaticDeclarations
	super generateTraversalRootTypeNodeCfgsStaticDeclarations!

generateTraversalRootTypeNodeCfgsStaticInstantiations
	super generateTraversalRootTypeNodeCfgsStaticInstantiations! !

!CODEModel publicMethodsFor: 'initialize-release'!

initAspectToGenerate
	"Generated by ISF/AD. Do not modify"
	aspectToGenerate := ''.!

initAttributeVariablePrefix
	"Generated by ISF/AD. Do not modify"
	attributeVariablePrefix := ''.!

initBrowserFrameworkPackage
	"Generated by ISF/AD. Do not modify"
	browserFrameworkPackage := ''.!

initDefaultSuperTypeFullBaseClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullBaseClassName := ''.!

initDefaultSuperTypeFullIfcClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullIfcClassName := ''.!

initDefaultSuperTypeFullImplClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullImplClassName := ''.!

initDefaultSuperTypeFullPrivClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullPrivClassName := ''.!

initDefaultSuperTypeFullPubClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullPubClassName := ''.!

initDefaultSuperTypeFullTrxClassName
	"Generated by ISF/AD. Do not modify"
	defaultSuperTypeFullTrxClassName := ''.!

initEnumVariablePrefix
	"Generated by ISF/AD. Do not modify"
	enumVariablePrefix := ''.!

initExpansionDelimiter
	expansionDelimiter := $$.!

initFrameworkPackage
	"Generated by ISF/AD. Do not modify"
	frameworkPackage := ''.!

initGenerateSeparateActions
	"Generated by ISF/AD. Do not modify"
	generateSeparateActions := false!

initGenerationStyle
	"Generated by ISF/AD. Do not modify"
	generationStyle := self class generationStyleDynamicReduced!

initIsM3
	"Generated by ISF/AD. Do not modify"
	isM3 := false.!

initM3FactoryName
	"Generated by ISF/AD. Do not modify"
	m3FactoryName := ''.!

initMetaMetaPackage
	"Generated by ISF/AD. Do not modify"
	metaMetaPackage := ''.!

initMetaPackage
	"Generated by ISF/AD. Do not modify"
	metaPackage := ''.!

initMetaTraversalPackage
	"Generated by ISF/AD. Do not modify"
	metaTraversalPackage := ''.!

initMetaVariablePrefix
	"Generated by ISF/AD. Do not modify"
	metaVariablePrefix := ''.!

initName
	name := 'Root'.!

initOutputDirectory
	"Generated by ISF/AD. Do not modify"
	outputDirectory := ''.!

initPackage
	"Generated by ISF/AD. Do not modify"
	package := ''.!

initProjectDirectory
	"Generated by ISF/AD. Do not modify"
	projectDirectory := ''.!

initProjectName
	"Generated by ISF/AD. Do not modify"
	projectName := ''.!

initRelationshipVariablePrefix
	"Generated by ISF/AD. Do not modify"
	relationshipVariablePrefix := ''.!

initRootTypeName
	"Generated by ISF/AD. Do not modify"
	rootTypeName := ''.!

initSerialVersionUIDPrefix
	"Generated by ISF/AD. Do not modify"
	serialVersionUIDPrefix := ''.!

initSkipModules
	skipModules := Array new.!

initSkipTypes
	skipTypes := Array new.!

initSourceFileName
	"Generated by ISF/AD. Do not modify"
	sourceFileName := ''.!

initTemplatesDirectory
	"Generated by ISF/AD. Do not modify"
	templatesDirectory := ''.!

initTypePrefix
	"Generated by ISF/AD. Do not modify"
	typePrefix := ''.!

release
	self changed: #objectDisconnectedOfTree.

	self typesRelease.

	super release! !

!CODEModel publicMethodsFor: 'parse'!

dropErrorLine
	errorLineKind := nil.
	errorLineName := nil.!

forgetIsAbstract
	foundIsAbstract := false!

foundErrorLine: theErrorKind name: theErrorName
	errorLineKind := theErrorKind.
	errorLineName := theErrorName.!

foundIsAbstract
	^foundIsAbstract == true!

fromFileNamed: theFileName
	| aFilename aStream |
	theFileName isNil ifTrue: [ ^nil].
	aFilename := theFileName asFilename.
	aFilename exists ifFalse: [ ^nil].

	sourceFileName := theFileName.

	[ 
		aStream := aFilename readStream.
		self fromStream: aStream.
	]
		valueNowOrOnUnwindDo:
	[ 
		aStream isNil ifFalse: [ aStream close]
	]!

fromStream: theStream

	
	theStream isNil ifTrue: [ ^nil].
	
	[ theStream atEnd] whileFalse: [ |  aLine aTrimmedLine |
		aLine := theStream upTo: Character cr.
		aTrimmedLine := aLine trimSeparators.
		aTrimmedLine isEmpty ifFalse: [ 
self logTranscript ifTrue: [ Transcript show: aTrimmedLine; cr].
			self fromLine: aTrimmedLine andStream: theStream	
		]	
	].
	self skipTypes do: [:aTypeName | | aType |
		aType := self typeNamed: aTypeName.
		aType isNil ifFalse: [ aType skip: true]].

	self skipModules do: [:aModuleName | | aModule |
		aModule := self moduleNamed: aModuleName.
		aModule isNil ifFalse: [ aModule skipRecursively: true]]!

moduleNamed: theModuleName
	
	| anExistingModule anSpacedModuleName someNames  |
	theModuleName isNil ifTrue: [ ^self].
	theModuleName isEmpty ifTrue: [ ^self].

	(theModuleName findString: '::' startingAt: 1 ) > 0 ifFalse: [  
		anExistingModule := self subModulesPrivate detect: [:aModule | aModule name = theModuleName] ifNone: [ nil].
		^anExistingModule].

	anSpacedModuleName := theModuleName copyReplaceAll: '::' with: ' '.
	someNames := anSpacedModuleName asArrayOfSubstrings.
	
	^self moduleNamedArray: someNames!

rememberFoundIsAbstract
	foundIsAbstract := true!

typeNamed: theTypeName
	
	| anExistingType anSpacedTypeName someNames |
	theTypeName isNil ifTrue: [ ^self].
	theTypeName isEmpty ifTrue: [ ^self].

	(theTypeName findString: '::' startingAt: 1 ) > 0 ifFalse: [  
		anExistingType := self types detect: [:aType | aType name = theTypeName] ifNone: [ nil].
		^anExistingType].

	anSpacedTypeName := theTypeName copyReplaceAll: '::' with: ' '.
	someNames := anSpacedTypeName asArrayOfSubstrings.
	
	^self typeNamedArray: someNames! !

!CODEModel publicMethodsFor: 'persistence-code'!

allModuleNamesInto: theStream!

asReferenceAsCodeStringNOCROn: theStream

	| aSep aModule |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	theStream nextPutAll: ' ( ';  nextPutAll: (self pcForV: self class refToModelKindSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	aModule isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [ aModule allModuleNamesInto: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAsCodeStringNOCROn: theStream. 
	theStream cr.!

firstPersistenceIndexModel
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		self numberPersistenceEntriesModule  +
		1!

initFromValues: theValues 
	| aFPI |
	super initFromValues: theValues.
	aFPI := self firstPersistenceIndexModel.

	self forzeDefaultApplicationTranslationStoreClassName: 	
		(theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]). 
	self forzeDefaultApplicationTranslationStoreMethodSelector: 	
		(theValues size < (aFPI + 1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 1)]). 

	self ph2InitFromSolver: self.
	self cleanDirtyMark.
	
	self buildDependencies.
	self createSpecializedHomeTypes!

localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter 
		indent: theIS doSubChunks: theDoSubChunks.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self defaultApplicationTranslationStoreClassName );  nextPutAll: aSep; 
		nextPutAll: (self pcForV:  self defaultApplicationTranslationStoreMethodSelector );  cr.!

numberPersistenceEntriesModel
	^2!

persistenceAsCodeStringChunksFilter: theFilter doSubChunks: theDoSubChunks

	| aStream aCollection aChunk aFilter anIS aSep aRes aMustStore |

	aFilter := theFilter = true ifTrue: [ true] ifFalse: [ theFilter = #dirty ifTrue: [ #dirty] ifFalse: [ theFilter = #source ifTrue: [ #source] ifFalse: [ nil]]].

	aCollection := OrderedCollection new: 32.
	aStream := nil.


	anIS := self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.
	
	aMustStore := self mustStoreWithFilter: theFilter.

	aMustStore ifTrue: [ 
		aStream := WriteStream on: (String new: (self subModulesSize + 1) * 256).
		aChunk := Array with: self with: aStream.
		aCollection add: aChunk.

		aStream nextPutAll: anIS; nextPutAll: '#( ';  nextPutAll: (self pcForV: self kind);  
			nextPutAll: aSep; nextPutAll: self name printString; cr.
	].

	self localValuesPersistenceAsCodeStringChunks: aCollection on: aStream filter: aFilter indent: anIS doSubChunks: theDoSubChunks.

	aMustStore ifTrue: [ 
		aStream nextPutAll: anIS; nextPutAll: ' )' ; cr; cr.
	].

	aRes := aCollection collect: [:aCh | Array with: aCh first with: aCh last contents].
	^aRes!

persistenceRefToMethodAsCodeStringOn: theStream indent: theIS

	| aSep |
	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
		
	theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self class refToModelMethodKind);  
		nextPutAll: aSep; nextPutAll: self name printString;  
		nextPutAll: aSep; nextPutAll: (self pcForV: self storeMethodSelector); nextPutAll: aSep; nextPutAll: (self pcForV: self storeClassName);  
		nextPutAll: ' )' ; cr; cr.! !

!CODEModel publicMethodsFor: 'search'!

resolveElementReference: theElementReference
	theElementReference isNil ifTrue: [ ^nil].! !

!CODEModel publicMethodsFor: 'semantic checking'!

checkAspectToGenerate: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkAttributeVariablePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkBrowserFrameworkPackage: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDefaultSuperTypeFullBaseClassName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDefaultSuperTypeFullIfcClassName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDefaultSuperTypeFullImplClassName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDefaultSuperTypeFullPrivClassName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDefaultSuperTypeFullPubClassName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDefaultSuperTypeFullTrxClassName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkEnumVariablePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkExpansionDelimiter: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkFrameworkPackage: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkGenerateSeparateActions: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkGenerationStyle: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsM3: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMetaMetaPackage: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMetaPackage: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMetaTraversalPackage: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMetaVariablePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOutputDirectory: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkPackage: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkProjectDirectory: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkProjectName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRelationshipVariablePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRootTypeName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSerialVersionUIDPrefix: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSkipModules: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSkipTypes: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSourceFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTemplatesDirectory: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypePrefix: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEModel publicMethodsFor: 'semantic links'!

attributeVariablePrefixCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self attributeVariablePrefix!

attributeVariablePrefixCreate
	"Generated by ISF/AD. Do not modify"
	^''!

attributeVariablePrefixLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self attributeVariablePrefix: self attributeVariablePrefixCreate.!

attributeVariablePrefixLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self attributeVariablePrefixCandidates
		initially: self attributeVariablePrefix
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self attributeVariablePrefix: anObject.!

attributeVariablePrefixLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self attributeVariablePrefixCandidates
		initially: self attributeVariablePrefix
		label: 'Select Or Create ...'
		class: self attributeVariablePrefixCreate class
		ifUnchanged: [^self].
	self attributeVariablePrefix: anObject!

attributeVariablePrefixScope
	"Generated by ISF/AD. Do not modify"
	^nil!

outputDirectoryCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self outputDirectory!

outputDirectoryCreate
	"Generated by ISF/AD. Do not modify"
	^''!

outputDirectoryLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self outputDirectory: self outputDirectoryCreate.!

outputDirectoryLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self outputDirectoryCandidates
		initially: self outputDirectory
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self outputDirectory: anObject.!

outputDirectoryLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self outputDirectoryCandidates
		initially: self outputDirectory
		label: 'Select Or Create ...'
		class: self outputDirectoryCreate class
		ifUnchanged: [^self].
	self outputDirectory: anObject!

outputDirectoryScope
	"Generated by ISF/AD. Do not modify"
	^nil!

relationshipVariablePrefixCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self relationshipVariablePrefix!

relationshipVariablePrefixCreate
	"Generated by ISF/AD. Do not modify"
	^''!

relationshipVariablePrefixLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self relationshipVariablePrefix: self relationshipVariablePrefixCreate.!

relationshipVariablePrefixLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self relationshipVariablePrefixCandidates
		initially: self relationshipVariablePrefix
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self relationshipVariablePrefix: anObject.!

relationshipVariablePrefixLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self relationshipVariablePrefixCandidates
		initially: self relationshipVariablePrefix
		label: 'Select Or Create ...'
		class: self relationshipVariablePrefixCreate class
		ifUnchanged: [^self].
	self relationshipVariablePrefix: anObject!

relationshipVariablePrefixScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typePrefixCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self typePrefix!

typePrefixCreate
	"Generated by ISF/AD. Do not modify"
	^''!

typePrefixLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self typePrefix: self typePrefixCreate.!

typePrefixLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typePrefixCandidates
		initially: self typePrefix
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self typePrefix: anObject.!

typePrefixLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typePrefixCandidates
		initially: self typePrefix
		label: 'Select Or Create ...'
		class: self typePrefixCreate class
		ifUnchanged: [^self].
	self typePrefix: anObject!

typePrefixScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typesCandidates
	"Generated by ISF/AD. Do not modify"
	^self types asArray!

typesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

typesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self typesAdd: anObject]!

typesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self typesAdd: anObject.!

typesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self typesCreate class
		ifUnchanged: [^self].
	self typesAdd: anObject!

typesScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEModel publicMethodsFor: 'testing'!

isModel
	^true! !

!CODEModel publicMethodsFor: 'TRF-operations'!

buildDependencies

	| someTypes |
	someTypes := self allTypes.
	someTypes do: [:aType |
		aType buildDependencies
	].! !

!CODEModule class publicMethodsFor: 'accessing'!

kind
	^#module! !

!CODEModule class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEModule class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, self modelEditorMETAPerspectivesSubModules,
		self modelEditorMETAPerspectivesModule, super modelEditorMETAPerspectives,
		self modelEditorMETAPerspectivesTranslation!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind'  'AllContainerNamespaceNames' 'IsDirty' 'StoreClassName' 'StoreMethodSelector')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesModule

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Types'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Types' )))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'Types';
			nlsTranslation: 'Tipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'AllTypes';
			nlsTranslation: 'TodosLosTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllNonAbstractTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'AllNonAbstractTypes';
			nlsTranslation: 'TodosLosTiposNoAbstractos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RootTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('RootTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'RootTypes';
			nlsTranslation: 'TodosLosTiposSinSuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SuperModule'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('SuperModule' )))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'SuperModule';
			nlsTranslation: 'SuperModulo';
			yourself);
		yourself!

modelEditorMETAPerspectivesSubModules

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SubModules'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('SubModules' )))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'SubModules';
			nlsTranslation: 'SubModulos';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsSubModules, self modelEditorMETASelectorsModule,
		self modelEditorMETASelectorsTranslation!

modelEditorMETASelectorsModule

	"METAChildSpecAutoViewEditor openOn: CODEModule selector: #modelEditorMETASelectorsModule target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Types';
			basicSelector: #types;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #nlsName;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'Types';
			nlsTranslation: 'Tipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RootTypes';
			basicSelector: #rootTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types without Supertypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'RootTypes';
			nlsTranslation: 'TiposRaiz';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllTypes';
			basicSelector: #allTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'All the Types in the Module and subModules';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'AllTypes';
			nlsTranslation: 'TodosLosTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractTypes';
			basicSelector: #allNonAbstractTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractTypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'AllNonAbstractTypes';
			nlsTranslation: 'TodosLosTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreClassName';
			basicSelector: #storeClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'StoreClassName';
			nlsTranslation: 'ClaseDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreMethodSelector';
			basicSelector: #storeMethodSelector;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreMethodSelector';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'StoreMethodSelector';
			nlsTranslation: 'SelectorDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IncludedModules';
			basicSelector: #includedModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'IncludedModules';
			displaySelector: #name;
			componentsClassName: #CODEModule;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'IncludedModules';
			nlsTranslation: 'ModulosIncluidos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IncludedInModules';
			basicSelector: #includedInModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IncludedInModules';
			displaySelector: #name;
			componentsClassName: #CODEModule;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'IncludedInModules';
			nlsTranslation: 'IncluidoEnModulos';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperModule';
			basicSelector: #superModule;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperModule';
			displaySelector: #name;
			canShowInTree: true;
			objectClassName: #CODEModule;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'SuperModule';
			nlsTranslation: 'SuperModulo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllContainerNamespaceNames';
			basicSelector: #allContainerNamespaceNames;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllContainerNamespaceNames';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllContainerNamespaceNames';
			nlsTranslation: 'Namespace contenedor completamente cualificado';
			yourself);
		yourself!

modelEditorMETASelectorsSubModules

	"METAChildSpecAutoViewEditor openOn: CODEModule selector: #modelEditorMETASelectorsSubModules target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubModules';
			basicSelector: #subModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubModules';
			displaySelector: #name;
			componentsClassName: #CODEModule;
			sortSelector: #nlsName;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Module_Selectors';
			nlsItem: 'SubModules';
			nlsTranslation: 'SubModulos';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsModule.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsModule

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('Types' 'SubModules' 'SuperModule'  'RootTypes' 'AllTypes' 'AllNonAbstractTypes')!

xmetaSelectors

	"METAChildSpecAutoViewEditor openOn: CODEModule selector: #metaSelectors target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 10)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Name';
			basicSelector: #name;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Name';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubModules';
			basicSelector: #subModules;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Modules';
			displaySelector: #name;
			componentsClassName: #CODEModule;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Types';
			basicSelector: #types;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RootTypes';
			basicSelector: #rootTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types without Supertypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllTypes';
			basicSelector: #allTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'All the Types in the Module and subModules';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		yourself! !

!CODEModule publicMethodsFor: 'accessing'!

applicationConfiguration
	
	^applicationConfiguration!

applicationConfiguration: theApplicationConfiguration
	
	applicationConfiguration := theApplicationConfiguration!

baseOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	baseOutPrjNdx isNil
		ifTrue: [self initBaseOutPrjNdx].
	^baseOutPrjNdx!

baseOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkBaseOutPrjNdx: aValue) ifFalse: [^aValue].
	baseOutPrjNdx := aValue.
	self changed: #baseOutPrjNdx!

definitionsHolderClassNameForInstances
	^definitionsHolderClassNameForInstances!

developerConfiguration
	
	| aConfiguration aDeveloperConfiguration |
	aConfiguration := self applicationConfiguration.
	aConfiguration isNil ifTrue: [ ^nil].

	aDeveloperConfiguration := aConfiguration developerConfiguration.
	^aDeveloperConfiguration!

ifcOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	ifcOutPrjNdx isNil
		ifTrue: [self initIfcOutPrjNdx].
	^ifcOutPrjNdx!

ifcOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIfcOutPrjNdx: aValue) ifFalse: [^aValue].
	ifcOutPrjNdx := aValue.
	self changed: #ifcOutPrjNdx!

implOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	implOutPrjNdx isNil
		ifTrue: [self initImplOutPrjNdx].
	^implOutPrjNdx!

implOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkImplOutPrjNdx: aValue) ifFalse: [^aValue].
	implOutPrjNdx := aValue.
	self changed: #implOutPrjNdx!

name: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkName: aValue) ifFalse: [^aValue].
	name := aValue.
	self markDirty.
	self changed: #name.

	self notifyFullyQualifiedNameChanged!

privOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	privOutPrjNdx isNil
		ifTrue: [self initPrivOutPrjNdx].
	^privOutPrjNdx!

privOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkPrivOutPrjNdx: aValue) ifFalse: [^aValue].
	privOutPrjNdx := aValue.
	self changed: #privOutPrjNdx!

prjNdx
	"Generated by ISF/AD. Do not modify"
	prjNdx isNil
		ifTrue: [self initPrjNdx].
	^prjNdx!

prjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkPrjNdx: aValue) ifFalse: [^aValue].
	prjNdx := aValue.
	self changed: #prjNdx!

skip
	"Generated by ISF/AD. Do not modify"
	skip isNil
		ifTrue: [self initSkip].
	^skip!

skip: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSkip: aValue) ifFalse: [^aValue].
	skip := aValue.
	self changed: #skip!

skipRecursively: theBool
	self skip: theBool == true.
	self types do: [:aType | aType skip: theBool == true].
	self subModules do: [:aModule | aModule skipRecursively: theBool == true].!

storeClassName
	^storeClassName!

storeClassName: elValor
	| unValor unosStrings |
	unValor := (elValor isNil or: [ elValor isEmpty])
		ifTrue: [ nil] 
		ifFalse: [ 	
			unosStrings := elValor  asArrayOfSubstrings.
			unosStrings isEmpty
				ifTrue: [ nil]
				ifFalse: [ 
					unosStrings size > 1
						ifTrue: [ unosStrings first asSymbol]
						ifFalse: [ elValor asSymbol]
				]
		].
	
	unValor = storeClassName  ifTrue: [ ^self].

	storeClassName := unValor.
	self markDirty.

	self changed: #storeClassName!

storeMethodSelector
	^storeMethodSelector!

storeMethodSelector: elValor
	| unValor unosStrings |
	unValor := (elValor isNil or: [ elValor isEmpty])
		ifTrue: [ nil] 
		ifFalse: [ 	
			unosStrings := elValor  asArrayOfSubstrings.
			unosStrings isEmpty
				ifTrue: [ nil]
				ifFalse: [ 
					unosStrings size > 1
						ifTrue: [ unosStrings first asSymbol]
						ifFalse: [ elValor asSymbol]
				]
		].
	
	unValor = storeMethodSelector  ifTrue: [ ^self].

	storeMethodSelector := unValor.
	self markDirty.

	self changed: #storeMethodSelector!

trxOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	trxOutPrjNdx isNil
		ifTrue: [self initTrxOutPrjNdx].
	^trxOutPrjNdx!

trxOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTrxOutPrjNdx: aValue) ifFalse: [^aValue].
	trxOutPrjNdx := aValue.
	self changed: #trxOutPrjNdx! !

!CODEModule publicMethodsFor: 'accessing-find'!

hasTypeNamed: theTypeName
	
	^(self typeNamed: theTypeName) isNil not!

moduleNamed: theModuleName
	
	| anExistingModule |
	theModuleName isNil ifTrue: [ ^self].
	(theModuleName findString: '::' startingAt: 1 ) > 0 ifTrue: [  ^self findModuleNamed: theModuleName].

	anExistingModule := self subModulesPrivate detect: [:aModule | aModule name = theModuleName] ifNone: [ nil].
	^anExistingModule!

typeNamed: theTypeName
	
	| anExistingType |
	theTypeName isNil ifTrue: [ ^self].
	(theTypeName findString: '::' startingAt: 1 ) > 0 ifTrue: [  ^self findTypeNamed: theTypeName].

	anExistingType := self typesPrivate detect: [:aType | aType name = theTypeName] ifNone: [ nil].
	^anExistingType! !

!CODEModule publicMethodsFor: 'accessing-private'!

forzeStoreClassName: aValue
	storeClassName := aValue!

forzeStoreMethodSelector: aValue
	storeMethodSelector := aValue! !

!CODEModule publicMethodsFor: 'association initialize-release'!

includedInModulesRelease
	"Generated by ISF/AD. Do not modify"
	self includedInModules do: [:each | self includedInModulesRemove: each]!

includedModulesRelease
	"Generated by ISF/AD. Do not modify"
	self includedModules do: [:each | self includedModulesRemove: each]!

initIncludedInModules
	"Generated by ISF/AD. Do not modify"
	includedInModules := OrderedCollection new.!

initIncludedModules
	"Generated by ISF/AD. Do not modify"
	includedModules := OrderedCollection new.!

initSubModules
	"Generated by ISF/AD. Do not modify"
	subModules := OrderedCollection new.!

initTypes
	"Generated by ISF/AD. Do not modify"
	types := OrderedCollection new.!

subModulesRelease
	"Generated by ISF/AD. Do not modify"
	self subModules do: [:each | self subModulesRemove: each]!

superModuleRelease
	"Generated by ISF/AD. Do not modify"
	superModule == nil
		ifFalse:
			[superModule subModulesPrivateRemove: self.
				superModule := nil.
				self changed: #superModule]!

typesRelease
	"Generated by ISF/AD. Do not modify"
	self types do: [:each | self typesRemove: each]! !

!CODEModule publicMethodsFor: 'associations accessing'!

includedInModules
	"Generated by ISF/AD. Do not modify"
	^self includedInModulesPrivate copy!

includedInModulesAsArray
	"Generated by ISF/AD. Do not modify"
	^self includedInModules asArray!

includedModules
	"Generated by ISF/AD. Do not modify"
	^self includedModulesPrivate copy!

includedModulesAsArray
	"Generated by ISF/AD. Do not modify"
	^self includedModules asArray!

subModules
	"Generated by ISF/AD. Do not modify"
	^self subModulesPrivate copy!

subModulesAsArray
	"Generated by ISF/AD. Do not modify"
	^self subModules asArray!

superModule
	"Generated by ISF/AD. Do not modify"
	^superModule!

superModule: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSuperModule: aValue) ifFalse: [^aValue].
	superModule == aValue ifTrue: [ ^self].
	self superModuleRelease.
	superModule := aValue.
	aValue == nil ifFalse: [aValue subModulesPrivateAdd: self].
	self changed: #superModule!

types
	"Generated by ISF/AD. Do not modify"
	^self typesPrivate copy!

typesAsArray
	"Generated by ISF/AD. Do not modify"
	^self types asArray! !

!CODEModule publicMethodsFor: 'associations modifying'!

includedInModulesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIncludedInModulesAdd: aValue) ifFalse: [^aValue].
	(self includedInModulesIncludes: aValue) ifTrue: [^aValue].
	(self includedInModulesPrivateAdd: aValue) includedModulesPrivateAdd: self.
	self changed: #includedInModules.
	^aValue!

includedInModulesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self includedInModulesIncludes: aValue) ifFalse: [^aValue].
	(self includedInModules indexOf: aValue) = self includedInModulesSize ifTrue: [^aValue].
	self includedInModulesPrivate remove: aValue.
	aRes := self includedInModulesPrivateAdd: aValue.
	^aRes!

includedInModulesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self includedInModulesIncludes: aValue) ifFalse: [^aValue].
	(index := self includedInModules indexOf: aValue) = self includedInModulesSize ifTrue: [^aValue].
	index = (self includedInModulesSize -1)
		ifTrue:
			[self includedInModulesPrivate remove: aValue.
			aRes := self includedInModulesPrivateAdd: aValue.
			self notifyChangeAllIncludedInModulesChildSpecs.
			^aRes].
	aRes := self includedInModulesPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

includedInModulesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self includedInModulesIncludes: aValue) ifFalse: [^aValue].
	(self includedInModules indexOf: aValue) = 1 ifTrue: [^aValue].
	self includedInModulesPrivateMove: aValue beforeIndex: 1.!

includedInModulesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self includedInModulesIncludes: aValue) ifFalse: [^aValue].
	(index := self includedInModules indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self includedInModulesPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

includedInModulesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIncludedInModulesRemove: aValue) ifFalse: [^aValue].
	(self includedInModulesPrivate remove: aValue ifAbsent: [^aValue]) includedModulesPrivateRemove: self.
	self changed: #includedInModules.
	^aValue!

includedModulesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIncludedModulesAdd: aValue) ifFalse: [^aValue].
	(self includedModulesIncludes: aValue) ifTrue: [^aValue].
	(self includedModulesPrivateAdd: aValue) includedInModulesPrivateAdd: self.
	self changed: #includedModules.
	^aValue!

includedModulesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self includedModulesIncludes: aValue) ifFalse: [^aValue].
	(self includedModules indexOf: aValue) = self includedModulesSize ifTrue: [^aValue].
	self includedModulesPrivate remove: aValue.
	aRes := self includedModulesPrivateAdd: aValue.
	^aRes!

includedModulesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self includedModulesIncludes: aValue) ifFalse: [^aValue].
	(index := self includedModules indexOf: aValue) = self includedModulesSize ifTrue: [^aValue].
	index = (self includedModulesSize -1)
		ifTrue:
			[self includedModulesPrivate remove: aValue.
			aRes := self includedModulesPrivateAdd: aValue.
			self notifyChangeAllIncludedModulesChildSpecs.
			^aRes].
	aRes := self includedModulesPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

includedModulesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self includedModulesIncludes: aValue) ifFalse: [^aValue].
	(self includedModules indexOf: aValue) = 1 ifTrue: [^aValue].
	self includedModulesPrivateMove: aValue beforeIndex: 1.!

includedModulesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self includedModulesIncludes: aValue) ifFalse: [^aValue].
	(index := self includedModules indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self includedModulesPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

includedModulesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIncludedModulesRemove: aValue) ifFalse: [^aValue].
	(self includedModulesPrivate remove: aValue ifAbsent: [^aValue]) includedInModulesPrivateRemove: self.
	self changed: #includedModules.
	^aValue!

subModulesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSubModulesAdd: aValue) ifFalse: [^aValue].
	(self subModulesIncludes: aValue) ifTrue: [^aValue].
	(self subModulesPrivateAdd: aValue) superModulePrivate: self.
	self changed: #subModules.
	^aValue!

subModulesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSubModulesRemove: aValue) ifFalse: [^aValue].
	(self subModulesPrivate remove: aValue ifAbsent: [^aValue]) superModulePrivate: nil.
	self changed: #subModules.
	^aValue!

typesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesAdd: aValue) ifFalse: [^aValue].
	(self typesIncludes: aValue) ifTrue: [^self typesMoveBottom: aValue].
	(self typesPrivateAdd: aValue) modulePrivate: self.
	self changed: #types.
	^aValue!

typesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	self typesPrivate remove: aValue.
	^self typesPrivateAdd: aValue!

typesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	index = (self typesSize -1)
		ifTrue:
			[self typesPrivate remove: aValue.
			^self typesPrivateAdd: aValue].
	^self typesPrivateMove: aValue beforeIndex: index + 2!

typesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = 1 ifTrue: [^aValue].
	self typesPrivateMove: aValue beforeIndex: 1!

typesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = 1 ifTrue: [^aValue].
	^self typesPrivateMove: aValue beforeIndex: index - 1!

typesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesRemove: aValue) ifFalse: [^aValue].
	(self typesPrivate remove: aValue ifAbsent: [^aValue]) modulePrivate: nil.
	self changed: #types.
	^aValue! !

!CODEModule publicMethodsFor: 'associations private'!

includedInModulesPrivate
	"Generated by ISF/AD. Do not modify"
	includedInModules isNil
		ifTrue: [self initIncludedInModules].
	^includedInModules!

includedInModulesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self includedInModulesPrivate add: aValue.
	self changed: #includedInModules.
	^aValue!

includedInModulesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self includedInModules at: anIndex.
	self includedInModulesPrivate remove: aValue.
	self includedInModulesPrivate add: aValue before: obj.
	self changed: #includedInModules.
	^aValue!

includedInModulesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self includedInModulesPrivate remove: aValue.
	self changed: #includedInModules.
	^aValue!

includedModulesPrivate
	"Generated by ISF/AD. Do not modify"
	includedModules isNil
		ifTrue: [self initIncludedModules].
	^includedModules!

includedModulesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self includedModulesPrivate add: aValue.
	self changed: #includedModules.
	^aValue!

includedModulesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self includedModules at: anIndex.
	self includedModulesPrivate remove: aValue.
	self includedModulesPrivate add: aValue before: obj.
	self changed: #includedModules.
	^aValue!

includedModulesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self includedModulesPrivate remove: aValue.
	self changed: #includedModules.
	^aValue!

subModulesPrivate
	"Generated by ISF/AD. Do not modify"
	subModules isNil
		ifTrue: [self initSubModules].
	^subModules!

subModulesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self subModulesPrivate add: aValue.
	self changed: #subModules.
	self markDirty.
	^aValue!

subModulesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self subModulesPrivate remove: aValue.
	self markDirty.
	self changed: #subModules.
	^aValue!

superModulePrivate: aValue
	| aPrevValue |
	aPrevValue := superModule.
	superModule := aValue.
	self changed: #superModule.
	(superModule isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

typesPrivate
	"Generated by ISF/AD. Do not modify"
	types isNil
		ifTrue: [self initTypes].
	^types!

typesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate add: aValue.
	self markDirty.

	self changed: #types.
	^aValue!

typesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self types at: anIndex.
	self typesPrivate remove: aValue.
	self typesPrivate add: aValue before: obj.
	self markDirty.

	self changed: #types.
	^aValue!

typesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate remove: aValue.
	self markDirty.

	self changed: #types.
	^aValue! !

!CODEModule publicMethodsFor: 'associations testing'!

includedInModulesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^includedInModules isNil
		ifTrue: [false]
		ifFalse: [self includedInModules includes: aValue]!

includedInModulesSize
	"Generated by ISF/AD. Do not modify"
	^includedInModules isNil
		ifTrue: [0]
		 ifFalse: [includedInModules size]!

includedModulesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^includedModules isNil
		ifTrue: [false]
		ifFalse: [self includedModules includes: aValue]!

includedModulesSize
	"Generated by ISF/AD. Do not modify"
	^includedModules isNil
		ifTrue: [0]
		 ifFalse: [includedModules size]!

subModulesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^subModules isNil
		ifTrue: [false]
		ifFalse: [self subModules includes: aValue]!

subModulesSize
	"Generated by ISF/AD. Do not modify"
	^subModules isNil
		ifTrue: [0]
		 ifFalse: [subModules size]!

typesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [false]
		ifFalse: [self types includes: aValue]!

typesSize
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [0]
		 ifFalse: [types size]! !

!CODEModule publicMethodsFor: 'changing'!

notifyFullyQualifiedNameChanged
	
	self changed: #allContainerNamespaceNames.

	self subModules do: [:aModule | aModule notifyFullyQualifiedNameChanged].
	self types do: [:aType | aType notifyFullyQualifiedNameChanged]! !

!CODEModule publicMethodsFor: 'derived accessing'!

allContainerNamespaceNames

	self superModule isNil ifTrue: [ ^'' copy].
	^self superModule allNamespaceNames!

allDefinedAspectsInto: theSet
	theSet isNil ifTrue: [ ^self].

	super allDefinedAspectsInto: theSet.
	self subModules do: [:aModule | aModule allDefinedAspectsInto: theSet].!

allModules
	| someModules |
	someModules := IdentitySet new: 111.
	self allModulesInto: someModules.
	^someModules asSortedCollection: [:aModule :otherModule | aModule name < otherModule name]!

allModulesInto: theSet
	theSet isNil ifTrue: [ ^self].

	theSet add: self.
	self subModules do: [:aModule | aModule allModulesInto: theSet].!

allNamespaceNames
	| aPackages |
	self superModule isNil ifTrue: [ ^''  copy].
	aPackages := self superModule allNamespaceNames.
	^(aPackages isEmpty ifTrue: [''] ifFalse: [ aPackages , '::']) , self name!

allNonAbstractTypes
	| someTypes someNonAbstractTypes |
	someTypes := self allTypes.
	someNonAbstractTypes := someTypes reject: [:aType | aType isAbstract].
	^someNonAbstractTypes!

allPackageNames
	| aPackages |
	self superModule isNil ifTrue: [ ^''  copy].
	aPackages := self superModule allPackageNames.
	^(aPackages isEmpty ifTrue: [''] ifFalse: [ aPackages , '.']) , self name!

allTypes
	| someTypes |
	someTypes := IdentitySet new: 111.
	self allTypesInto: someTypes.
	^someTypes!

allTypesInto: theSet
	| someTypes |
	theSet isNil ifTrue: [ ^self].

	someTypes := self typesPrivate.
	theSet addAll: someTypes.
	someTypes do: [:aType | aType allTypesInto: theSet].
	self subModulesPrivate do: [:aModule | aModule allTypesInto: theSet].!

fullyQualifiedName

	| aModuleFullyQualifiedName aFullyQualifiedName |
	self superModule isNil ifTrue: [ ^self name].
	self superModule isModel ifTrue: [ ^self name].
	
	aModuleFullyQualifiedName := self superModule fullyQualifiedName.
	(aModuleFullyQualifiedName isNil or: [ aModuleFullyQualifiedName isEmpty]) ifTrue: [ 
		^self name
	].

	aFullyQualifiedName := aModuleFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

fullyQualifiedNameArray

	| aModuleFullyQualifiedName aFullyQualifiedNameArray |
	self superModule isNil ifTrue: [ ^Array with: self name].
	self superModule isModel ifTrue: [ ^Array with: self name].
	
	aModuleFullyQualifiedName := self superModule fullyQualifiedNameArray.
	(aModuleFullyQualifiedName isNil or: [ aModuleFullyQualifiedName isEmpty]) ifTrue: [ 
		^Array with: self name
	].

	aFullyQualifiedNameArray := aModuleFullyQualifiedName, (Array with: self name).
	^aFullyQualifiedNameArray!

includesModule: theModule
	theModule isNil ifTrue: [ ^false].

	(self includedModules includes: theModule) ifTrue: [ ^true].

	^(self includedModules detect: [:aModule |  aModule includesModule: theModule] ifNone: [ nil]) isNil not!

isVisibleInModules: 		theModules
	andAspects: 			theAspects
	definitionsHolder: 	theDefinitionsHolder

	((theModules isNil or: [ theModules isEmpty]) and: [  
		theAspects isNil or: [ theAspects isEmpty]]) ifTrue: [ 
		^true
	].

	^(  self isVisibleInModules: 	theModules definitionsHolder: 	theDefinitionsHolder) and: [ 
		self isVisibleInAspects: 	theAspects definitionsHolder: 	theDefinitionsHolder
	]!

isVisibleInModules: 		theModules
	definitionsHolder: 	theDefinitionsHolder


	| aThisModule |

	(theModules isNil or: [ theModules isEmpty]) ifTrue: [ ^true ].

	(theModules isNil not and: [ theModules isEmpty not]) ifTrue: [ 
		aThisModule := self superModule.
		aThisModule isNil ifTrue: [ ^false].
		(theModules includes: aThisModule) ifFalse: [ 
			(theModules detect: [:aModule | aModule includesModule: aModule] ifNone: [ nil]) isNil ifTrue: [ ^false]
		]
	].!

model
	^self superModule isNil ifTrue: [ nil] ifFalse: [ self superModule model]!

rootTypes
	| someTypes |
	someTypes := IdentitySet new: 37.
	self rootTypesInto: someTypes.
	^someTypes!

rootTypesInto: theSet
	theSet isNil ifTrue: [ ^self].

	self types do: [:aType | 
		aType isRootType ifTrue: [ theSet add: aType].
		aType rootTypesInto: theSet
	].
	self subModules do: [:aModule | aModule rootTypesInto: theSet].!

treeRootType
	| aRoot someTypes |

	rootType isNil ifFalse: [ ^rootType].
	rootTypeSearched == true ifTrue: [ ^nil].
 
	someTypes := self types.

	aRoot := someTypes detect: [:aType | aType isTreeRootType] ifNone: [ nil].
	aRoot isNil ifFalse: [ 
		rootTypeSearched := true.
		rootType := aRoot.
		^aRoot].

	someTypes detect: [:aType | (aRoot := aType treeRootType) isNil not] ifNone: [ nil].
	aRoot isNil ifFalse: [ 
		rootTypeSearched := true.
		rootType := aRoot.
		^aRoot].
	self subModules detect: [:aModule | (aRoot := aModule treeRootType) isNil not] ifNone: [ nil].

	rootTypeSearched := true.
	rootType := aRoot.
	^aRoot! !

!CODEModule publicMethodsFor: 'dirty'!

cleanDirtyMark
	super cleanDirtyMark.
	self types do: [:aType | aType cleanDirtyMark].
	self subModules do: [:aModule | aModule cleanDirtyMark].!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self superModule isNil ifFalse: [ self superModule markDirtyOwner]
	].!

markDirtyOwner
	self mustStore 
		ifTrue: [ self markDirty]
		ifFalse: [ self superModule isNil ifFalse: [ self superModule markDirty]]!

persistIfDirty
	^self superModule isNil ifFalse: [self  superModule persistIfDirty] ifTrue: [ nil]! !

!CODEModule publicMethodsFor: 'generate'!

generate

	self skip ifTrue: [ ^self].
Transcript show: 'M ', self name;cr.


	self types do: [:aType | aType generate].


	self subModules do: [:aModule | aModule generate]!

generateM3ModuleInitialization

	| aSuperModule |
	self skip ifTrue: [ ^self].

	self  metamodelOutStream 
		tab;tab;
		nextPutAll:  (self expand: 'MetaVariableName');
		nextPutAll: ' = (',self metaModuleFullIfcPrefixedClassName,') theCtxt.getMMFactory("', self model m3FactoryName, 
			'").createMMElementOfType( theCtxt, "Module", "core",',
			'"', self name, '");';cr.


	aSuperModule := self superModule.
	aSuperModule isNil ifFalse: [ 
		self  metamodelOutStream 
			tab;tab;
			nextPutAll:  (aSuperModule expand: 'MetaVariableName');
			nextPutAll: '.addSubModules( theCtxt, ';
			nextPutAll:  (self expand: 'MetaVariableName');
			nextPutAll: ');';
			cr.
	].

	self generateM3TypesInModuleInitializations.
	self metamodelOutStream cr.

	self subModules do: [:aModule | aModule generateM3ModuleInitialization].
	self metamodelOutStream cr.

"      vm3CoreModule = new com.d_a_t.eai.studio.m3.impl.M3ModuleImpl( theCtxt, new EAIMMName('core'));
	  vm3CxModule.addSubModules( theCtxt, vm3CoreModule);
	  vm3CoreModule.addTypes( theCtxt, com.d_a_t.cx.core.impl.CxPackageImpl.vm3Type);
"!

generateM3StorageDefinition

	self skip ifTrue: [ ^self].

	self  metamodelOutStream 
		tab;
		nextPutAll: 'public static ', self metaModuleFullIfcPrefixedClassName, ' ';
		nextPutAll: (self expand: 'MetaVariableName');
		nextPutAll: ';';
		cr; cr

"  public static com.d_a_t.eai.studio.m3.ifc.M3ModuleIfc vm3ComModule;
"!

generateM3TypesInModuleInitializations

	self skip ifTrue: [ ^self].

	self types do: [:aType | aType generateM3TypeInModuleInitialization].

"    
	  vm3CoreModule.addTypes( theCtxt, com.d_a_t.cx.core.impl.CxPackageImpl.vm3Type);
"!

generateM3TypesPhase1Initializations

	self skip ifTrue: [ ^self].

	self types do: [:aType | aType generateM3ModelPhase1Initialization].
	self metamodelOutStream cr.
	self subModules do: [:aModule | aModule generateM3TypesPhase1Initializations].
	self metamodelOutStream cr.

"
	com.d_a_t.eai.studio.metamodel.impl.EAIProjectImpl.initM3TypePhase1( theCtxt);
	com.d_a_t.eai.studio.metamodel.impl.EAIPackageImpl.initM3TypePhase1( theCtxt);
"!

generateM3TypesPhase2Initializations

	self skip ifTrue: [ ^self].


	self types do: [:aType | aType generateM3ModelPhase2Initialization].
	self metamodelOutStream cr.
	self subModules do: [:aModule | aModule generateM3TypesPhase2Initializations].
	self metamodelOutStream cr.

"
	com.d_a_t.eai.studio.metamodel.impl.EAIProjectImpl.initM3TypePhase1( theCtxt);
	com.d_a_t.eai.studio.metamodel.impl.EAIPackageImpl.initM3TypePhase1( theCtxt);
"!

generateNMgrBMgrConfigs

	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateNMgrBMgrConfigs].
	self subModules do:[:aModule |  aModule generateNMgrBMgrConfigs].!

generateNMgrBmgrStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateNMgrBmgrStaticDeclarations].
	self subModules do:[:aModule |  aModule generateNMgrBmgrStaticDeclarations].!

generateProjectNodeModuleDeclarations: theStartIndex
	| anStartIndex anStream |

	self skip ifTrue: [ ^theStartIndex].

	anStartIndex := theStartIndex.

	self typesSize > 0  ifTrue: [ 
		self baseOutPrjNdx: anStartIndex.
		self implOutPrjNdx: anStartIndex + 1.
		self ifcOutPrjNdx: anStartIndex + 2.
		self trxOutPrjNdx: anStartIndex + 3.
		self privOutPrjNdx: anStartIndex + 4.

		anStartIndex := anStartIndex + 5.

		anStream := self prjOutStream.
		anStream isNil ifTrue: [ ^anStartIndex].

		anStream nextPutAll: '#' , self baseOutPrjNdx printString, '=', self projectNodeBaseDeclarationName; cr.
		anStream nextPutAll: '#' , self implOutPrjNdx printString, '=',  self projectNodeImplDeclarationName; cr.
		anStream nextPutAll: '#' , self ifcOutPrjNdx printString, '=',  self projectNodeIfcDeclarationName; cr.
		anStream nextPutAll: '#' , self trxOutPrjNdx printString, '=',  self projectNodeTrxDeclarationName; cr.
		anStream nextPutAll: '#' , self privOutPrjNdx printString, '=',  self projectNodePrivDeclarationName; cr.
	].

	anStartIndex := self subModules inject: anStartIndex into:[:anIndex :aModule | 
		aModule generateProjectNodeModuleDeclarations: anIndex].
	
	^anStartIndex!

generateProjectNodeModuleParameters
	| anStream |

	self skip ifTrue: [ ^self].

	self typesSize > 0 ifTrue: [ 
		anStream := self prjOutStream.
		anStream isNil ifFalse: [

			anStream nextPutAll: 'sys[' , self baseOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self baseOutPrjNdx printString, '].Type=Folder'; cr.
			anStream nextPutAll: 'sys[' , self implOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self implOutPrjNdx printString, '].Type=Folder'; cr.
			anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].Type=Folder'; cr.
			anStream nextPutAll: 'sys[' , self trxOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self trxOutPrjNdx printString, '].Type=Folder'; cr.
			anStream nextPutAll: 'sys[' , self privOutPrjNdx printString, '].Parent=0'; cr.
			anStream nextPutAll: 'sys[' , self privOutPrjNdx printString, '].Type=Folder'; cr.	
		]
	].

	self subModules do:[:aModule |  aModule generateProjectNodeModuleParameters].!

generateProjectNodeTypeDeclarations: theStartIndex
	| anStartIndex |


	self skip ifTrue: [ ^theStartIndex].

	anStartIndex := theStartIndex.
	anStartIndex := self types inject: anStartIndex into:[:anIndex :aType | 
		aType generateProjectNodeDeclarations: anIndex].

	anStartIndex := self subModules inject: anStartIndex into:[:anIndex :aModule | 
		aModule generateProjectNodeTypeDeclarations: anIndex].
	
	^anStartIndex!

generateProjectNodeTypeParameters


	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateProjectNodeParameters].
	self subModules do:[:aModule |  aModule generateProjectNodeTypeParameters].!

generateRootNodeConfigs


	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateRootNodeConfig].
	self subModules do:[:aModule |  aModule generateRootNodeConfigs].! !

!CODEModule publicMethodsFor: 'generate-streams'!

metamodelOutStream 

	^self model isNil ifTrue: [ nil] ifFalse: [	self model  metamodelOutStream]!

prjOutStream
	^self model isNil ifTrue: [ nil] ifFalse: [ self model prjOutStream]! !

!CODEModule publicMethodsFor: 'generate-support'!

expand: theKey
	expansionInitialized == true ifFalse: [ self initializeExpansions].

	^self expansions at: theKey ifAbsent: [ self model expand: theKey]!

fullPackageName
	| aModule |
	aModule  := self superModule.
	aModule isNil ifTrue: [ ^self name].
	^aModule fullPackageName, '.', self name!

initBaseOutPrjNdx
	baseOutPrjNdx := 0!

initializeExpansions
	
	self expansion: 'MetaVariableName' value: 'vm3Module', 
		(self superModule isNil ifTrue: [''] ifFalse: [ self superModule upperInitialName]) , 
		self upperInitialName.

	self expansion: 'MetaModuleFullIfcPrefixedClassName' value: self model metaModuleFullIfcPrefixedClassName.
	self expansion: 'MetaModuleFullImplPrefixedClassName' value: self model  metaModuleFullImplPrefixedClassName.
	self expansion: 'M3ModelName' value: self model typePrefix.!

initIfcOutPrjNdx
	ifcOutPrjNdx :=  0!

initImplOutPrjNdx
	implOutPrjNdx :=  0!

initPrivOutPrjNdx
	privOutPrjNdx :=  0!

initPrjNdx
	prjNdx := 0!

initTrxOutPrjNdx
	trxOutPrjNdx := 0!

metaAttributeFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaAttributeFullIfcPrefixedClassName!

metaAttributeFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaAttributeFullImplPrefixedClassName!

metaModelFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModelFullIfcPrefixedClassName!

metaModelFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModelFullImplPrefixedClassName!

metaModuleFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModuleFullIfcPrefixedClassName!

metaModuleFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModuleFullImplPrefixedClassName!

metaRelationshipFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaRelationshipFullIfcPrefixedClassName!

metaRelationshipFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaRelationshipFullImplPrefixedClassName!

metaTypeFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaTypeFullIfcPrefixedClassName!

metaTypeFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaTypeFullImplPrefixedClassName!

metaTypeFullPubPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaTypeFullPubPrefixedClassName!

mmElementWithM3FullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel mmElementWithM3FullIfcPrefixedClassName!

outputDirectoryWithPackage
	| anOutputDirectoryName aPath aDirectory anOutputDirectory aPackage aPackageString aPackageList aPackagePath |
	anOutputDirectoryName :=  self model outputDirectory.
	aPath := anOutputDirectoryName , (String with: Filename separator), self packageAsPath.
	aDirectory := aPath asFilename.
	aDirectory exists ifTrue: [
		aDirectory isDirectory ifFalse: [ 
			Transcript show: '!!!!!!ERROR!!!!!!  OutputDirectoryWithPackage ', aPath,  ' is not a Directory'; cr;cr.
			self error:  '!!!!!!ERROR!!!!!!  OutputDirectoryWithPackage ', aPath , ' is not a Directory'.
			^nil].
		 ^aPath].
	
	anOutputDirectory := anOutputDirectoryName asFilename.
	anOutputDirectory exists ifFalse: [ 
		Transcript show: '!!!!!!ERROR!!!!!!  OutputDirectory ', anOutputDirectoryName,  ' does not exists'; cr;cr.
		self error:  '!!!!!!ERROR!!!!!!  OutputDirectory ', anOutputDirectoryName , ' does not exists'.
		^nil].
	anOutputDirectory isDirectory ifFalse: [ 
		Transcript show: '!!!!!!ERROR!!!!!!  OutputDirectory ', anOutputDirectoryName,  ' is not a Directory'; cr;cr.
		self error:  '!!!!!!ERROR!!!!!!  OutputDirectory ', anOutputDirectoryName , ' is not a Directory'.
		^nil].

	aPackage := self fullPackageName.
	aPackageString := aPackage copyReplaceAll: '.' with: ' '.
	aPackageList := aPackageString asArrayOfSubstrings.
	aPackagePath := anOutputDirectoryName.
	aPackageList do: [:aPackageElement | |  aPackageDirectory | 
		(aPackageElement isNil not and: [ aPackageElement isEmpty not]) ifTrue: [ 
			aPackagePath := aPackagePath , (String with: Filename separator), aPackageElement.
			aPackageDirectory := aPackagePath asFilename.
			aPackageDirectory exists
				ifFalse: [  aPackageDirectory makeDirectory ]
				ifTrue: [ 
					aPackageDirectory isDirectory ifFalse: [ 
						Transcript show: '!!!!!!ERROR!!!!!!  PackageDirectory ', aPackagePath,  ' is not a Directory'; cr;cr.
						self error:  '!!!!!!ERROR!!!!!!  PackageDirectory ', aPackagePath , ' is not a Directory'.
						^nil]
				]
		]
	].
	^aPath!

outputDirectoryWithPackageAndFolder: theFolder
	| aPath aPathWithFolder aPathWithFolderDirectory |
	
	aPath := self outputDirectoryWithPackage.
	aPath isNil ifTrue: [ ^nil].

	aPathWithFolder := 	aPath , (String with: Filename separator), theFolder.
	aPathWithFolderDirectory := aPathWithFolder asFilename.
	aPathWithFolderDirectory exists
		ifFalse: [  aPathWithFolderDirectory makeDirectory ]
		ifTrue: [ 
			aPathWithFolderDirectory isDirectory ifFalse: [ 
				Transcript show: '!!!!!!ERROR!!!!!!  PackageWithFolderDirectory ', aPathWithFolder,  ' is not a Directory'; cr;cr.
				self error:  '!!!!!!ERROR!!!!!!  PackageWithFolderDirectory ', aPathWithFolder , ' is not a Directory'.
				^nil]
		].

	^aPathWithFolder!

packageAsPath
	| aPackage aPath |
	aPackage := self fullPackageName.
	aPath := aPackage copyReplaceAll: '.' with: (String with: Filename separator).
	^aPath!

parentModuleNames
	self superModule isNil ifTrue: [ ^self name].
	^self name , ' ', self superModule parentModuleNames!

projectNodeBaseDeclarationName

	^self name , ' base ' , self parentModuleNames!

projectNodeIfcDeclarationName

	^self name , ' ifc ' , self parentModuleNames!

projectNodeImplDeclarationName

	^self name , ' impl ' , self parentModuleNames!

projectNodePrivDeclarationName

	^self name , ' priv ' , self parentModuleNames!

projectNodeTrxDeclarationName

	^self name , ' trx ' , self parentModuleNames! !

!CODEModule publicMethodsFor: 'generate-traversals'!

generateTraversalAttributeCfgsStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalAttributeCfgsStaticDeclarations].
	self subModules do:[:aModule |  aModule generateTraversalAttributeCfgsStaticDeclarations].!

generateTraversalAttributeCfgsStaticInstantiations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalAttributeCfgsStaticInstantiations].
	self subModules do:[:aModule |  aModule generateTraversalAttributeCfgsStaticInstantiations].!

generateTraversalBranchCfgsStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalBranchCfgsStaticDeclarations].
	self subModules do:[:aModule |  aModule generateTraversalBranchCfgsStaticDeclarations].!

generateTraversalBranchCfgsStaticInitializations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalBranchCfgsStaticInitializations].
	self subModules do:[:aModule |  aModule generateTraversalBranchCfgsStaticInitializations].!

generateTraversalBranchCfgsStaticInstantiations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalBranchCfgsStaticInstantiations].
	self subModules do:[:aModule |  aModule generateTraversalBranchCfgsStaticInstantiations].!

generateTraversalBranchMgrsStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalBranchMgrsStaticDeclarations].
	self subModules do:[:aModule |  aModule generateTraversalBranchMgrsStaticDeclarations].!

generateTraversalBranchMgrsStaticInstantiations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalBranchMgrsStaticInstantiations].
	self subModules do:[:aModule |  aModule generateTraversalBranchMgrsStaticInstantiations].!

generateTraversalFieldMgrsStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalFieldMgrsStaticDeclarations].
	self subModules do:[:aModule |  aModule generateTraversalFieldMgrsStaticDeclarations].!

generateTraversalFieldMgrsStaticInstantiations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalFieldMgrsStaticInstantiations].
	self subModules do:[:aModule |  aModule generateTraversalFieldMgrsStaticInstantiations].!

generateTraversalNodeCfgsStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalNodeCfgsStaticDeclarations].
	self subModules do:[:aModule |  aModule generateTraversalNodeCfgsStaticDeclarations].!

generateTraversalNodeCfgsStaticInitializations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalNodeCfgsStaticInitializations].
	self subModules do:[:aModule |  aModule generateTraversalNodeCfgsStaticInitializations].!

generateTraversalNodeCfgsStaticInstantiations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalNodeCfgsStaticInstantiations].
	self subModules do:[:aModule |  aModule generateTraversalNodeCfgsStaticInstantiations].!

generateTraversalNodeMgrsStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalNodeMgrsStaticDeclarations].
	self subModules do:[:aModule |  aModule generateTraversalNodeMgrsStaticDeclarations].!

generateTraversalNodeMgrsStaticInstantiations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalNodeMgrsStaticInstantiations].
	self subModules do:[:aModule |  aModule generateTraversalNodeMgrsStaticInstantiations].!

generateTraversalRelatedTypeNodeCfgsStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalRelatedTypeNodeCfgsStaticDeclarations].
	self subModules do:[:aModule |  aModule generateTraversalRelatedTypeNodeCfgsStaticDeclarations].!

generateTraversalRelatedTypeNodeCfgsStaticInstantiations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalRelatedTypeNodeCfgsStaticInstantiations].
	self subModules do:[:aModule |  aModule generateTraversalRelatedTypeNodeCfgsStaticInstantiations].!

generateTraversalRootTypeNodeCfgsStaticDeclarations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalRootTypeNodeCfgsStaticDeclarations].
	self subModules do:[:aModule |  aModule generateTraversalRootTypeNodeCfgsStaticDeclarations].!

generateTraversalRootTypeNodeCfgsStaticInstantiations
	self skip ifTrue: [ ^self].

	self types do:[:aType |  aType generateTraversalRootTypeNodeCfgsStaticInstantiations].
	self subModules do:[:aModule |  aModule generateTraversalRootTypeNodeCfgsStaticInstantiations].! !

!CODEModule publicMethodsFor: 'initialize-release'!

initSkip
	skip := false!

release
	self changed: #objectDisconnectedOfTree.

	self superModuleRelease.

	self subModulesRelease.

	self typesRelease.

	super release! !

!CODEModule publicMethodsFor: 'integrity'!

integrityReportHereJustFirst: theJustFirst

	| aThisCriticsNode |
	aThisCriticsNode :=  super integrityReportHereJustFirst: theJustFirst.
	(theJustFirst == true and: [ aThisCriticsNode isVoid not]) ifTrue:  [ ^aThisCriticsNode].

	self integrityReportHereSuperModule: aThisCriticsNode justFirst: theJustFirst.
	(theJustFirst == true and: [ aThisCriticsNode isVoid not]) ifTrue:  [ ^aThisCriticsNode].

	self integrityReportHereSubModules: aThisCriticsNode justFirst: theJustFirst.
	(theJustFirst == true and: [ aThisCriticsNode isVoid not]) ifTrue:  [ ^aThisCriticsNode].

	self integrityReportHereSubTypes: aThisCriticsNode justFirst: theJustFirst.
	(theJustFirst == true and: [ aThisCriticsNode isVoid not]) ifTrue:  [ ^aThisCriticsNode].

	^aThisCriticsNode!

integrityReportHereSuperModule: theThisCriticsNode justFirst: theJustFirst

	| aSuperModule aNewCriticsNode |

	theThisCriticsNode isNil ifTrue: [ ^self].

	(theJustFirst == true and: [ theThisCriticsNode isNil not and: [ theThisCriticsNode isVoid not]]) ifTrue:  [ ^self].

	aSuperModule := self superModule.
	aSuperModule isNil ifTrue: [ 
		theThisCriticsNode isVoid 
			ifTrue: [ 
				theThisCriticsNode constrained: #superModule.

			]
			ifFalse: [ 
				aNewCriticsNode := MDAMCriticsNode new.
				aNewCriticsNode element: self.
				theThisCriticsNode childrenNodesAdd: aNewCriticsNode.
			].
			^self
	].

	(aSuperModule subModulesIncludes: self) ifFalse: [ 
		theThisCriticsNode isVoid 
			ifTrue: [ 
				theThisCriticsNode constrained: #superModule.

			]
			ifFalse: [ 
				aNewCriticsNode := MDAMCriticsNode new.
				aNewCriticsNode element: self.
				theThisCriticsNode childrenNodesAdd: aNewCriticsNode.
			].
			^self
	].!

integrityReportJustFirst: theJustFirst

	"| someModules someTypes |

	aThisCriticsNode := super integrityReportJustFirst: theJustFirst.
	
	(theJustFirst == true and: [ aThisCriticsNode isNil not and: [ aThisCriticsNode isVoid not]]) ifTrue:  [ ^aThisCriticsNode].

	aSuperModule := self superModule.
	aSuperModule isNil ifTrue: [ 

	someModules := self subModules.
	someModules do: [:aSubModule | | aSubModuleSuperModule aReportEntry |
		aSubModuleSuperModule := aSubModule superModule.
		self == aSubModuleSuperModule ifFalse: [ 
			aCriticsNode := MDAMCriticsNode new.
			aCriticsNode element: aSubModule.
			aCriticsNode constrained: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].


	someModules := self subModules.
	someModules do: [:aSubModule | | aSubModuleSuperModule aReportEntry |
		aSubModuleSuperModule := aSubModule superModule.
		self == aSubModuleSuperModule ifFalse: [ 
			aCriticsNode := MDAMCriticsNode new.
			aCriticsNode element: aSubModule.
			aCriticsNode constrained: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].

	someTypes := self types.
	someTypes do: [:aType | | aSuperType aReportEntry |
		aSuperType := aType module.
		self == aSuperType ifFalse: [ 
			aReportEntry := theReport at: aType ifAbsent: [ nil].
			aReportEntry ifTrue: [ 
				aReportEntry := OrderedCollection new: 2.
				theReport at: aType put: aReportEntry
			].
			aReportEntry add: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].

	someTypes := self types.
	someTypes do: [:aType |
		aType integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst == true and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].

	someModules := self subModules.
	someModules do: [:aModule |
		aModule integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst == true and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	]."!

integrityReportSuperModuleIn: theThisCriticsNode justFirst: theJustFirst
"
	| someModules someTypes |

	aSuperModule := self superModule.
	aSuperModule isNil ifTrue: [ 
	
	(theJustFirst == true and: [ aThisCriticsNode isNil not and: [ aThisCriticsNode isVoid not]]) ifTrue:  [ ^aThisCriticsNode].


	someModules := self subModules.
	someModules do: [:aSubModule | | aSubModuleSuperModule aReportEntry |
		aSubModuleSuperModule := aSubModule superModule.
		self == aSubModuleSuperModule ifFalse: [ 
			aCriticsNode := MDAMCriticsNode new.
			aCriticsNode element: aSubModule.
			aCriticsNode constrained: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].


	someModules := self subModules.
	someModules do: [:aSubModule | | aSubModuleSuperModule aReportEntry |
		aSubModuleSuperModule := aSubModule superModule.
		self == aSubModuleSuperModule ifFalse: [ 
			aCriticsNode := MDAMCriticsNode new.
			aCriticsNode element: aSubModule.
			aCriticsNode constrained: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].

	someTypes := self types.
	someTypes do: [:aType | | aSuperType aReportEntry |
		aSuperType := aType module.
		self == aSuperType ifFalse: [ 
			aReportEntry := theReport at: aType ifAbsent: [ nil].
			aReportEntry ifTrue: [ 
				aReportEntry := OrderedCollection new: 2.
				theReport at: aType put: aReportEntry
			].
			aReportEntry add: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].

	someTypes := self types.
	someTypes do: [:aType |
		aType integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst == true and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].

	someModules := self subModules.
	someModules do: [:aModule |
		aModule integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst == true and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	]."! !

!CODEModule publicMethodsFor: 'parse'!

contentFromStream: theStream

	theStream isNil ifTrue: [ ^nil].
	theStream atEnd ifTrue: [ ^nil].
	self model isNil ifTrue: [ ^nil].

	[ theStream atEnd] whileFalse: [ |  aLine aTrimmedLine |
		aLine := theStream upTo: Character cr.
		aTrimmedLine := aLine trimSeparators.
		aTrimmedLine isEmpty ifFalse: [ 
			aTrimmedLine first = $} ifTrue: [ ^self].
			self fromLine: aTrimmedLine andStream: theStream	
		]	
	]!

errorFromLineStream: theLineStream andStream: theStream
	
	| anErrorKind anErrorName |

	theLineStream isNil ifTrue: [ ^self].
	theLineStream atEnd ifTrue: [ ^self].
	
	anErrorKind := theLineStream skipSeparators; upTo: $:.
	anErrorKind isEmpty ifTrue: [ ^self].

	anErrorName := ''.
	theLineStream atEnd ifFalse: [ 
		anErrorName := theLineStream skipSeparators;  upToEnd.
	].
	self model foundErrorLine: anErrorKind name: anErrorName!

featureNamedArray: theNames
	
	| aName aModule otherNames aType |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 2 ifTrue: [ 
		aType := self typeNamed: aName.
		aType isNil ifTrue: [ ^nil].
		^aType featureNamed: (theNames at: 2)
	].
	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ ^nil].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule featureNamedArray: otherNames!

findFeatureNamed: theFeatureName
	
	| anSpacedTypeName someNames |
	theFeatureName isNil ifTrue: [ ^self].
	theFeatureName isEmpty ifTrue: [ ^self].

	(theFeatureName findString: '::' startingAt: 1 ) > 0 
		ifFalse: [ ^nil]
		ifTrue: [ 
			anSpacedTypeName := theFeatureName copyReplaceAll: '::' with: ' '.
			someNames := anSpacedTypeName asArrayOfSubstrings
		].
	
	^self findFeatureNamedArray: someNames!

findFeatureNamedArray: theNames
	
	| aName aModule otherNames aSuperModule aType |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ 
		aType := self typeNamed: aName.
		aType isNil ifFalse: [ ^aType].
	].

	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ 
		aSuperModule := self superModule.
		aSuperModule isNil ifTrue: [ ^nil].
		^aSuperModule findFeatureNamedArray: theNames].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule featureNamedArray: otherNames!

findModuleNamed: theModuleName
	
	| anExistingModule anSpacedModuleName someNames |
	theModuleName isNil ifTrue: [ ^self].
	theModuleName isEmpty ifTrue: [ ^self].

	(theModuleName findString: '::' startingAt: 1 ) > 0 
		ifFalse: [  
			anExistingModule := self types detect: [:aModule | aModule name = theModuleName] ifNone: [ nil].
			anExistingModule isNil ifFalse: [ ^anExistingModule].
			someNames := Array with: theModuleName
		]
		ifTrue: [ 
			anSpacedModuleName := theModuleName copyReplaceAll: '::' with: ' '.
			someNames := anSpacedModuleName asArrayOfSubstrings
		].
	
	^self findModuleNamedArray: someNames!

findModuleNamedArray: theNames
	
	| aName aModule otherNames aSuperModule aModule |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ 
		aModule := self typeNamed: aName.
		aModule isNil ifFalse: [ ^aModule].
	].

	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ 
		aSuperModule := self superModule.
		aSuperModule isNil ifTrue: [ ^nil].
		^aSuperModule findModuleNamedArray: theNames].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames!

findSubModuleNamed: theSubModuleName
	
	| anExistingSubModule anSpacedSubModuleName someNames |
	theSubModuleName isNil ifTrue: [ ^self].
	theSubModuleName isEmpty ifTrue: [ ^self].

	(theSubModuleName findString: '::' startingAt: 1 ) > 0 
		ifFalse: [  
			anExistingSubModule := self subModulesPrivate detect: [:aSubModule | aSubModule name = theSubModuleName] ifNone: [ nil].
			anExistingSubModule isNil ifFalse: [ ^anExistingSubModule].
			someNames := Array with: theSubModuleName
		]
		ifTrue: [ 
			anSpacedSubModuleName := theSubModuleName copyReplaceAll: '::' with: ' '.
			someNames := anSpacedSubModuleName asArrayOfSubstrings
		].
	
	^self findSubModuleNamed: someNames!

findSubModuleNamedArray: theNames
	
	| aName aModule otherNames aSuperModule aSubModule |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ 
		aSubModule := self typeNamed: aName.
		aSubModule isNil ifFalse: [ ^aSubModule].
	].

	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ 
		aSuperModule := self superModule.
		aSuperModule isNil ifTrue: [ ^nil].
		^aSuperModule findSubModuleNamedArray: theNames].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames!

findTypeNamed: theTypeName
	
	| anExistingType anSpacedTypeName someNames |
	theTypeName isNil ifTrue: [ ^self].
	theTypeName isEmpty ifTrue: [ ^self].

	(theTypeName findString: '::' startingAt: 1 ) > 0 
		ifFalse: [  
			anExistingType := self types detect: [:aType | aType name = theTypeName] ifNone: [ nil].
			anExistingType isNil ifFalse: [ ^anExistingType].
			someNames := Array with: theTypeName
		]
		ifTrue: [ 
			anSpacedTypeName := theTypeName copyReplaceAll: '::' with: ' '.
			someNames := anSpacedTypeName asArrayOfSubstrings
		].
	
	^self findTypeNamedArray: someNames!

findTypeNamedArray: theNames
	
	| aName aModule otherNames aSuperModule aType |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ 
		aType := self typeNamed: aName.
		aType isNil ifFalse: [ ^aType].
	].

	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ 
		aSuperModule := self superModule.
		aSuperModule isNil ifTrue: [ ^nil].
		^aSuperModule findTypeNamedArray: theNames].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames!

fromLine: theLine andStream: theStream
	
	| aStream  |
	theLine isNil ifTrue: [ ^self].
	theLine isEmpty ifTrue: [ ^self].
	((theLine first = $/ and: [ ((theLine findString: '//Error:' startingAt: 1) == 1) not]) or: [ theLine first == $#]) ifTrue: [ ^self].

	aStream := ReadStream on: theLine.
	[ aStream atEnd] whileFalse: [ | aWord  |
		aWord := aStream upTo: Character space.
		aWord isEmpty ifFalse: [ 
			aWord = '//Error:' ifTrue: [  self errorFromLineStream: aStream andStream: theStream] ifFalse: [ 
			aWord = '[is_abstract]' ifTrue: [  self isAbstractFromLineStream: aStream andStream: theStream] ifFalse: [ 
			aWord = 'type' ifTrue: [ 
				self typeFromLineStream: aStream andStream: theStream.
				self model dropErrorLine.
				self model forgetIsAbstract] ifFalse: [ 
			aWord = 'module' ifTrue: [ 
				self model dropErrorLine.
				self model forgetIsAbstract.
				self moduleFromLineStream: aStream andStream: theStream ] ifFalse: [ 
			]]]]			
		]
	]!

fromLineStream: theLineStream andStream: theStream

	theLineStream isNil ifTrue: [ ^nil].
	theLineStream atEnd ifTrue: [ ^nil].
self logTranscript ifTrue: [ Transcript  show: ' >> Model or Module ';  show: self name; cr].

	[ theLineStream atEnd] whileFalse: [ 	| aWord |
		aWord := self nextTokenFrom: theLineStream.
		aWord isNil ifTrue: [ ^nil].
		aWord = '{' 
			ifTrue: [ self contentFromStream: theStream]
			ifFalse: [ 
				aWord = '}' ifTrue: [ ^self]
			]	

	]!

isAbstractFromLineStream: theLineStream andStream: theStream
	
	self model rememberFoundIsAbstract!

moduleFromLineStream: theLineStream andStream: theStream
	
	| aModuleName   anExistingModule aNewModule |

	theLineStream isNil ifTrue: [ ^self].
	theLineStream atEnd ifTrue: [ ^self].
	
	aModuleName := self nextTokenFrom: theLineStream.
	aModuleName isEmpty ifTrue: [ ^self].
	
	anExistingModule := self moduleNamed: aModuleName.
	anExistingModule isNil
		ifFalse: [ anExistingModule fromLineStream: theLineStream andStream: theStream]
		ifTrue: [  
self logTranscript ifTrue: [ Transcript show: '+ M '; show: aModuleName; cr].
			aNewModule := CODEModule new.
			aNewModule name: aModuleName.
			self subModulesAdd: aNewModule.
			aNewModule fromLineStream: theLineStream andStream: theStream
		]!

moduleNamedArray: theNames
	
	| aName aModule otherNames |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ ^self moduleNamed: aName].
	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ ^nil].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule moduleNamedArray: otherNames!

subModuleNamed: theModuleName
	
	| anExistingModule |
	theModuleName isNil ifTrue: [ ^self].

	anExistingModule := self subModulesPrivate detect: [:aModule | aModule name = theModuleName] ifNone: [ nil].
	^anExistingModule!

typeFromLineStream: theLineStream andStream: theStream
	
	| aTypeName   anExistingType aNewType anErrorName |

	theLineStream isNil ifTrue: [ ^self].
	theLineStream atEnd ifTrue: [ ^self].
	
	aTypeName := self nextTokenFrom: theLineStream.
	aTypeName isEmpty ifTrue: [ ^self].
	
	anExistingType := self typeNamed: aTypeName.
	anExistingType isNil
		ifFalse: [ 
			self model errorLineKind isNil ifFalse: [ 
				anErrorName := self model errorLineName.
				anErrorName = 'Enumeration' ifTrue: [ anExistingType isEnumeration: true].
				anErrorName = 'primitive' ifTrue: [ anExistingType isPrimitive: true].
			].
			self model foundIsAbstract ifTrue: [ 
				 anExistingType isAbstract: true].

			anExistingType fromLineStream: theLineStream andStream: theStream]
		ifTrue: [  
self logTranscript ifTrue: [ Transcript show: '+ T '; show: aTypeName; cr].
					
			aNewType := CODEType new.
			aNewType name: aTypeName.
			self typesAdd: aNewType.
			self model errorLineKind isNil ifFalse: [ 
				anErrorName := self model errorLineName.
				anErrorName = 'Enumeration' ifTrue: [ aNewType isEnumeration: true].
				anErrorName = 'primitive' ifTrue: [ aNewType isPrimitive: true].
			].
			aNewType fromLineStream: theLineStream andStream: theStream
		].!

typeNamedArray: theNames
	
	| aName aModule otherNames |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ ^self typeNamed: aName].
	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ ^nil].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames! !

!CODEModule publicMethodsFor: 'persistence-code'!

allModuleNamesArray

	| aStream |
	aStream := WriteStream on: (OrderedCollection new: 8).
	self allModuleNamesArrayInto: aStream.
	^aStream contents!

allModuleNamesArrayInto: theStream

	| aModule |
	theStream isNil ifTrue: [ ^self].

	aModule := self superModule.
	aModule isNil  ifFalse: [  aModule allModuleNamesArrayInto: theStream].

	theStream nextPut: self name!

allModuleNamesInto: theStream

	| aModule aSep |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aModule := self superModule.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

allQualifiedNamesInto: theStream
	^self allModuleNamesInto: theStream!

firstPersistenceIndexModule
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexModule.

	self forzeStoreClassName: 				(theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]). 
	self forzeStoreMethodSelector: 			(theValues size < (aFPI + 1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 1)]). 

	theValues size < (aFPI + 2) ifFalse: [  self initTypesFromValues: (theValues at: (aFPI + 2)) ].

	theValues size < (aFPI + 3) ifFalse: [  self initSubModulesFromValues: (theValues at: (aFPI + 3)) ].!

initSubModulesFromValues: theValues
	
	| someModules |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someModules := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someModules isNil ifFalse: [ 
		self subModulesPrivate addAll: someModules.
		someModules do: [:aC | aC superModulePrivate: self]]!

initTypesFromValues: theValues
	
	| someTypes |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someTypes := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someTypes isNil ifFalse: [ 
		self typesPrivate addAll: someTypes.
		someTypes do: [:aC | aC modulePrivate: self]]!

inner: theIsInner persistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| aSep aNewStream aNewChunk |

	aSep := self separatorForPersistenceAsCode.
	
	self isNotPersistentMetaInfo ifTrue: [ ^self].

	aNewStream :=  nil.
	aNewChunk := nil.

	theIsInner
		ifTrue: [ 
			self mustStore 
				ifFalse: [ 
					theStream isNil ifFalse: [ 
						theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self kind);  
							nextPutAll: aSep; nextPutAll: self name printString; cr].
					self localValuesPersistenceAsCodeStringChunks: theCollection 
						on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.
					theStream isNil ifFalse: [ theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr]
				]
				ifTrue: [ 
					self persistenceRefToMethodAsCodeStringOn: theStream indent: theIS.
					theDoSubChunks ifTrue: [ 

						(self mustStoreWithFilter: theFilter) ifTrue: [ 
							aNewStream := WriteStream on: (String new: self subPartsSize * 256).
							aNewChunk := Array with: self with: aNewStream.
							theCollection add: aNewChunk
						].
						self inner: false persistenceAsCodeStringChunks: theCollection 
							on: aNewStream filter: theFilter indent: self indentStringForPersistenceAsCode 
							doSubChunks: theDoSubChunks
					]
				]
		]
		ifFalse: [ 
			theStream isNil ifFalse: [ 
				theStream nextPutAll: theIS; nextPutAll: '#( ';  nextPutAll: (self pcForV: self kind);  
					nextPutAll: aSep; nextPutAll: self name printString; cr].
			self localValuesPersistenceAsCodeStringChunks: theCollection 
				on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.
			theStream isNil ifFalse: [ theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr]
		]!

localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self storeClassName );  nextPutAll: aSep; nextPutAll: (self pcForV:  self storeMethodSelector ); cr.

	(self typesPrivate isNil not and: [ self typesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	   	  		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class typesPersistenceSymbol); cr
			].
			self typesPrivate do:  [:aType |
				aType inner: true persistenceAsCodeStringChunks: theCollection on: theStream 
					filter: theFilter indent: anIS , self indentStringForPersistenceAsCode doSubChunks: theDoSubChunks
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
	].

	(self subModulesPrivate isNil not and: [ self subModulesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil); cr ]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	  	   		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class subModulesPersistenceSymbol); cr
			].
			self subModulesPrivate do:  [:aModule |
				aModule inner: true persistenceAsCodeStringChunks: theCollection on: theStream 
					filter: theFilter indent: anIS , self indentStringForPersistenceAsCode doSubChunks: theDoSubChunks
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

mustStore

	^self storeMethodSelector isNil not and: [ 
		self storeMethodSelector isEmpty not and: [ 
			self storeClassName isNil not and: [ 
				self storeClassName isEmpty not]]]!

mustStoreWithFilter: theFilter

	^theFilter = true or: [ 
			(theFilter = #dirty and: [ self isDirty]) or: [ 
				(self preferredInstallerClass existsElementMethod: self storeMethodSelector inClass: self storeClassName) not or: [ 
					theFilter = #source and: [ 
						(self preferredInstallerClass  sameSource: self persistenceAsCodeString
							elementMethod: self storeMethodSelector asSymbol inClass: self storeClassName asSymbol) not
					]
				]
			]
		]!

numberPersistenceEntriesModule
	^4!

persistenceAsCodeString

	| aCollection |

	aCollection := self persistenceAsCodeStringChunksFilter: true doSubChunks: false.
	(aCollection isNil or: [ aCollection isEmpty]) ifTrue: [ ^nil].

	^aCollection first at: 2!

persistenceRefToMethodArray

	^Array 
		with: self class refToModelMethodKind
		with: self name printString  
		with: self storeMethodSelector
		with: self storeClassName!

persistenceRefToMethodAsCodeStringOn: theStream indent: theIS

	| aSep |
	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
		
	theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self class refToModuleMethodKind);  
		nextPutAll: aSep; nextPutAll: self name printString;  
		nextPutAll: aSep; nextPutAll: (self pcForV: self storeMethodSelector); nextPutAll: aSep; nextPutAll: (self pcForV: self storeClassName);  
		nextPutAll: ' )' ; cr; cr.!

ph2InitFromSolver: theSolver

	super ph2InitFromSolver: theSolver.
	self typesPrivate do: [:aType | aType ph2InitFromSolver: theSolver].

	self subModulesPrivate do: [:aModule | aModule ph2InitFromSolver: theSolver]!

resolveOrNewReferencedAspectName: theName elementNames: theElementNames
	| anElementName someElementNames aTypeName aType aModule |
	theName isNil ifTrue: [ ^nil].
 
	(theElementNames isNil or: [ theElementNames isEmpty]) ifTrue: [
		^self resolveOrNewReferencedAspectName: theName
	].

	anElementName := theElementNames first.

	^anElementName = self class qualifiedNameTypeStepSymbol 
		ifFalse: [ 
			aModule := self moduleNamed: anElementName.
			aModule isNil ifTrue: [ ^nil].
			someElementNames := theElementNames copyFrom: 2 to: theElementNames size.
			aModule resolveOrNewReferencedAspectName: theName elementNames: someElementNames	
		]
		ifTrue: [ 
			theElementNames size < 2 ifTrue: [ ^nil].
			aTypeName := theElementNames at: 2. 
			aType := self typeNamed: aTypeName.
			aType isNil ifTrue: [ ^nil].
			theElementNames size < 3 ifTrue: [ ^aType].
			someElementNames := theElementNames copyFrom: 3 to: theElementNames size.
			aType resolveOrNewReferencedAspectName: theName elementNames: someElementNames	
		].!

resolveOrNewReferencedTypeName: theName
	| aType |

	theName isNil ifTrue: [ ^nil].

	aType := self typeNamed: theName.
	aType isNil ifFalse: [ ^aType].

	aType := self preferredTypeClass new name: theName.
	self typesAdd: aType.
	^aType!

resolveOrNewReferencedTypeName: theName moduleNames: theModuleNames
	| aModuleName someModuleNames aModule |
	theName isNil ifTrue: [ ^nil].
 
	(theModuleNames isNil or: [ theModuleNames isEmpty]) ifTrue: [
		^self resolveOrNewReferencedTypeName: theName
	].

	aModuleName := theModuleNames first.
	someModuleNames := theModuleNames copyFrom: 2 to: theModuleNames size.
	
	aModule := self subModuleNamed: aModuleName.
	aModule isNil ifTrue: [	
		aModule := self preferredModuleClass new name: aModuleName.
		self subModulesAdd: aModule.
	].

	^aModule resolveOrNewReferencedTypeName: theName moduleNames: someModuleNames!

resolveReferencedModuleNames: theModuleNames
	| aModuleName someModuleNames aModule |
 
	(theModuleNames isNil or: [ theModuleNames isEmpty]) ifTrue: [
		^self
	].

	aModuleName := theModuleNames first.
	someModuleNames := theModuleNames copyFrom: 2 to: theModuleNames size.
	
	aModule := self subModuleNamed: aModuleName.
	aModule isNil ifTrue: [^ nil].

	^aModule resolveReferencedModuleNames: someModuleNames!

resolveReferencedTypeName: theName
	| aType |

	theName isNil ifTrue: [ ^nil].

	aType := self typeNamed: theName.
	^aType!

resolveReferencedTypeName: theName moduleNames: theModuleNames
	| aModuleName someModuleNames aModule |
	theName isNil ifTrue: [ ^nil].
 
	(theModuleNames isNil or: [ theModuleNames isEmpty]) ifTrue: [
		^self resolveReferencedTypeName: theName
	].

	aModuleName := theModuleNames first.
	someModuleNames := theModuleNames copyFrom: 2 to: theModuleNames size.
	
	aModule := self subModuleNamed: aModuleName.
	aModule isNil ifTrue: [^ nil].

	^aModule resolveReferencedTypeName: theName moduleNames: someModuleNames! !

!CODEModule publicMethodsFor: 'semantic checking'!

checkBaseOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIfcOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkImplOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIncludedInModulesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIncludedModulesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIncludedModulesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkPrivOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSkip: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSubModulesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSubModulesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSuperModule: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTrxOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEModule publicMethodsFor: 'semantic links'!

includedInModulesCandidates
	"Generated by ISF/AD. Do not modify"
	^self includedInModules asArray!

includedInModulesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEModule new!

includedInModulesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self includedInModulesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self includedInModulesAdd: anObject.!

includedInModulesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self includedInModulesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self includedInModulesCreate class
		ifUnchanged: [^self].
	self includedInModulesAdd: anObject!

includedInModulesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

includedModulesCandidates
	"Generated by ISF/AD. Do not modify"
	^self includedModules asArray!

includedModulesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEModule new!

includedModulesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self includedModulesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self includedModulesAdd: anObject.!

includedModulesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self includedModulesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self includedModulesCreate class
		ifUnchanged: [^self].
	self includedModulesAdd: anObject!

includedModulesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

subModulesCandidates
	"Generated by ISF/AD. Do not modify"
	^self subModules asArray!

subModulesCreate
	^self preferredModuleClass new!

subModulesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self subModulesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self subModulesAdd: anObject]!

subModulesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self subModulesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self subModulesAdd: anObject.!

subModulesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self subModulesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self subModulesCreate class
		ifUnchanged: [^self].
	self subModulesAdd: anObject!

subModulesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

superModuleCandidates
	"Generated by ISF/AD. Do not modify"
	^self superModule isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self superModule]!

superModuleCreate
	"Generated by ISF/AD. Do not modify"
	^CODEModule new!

superModuleLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self superModuleCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self superModule: anObject]!

superModuleLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self superModuleCandidates
		initially: self superModule
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self superModule: anObject.!

superModuleLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self superModuleCandidates
		initially: self superModule
		label: 'Select Or Create ...'
		class: self superModuleCreate class
		ifUnchanged: [^self].
	self superModule: anObject!

superModuleScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typesCandidates
	"Generated by ISF/AD. Do not modify"
	^self types asArray!

typesCreate
	^self preferredTypeClass new!

typesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self typesAdd: anObject]!

typesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self typesAdd: anObject.!

typesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self typesCreate class
		ifUnchanged: [^self].
	self typesAdd: anObject!

typesScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEModule publicMethodsFor: 'semantic links-custom'!

includedInModulesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self includedInModulesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self includedInModulesAdd: anObject]!

includedModulesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self includedModulesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self includedModulesAdd: anObject]!

newOrExistingModuleNamedArray: theModuleNamesArray
	| someNewModules |
	theModuleNamesArray isNil ifTrue: [ ^nil].
	theModuleNamesArray isEmpty ifTrue: [ ^self].

	someNewModules := OrderedCollection new: theModuleNamesArray size.

	^self newOrExistingModuleNamedArray: theModuleNamesArray newModulesInto: someNewModules.!

newOrExistingModuleNamedArray: theModuleNamesArray newModulesInto: theNewModules
	| aModuleName someModuleNames aModule |
	theModuleNamesArray isNil ifTrue: [ ^nil].
	theModuleNamesArray isEmpty ifTrue: [ ^self].

	aModuleName := theModuleNamesArray first.
	someModuleNames := theModuleNamesArray copyFrom: 2 to: theModuleNamesArray size.

	aModule := self moduleNamed: aModuleName.
	aModule isNil ifTrue: [ 
		aModule := self preferredModuleClass new.
		aModule name: aModuleName.
		self subModulesAdd: aModule.
		theNewModules isNil ifFalse: [ theNewModules add: aModule].
	].
	^aModule newOrExistingModuleNamedArray: someModuleNames! !

!CODEModule publicMethodsFor: 'utils'!

determineIfRefiningMetaAttributes

	| someTypes |
	someTypes := self rootTypes.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ ^self].

	someTypes do: [:aType | | someTypesHierarchy |
		 someTypesHierarchy := aType withAllSubtypes.
		(someTypesHierarchy isNil or: [ someTypesHierarchy isEmpty]) ifFalse: [ 
			someTypesHierarchy do: [:otherType | | someFeatures someFeatureRefinements |
				someFeatures := otherType allEffectiveFeatures.
				(someFeatures isNil or: [ someFeatures isEmpty]) ifFalse: [ 
					someFeatureRefinements := someFeatures select: [:aFeature | 
						aFeature isStructuralFeature and: [ aFeature isRefinement]
					].
					someFeatureRefinements do: [:aFeature |
						aFeature determineIfRefiningMetaAttributes
					]
				]
			]
		]
	].!

refinementsWithoutRefined

	| someTypes someRefinementsWithoutRefined |
	someTypes := self rootTypes.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ ^self].

	someRefinementsWithoutRefined  := OrderedCollection new: 32.
	
	someTypes do: [:aType | | someTypesHierarchy |
		 someTypesHierarchy := aType withAllSubtypes.
		(someTypesHierarchy isNil or: [ someTypesHierarchy isEmpty]) ifFalse: [ 
			someTypesHierarchy do: [:otherType | | someFeatures  |
				someFeatures := otherType allEffectiveFeatures.
				(someFeatures isNil or: [ someFeatures isEmpty]) ifFalse: [ 
					someFeatures do: [:aFeature | 
						(aFeature isStructuralFeature and: [ aFeature isRefinement]) ifTrue: [ 
							aFeature refinedFeatures isEmpty ifTrue:  [ 
								someRefinementsWithoutRefined add: aFeature
							]
						]
					]
				]
			]
		]
	].
	^someRefinementsWithoutRefined! !

!CODEOperation class publicMethodsFor: 'accessing'!

kind
	^#operation! !

!CODEOperation class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEOperation class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^super modelEditorMETAPerspectives, self modelEditorMETAPerspectivesOperation, 
			self modelEditorMETAPerspectivesTranslation, self modelEditorMETAPerspectivesConstraints!

modelEditorMETAPerspectivesConstraints
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Constraints'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #(  'IsExclussion' 'ExecutableExpression'  'OrderConstraint'  'EnablementConstraint' )))
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Perspectives';
			nlsItem: 'Constraints';
			nlsTranslation: 'Constricciones';
			yourself);
		yourself!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'IsDirty' 'IsAbstract'  'MinMult' 'MaxMult'  'ReturnType')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesOperation

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ReturnType'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'ReturnType' )))
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Perspectives';
			nlsItem: 'ReturnType';
			nlsTranslation: 'TipoDeResultado';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Type'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Type' )))
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Perspectives';
			nlsItem: 'Type';
			nlsTranslation: 'Tipo';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'OperationRefinements'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'OperationRefinements' )))
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Perspectives';
			nlsItem: 'OperationRefinements';
			nlsTranslation: 'OperacionesRefinadas';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsOperation,
		self modelEditorMETASelectorsTranslation!

modelEditorMETASelectorsOperation

	"METAChildSpecAutoViewEditor openOn: CODEOperation selector: #modelEditorMETASelectorsOperation target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MinMult';
			basicSelector: #minMult;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MinMult';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: '0 1 2 *';
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'MinMult';
			nlsTranslation: 'MinimoDeElementos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MaxMult';
			basicSelector: #maxMult;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MaxMult';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: '0 1 2 *';
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'MaxMult';
			nlsTranslation: 'MaximoDeElementos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'OrderConstraint';
			basicSelector: #orderConstraint;
			type: #String;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'OrderConstraint';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'OrderConstraint';
			nlsTranslation: 'ConstriccionDeOrden';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'EnablementConstraint';
			basicSelector: #enablementConstraint;
			type: #String;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'EnablementConstraint';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'EnablementConstraint';
			nlsTranslation: 'ConstriccionDeDisponibilidad';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ExecutableExpression';
			basicSelector: #executableExpression;
			type: #String;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ExecutableExpression';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'ExecutableExpression';
			nlsTranslation: 'ExpresionEjecutable';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReturnType';
			basicSelector: #returnType;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'ReturnType';
			displaySelector: nil;
			objectClassName: #CODEType;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'ReturnType';
			nlsTranslation: 'TipoDelResultado';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Arguments';
			basicSelector: #arguments;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Arguments';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEArgument;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Arguments';
			nlsTranslation: 'Argumentos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'OperationRefinements';
			basicSelector: #operationRefinements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'OperationRefinements';
			displaySelector: #name;
			componentsClassName: #CODEOperation;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'OperationRefinements';
			nlsTranslation: 'OperacionesRefinadas';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Type';
			basicSelector: #type;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Type';
			displaySelector: #name;
			objectClassName: #CODEType;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Operation_Selectors';
			nlsItem: 'Type';
			nlsTranslation: 'Tipo';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsOperation.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsOperation

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('ReturnType' 'OperationRefinements' 'Type')! !

!CODEOperation publicMethodsFor: 'accessing'!

enablementConstraint
	enablementConstraint isNil
		ifTrue: [self initEnablementConstraint].
	^enablementConstraint!

enablementConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkEnablementConstraint: aValue) ifFalse: [^aValue].
	enablementConstraint := aValue.
	self markDirty.

	self invalidateEffectiveOperationsCaches.


	self changed: #enablementConstraint!

executableExpression
	executableExpression isNil
		ifTrue: [self initExecutableExpression].
	^executableExpression!

executableExpression: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkExecutableExpression: aValue) ifFalse: [^aValue].
	executableExpression := aValue.
	self markDirty.

	self invalidateEffectiveOperationsCaches.


	self changed: #executableExpression!

isAbstract
	"Generated by ISF/AD. Do not modify"
	isAbstract isNil
		ifTrue: [self initIsAbstract].
	^isAbstract!

isAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsAbstract: aValue  == true) ifFalse: [^aValue].
	isAbstract := aValue == true.
	self markDirty.


	self invalidateEffectiveOperationsCaches.


	self changed: #isAbstract!

isExclussion
	"Generated by ISF/AD. Do not modify"
	isExclussion isNil
		ifTrue: [self initIsExclussion].
	^isExclussion!

isExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	isExclussion := aValue.

	self invalidateEffectiveOperationsCaches.

	self markDirty.
	self changed: #isExclussion!

maxMult
	"Generated by ISF/AD. Do not modify"
	maxMult isNil
		ifTrue: [self initMaxMult].
	^maxMult!

maxMult: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMaxMult: aValue) ifFalse: [^aValue].
	maxMult := aValue.
	self markDirty.

	self invalidateEffectiveOperationsCaches.


	self changed: #maxMult!

minMult
	"Generated by ISF/AD. Do not modify"
	minMult isNil
		ifTrue: [self initMinMult].
	^minMult!

minMult: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMinMult: aValue) ifFalse: [^aValue].
	minMult := aValue.
	self markDirty.

	self invalidateEffectiveOperationsCaches.


	self changed: #minMult!

name: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkName: aValue) ifFalse: [^aValue].
	name := aValue.
	self markDirty.

	self invalidateEffectiveOperationsCaches.

	self changed: #name!

orderConstraint
	orderConstraint isNil
		ifTrue: [self initOrderConstraint].
	^orderConstraint!

orderConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOrderConstraint: aValue) ifFalse: [^aValue].
	orderConstraint := aValue.
	self markDirty.


	self invalidateEffectiveOperationsCaches.


	self changed: #orderConstraint! !

!CODEOperation publicMethodsFor: 'accessing-private'!

forzeEnablementConstraint: aValue
	enablementConstraint := aValue!

forzeExecutableExpression: aValue
	executableExpression := aValue!

forzeIsAbstract: aValue
	isAbstract := aValue == true.!

forzeIsExclussion: aValue
	isExclussion := aValue == true.!

forzeMaxMult: aValue
	maxMult := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeMinMult: aValue
	minMult := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeOrderConstraint: aValue
	orderConstraint := aValue! !

!CODEOperation publicMethodsFor: 'association initialize-release'!

argumentsRelease
	"Generated by ISF/AD. Do not modify"
	self arguments do: [:each | self argumentsRemove: each]!

initArguments
	"Generated by ISF/AD. Do not modify"
	arguments :=OrderedCollection new.!

initOperationRefinements
	"Generated by ISF/AD. Do not modify"
	operationRefinements := OrderedCollection new.!

operationRefinementsRelease
	"Generated by ISF/AD. Do not modify"
	self operationRefinements do: [:each | self operationRefinementsRemove: each]!

returnTypeRelease
	"Generated by ISF/AD. Do not modify"
	returnType == nil
		ifFalse:
			[returnType typeOfReturnsPrivateRemove: self.
				returnType := nil.
				self changed: #returnType]!

typeRelease
	"Generated by ISF/AD. Do not modify"
	type == nil
		ifFalse:
			[type operationsPrivateRemove: self.
				type := nil.
				self changed: #type]! !

!CODEOperation publicMethodsFor: 'associations accessing'!

arguments
	"Generated by ISF/AD. Do not modify"
	^self argumentsPrivate copy!

argumentsAsArray
	"Generated by ISF/AD. Do not modify"
	^self arguments asArray!

operationRefinements
	"Generated by ISF/AD. Do not modify"
	^self operationRefinementsPrivate copy!

operationRefinementsAsArray
	"Generated by ISF/AD. Do not modify"
	^self operationRefinements asArray!

returnType
	"Generated by ISF/AD. Do not modify"
	^returnType!

returnType: aValue
	"Generated by ISF/AD. Do not modify"

	(self checkReturnType: aValue) ifFalse: [^aValue].
	returnType == aValue ifTrue: [ ^self].
	self returnTypeRelease.
	returnType := aValue.
	aValue == nil ifFalse: [aValue typeOfReturnsPrivateAdd: self].
	self markDirty.
	self changed: #returnType!

type
	"Generated by ISF/AD. Do not modify"
	^type!

type: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkType: aValue) ifFalse: [^aValue].
	type == aValue ifTrue: [ ^self].
	self typeRelease.
	type := aValue.
	aValue == nil ifFalse: [aValue operationsPrivateAdd: self].
	self changed: #type! !

!CODEOperation publicMethodsFor: 'associations modifying'!

argumentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkArgumentsAdd: aValue) ifFalse: [^aValue].
	(self argumentsIncludes: aValue) ifTrue: [^self argumentsMoveBottom: aValue].
	(self argumentsPrivateAdd: aValue) typePrivate: self.
	self invalidateEffectiveOperationsCaches.

	self notifyChangeAllArgumentsChildSpecs.
	^aValue!

argumentsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self argumentsIncludes: aValue) ifFalse: [^aValue].
	(self arguments indexOf: aValue) = self argumentsSize ifTrue: [^aValue].
	self argumentsPrivate remove: aValue.
	aRes := self argumentsPrivateAdd: aValue.
	self invalidateEffectiveOperationsCaches.
	self notifyChangeAllArgumentsChildSpecs.
	^aRes!

argumentsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aResult |
	(self argumentsIncludes: aValue) ifFalse: [^aValue].
	(index := self arguments indexOf: aValue) = self argumentsSize ifTrue: [^aValue].
	index = (self argumentsSize -1)
		ifTrue:
			[self argumentsPrivate remove: aValue.
			^self argumentsPrivateAdd: aValue].
	aResult := self argumentsPrivateMove: aValue beforeIndex: index + 2.
	self invalidateEffectiveOperationsCaches.
	self notifyChangeAllArgumentsChildSpecs.
	^aResult!

argumentsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self argumentsIncludes: aValue) ifFalse: [^aValue].
	(self arguments indexOf: aValue) = 1 ifTrue: [^aValue].
	self argumentsPrivateMove: aValue beforeIndex: 1
	self invalidateEffectiveOperationsCaches.
	self notifyChangeAllArgumentsChildSpecs.!

argumentsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self argumentsIncludes: aValue) ifFalse: [^aValue].
	(index := self arguments indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self argumentsPrivateMove: aValue beforeIndex: index - 1.
	self invalidateEffectiveOperationsCaches.
	self notifyChangeAllArgumentsChildSpecs.
	^aRes!

argumentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkArgumentsRemove: aValue) ifFalse: [^aValue].
	(self argumentsPrivate remove: aValue ifAbsent: [^aValue]) typePrivate: nil.
	self invalidateEffectiveOperationsCaches.
	self notifyChangeAllArgumentsChildSpecs.

	^aValue!

operationRefinementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOperationRefinementsAdd: aValue) ifFalse: [^aValue].
	(self operationRefinementsIncludes: aValue) ifTrue: [^aValue].
	(self operationRefinementsPrivateAdd: aValue) refinedOperationsPrivateAdd: self.
	self changed: #operationRefinements.
	^aValue!

operationRefinementsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self operationRefinementsIncludes: aValue) ifFalse: [^aValue].
	(self operationRefinements indexOf: aValue) = self operationRefinementsSize ifTrue: [^aValue].
	self operationRefinementsPrivate remove: aValue.
	aRes := self operationRefinementsPrivateAdd: aValue.
	^aRes!

operationRefinementsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self operationRefinementsIncludes: aValue) ifFalse: [^aValue].
	(index := self operationRefinements indexOf: aValue) = self operationRefinementsSize ifTrue: [^aValue].
	index = (self operationRefinementsSize -1)
		ifTrue:
			[self operationRefinementsPrivate remove: aValue.
			aRes := self operationRefinementsPrivateAdd: aValue.
			self notifyChangeAllOperationRefinementsChildSpecs.
			^aRes].
	aRes := self operationRefinementsPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

operationRefinementsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self operationRefinementsIncludes: aValue) ifFalse: [^aValue].
	(self operationRefinements indexOf: aValue) = 1 ifTrue: [^aValue].
	self operationRefinementsPrivateMove: aValue beforeIndex: 1.!

operationRefinementsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self operationRefinementsIncludes: aValue) ifFalse: [^aValue].
	(index := self operationRefinements indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self operationRefinementsPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

operationRefinementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOperationRefinementsRemove: aValue) ifFalse: [^aValue].
	(self operationRefinementsPrivate remove: aValue ifAbsent: [^aValue]) refinedOperationsPrivateRemove: self.
	self changed: #operationRefinements.
	^aValue! !

!CODEOperation publicMethodsFor: 'associations private'!

argumentsPrivate
	"Generated by ISF/AD. Do not modify"
	arguments isNil
		ifTrue: [self initArguments].
	^arguments!

argumentsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self argumentsPrivate add: aValue.
	self changed: #arguments.
	^aValue!

argumentsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self arguments at: anIndex.
	self argumentsPrivate remove: aValue.
	self argumentsPrivate add: aValue before: obj.
	self changed: #arguments.
	^aValue!

argumentsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self argumentsPrivate remove: aValue.
	self changed: #arguments.
	^aValue!

forzeReturnType: aValue
	returnType := aValue.!

forzeType: aValue
	type := aValue.!

operationRefinementsPrivate
	"Generated by ISF/AD. Do not modify"
	operationRefinements isNil
		ifTrue: [self initOperationRefinements].
	^operationRefinements!

operationRefinementsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self operationRefinementsPrivate add: aValue.
	self changed: #operationRefinements.
	^aValue!

operationRefinementsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self operationRefinements at: anIndex.
	self operationRefinementsPrivate remove: aValue.
	self operationRefinementsPrivate add: aValue before: obj.
	self changed: #operationRefinements.
	^aValue!

operationRefinementsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self operationRefinementsPrivate remove: aValue.
	self changed: #operationRefinements.
	^aValue!

returnTypePrivate: aValue
	"Generated by ISF/AD. Do not modify"
	returnType := aValue.
	self markDirty.
	self changed: #returnType!

typePrivate: aValue
	| aPrevValue |
	(type isNil and: [ aValue isNil]) ifTrue: [ ^self].
	aPrevValue := type.
	type := aValue.
	self changed: #type.
	(type isNil and: [ aPrevValue isNil not]) ifTrue: [ self release].! !

!CODEOperation publicMethodsFor: 'associations testing'!

argumentsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^arguments isNil
		ifTrue: [false]
		ifFalse: [self arguments includes: aValue]!

argumentsSize
	"Generated by ISF/AD. Do not modify"
	^arguments isNil
		ifTrue: [0]
		 ifFalse: [arguments size]!

operationRefinementsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^operationRefinements isNil
		ifTrue: [false]
		ifFalse: [self operationRefinements includes: aValue]!

operationRefinementsSize
	"Generated by ISF/AD. Do not modify"
	^operationRefinements isNil
		ifTrue: [0]
		 ifFalse: [operationRefinements size]! !

!CODEOperation publicMethodsFor: 'cache features'!

invalidateEffectiveOperationsCaches
	
	| aType |

	aType := self type.
	aType isNil ifTrue:  [ ^self].

	aType invalidateEffectiveOperationsCaches! !

!CODEOperation publicMethodsFor: 'derived accessing'!

allArguments

	| someArguments someSortedArguments |
	
	someArguments := IdentitySet new: 37.
	someArguments addAll: self arguments.
	self superTypes do: [:aType | 
		aType allArgumentsInto: someArguments	
	].
		
	someSortedArguments := someArguments asSortedCollection: [:anAttr :otherAttr |
		anAttr name < otherAttr name].

	^someSortedArguments!

allArgumentsInto: theSet

	| aSuperType |
	theSet isNil ifTrue: [ ^nil].
	
	self arguments do: [:anArgument | 
		(theSet includes: anArgument) ifFalse: [  theSet add: anArgument]
	].

	self superTypesSize < 1 ifTrue: [ ^theSet].

	aSuperType := self superTypes first.
	aSuperType allArgumentsInto: theSet.
	
	self superTypesSize < 2 ifTrue: [ ^theSet].

	(self superTypes copyFrom: 2 to: self superTypesSize) do: [:aType | 
		aType allArgumentsInto: theSet	
	].
		
	^theSet!

allRefinedOperationsInto: theSet

	(theSet includes: self) ifTrue: [ ^self].

	theSet add: self.!

applicationConfiguration
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type applicationConfiguration]!

fullyQualifiedName

	| aFullyQualifiedName aTypeFullyQualifiedName |
	self type isNil ifTrue: [ ^self name].
	
	aTypeFullyQualifiedName := self type fullyQualifiedName.
	(aTypeFullyQualifiedName isNil or: [ aTypeFullyQualifiedName isEmpty]) ifTrue: [ 
		^self name
	].

	aFullyQualifiedName := aTypeFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

hasOrTypeHasAspectNamed: theAspectName

	| aReturnType |
	(theAspectName isNil or: [ theAspectName]) isEmpty ifTrue: [ ^false].

	(self aspectNamed: theAspectName) isNil ifFalse: [ ^true].
	
	aReturnType := self returnType.
	aReturnType isNil ifTrue: [ ^false].

	(aReturnType aspectNamed: theAspectName) isNil ifFalse: [ ^true].

	^false!

isVisibleInModules: 		theModules
	andAspects: 			theAspects
	definitionsHolder: 	theDefinitionsHolder

	((theModules isNil or: [ theModules isEmpty]) and: [  
		theAspects isNil or: [ theAspects isEmpty]]) ifTrue: [ 
		^true
	].

	^(  self isVisibleInModules: 	theModules definitionsHolder: 	theDefinitionsHolder) and: [ 
		self isVisibleInAspects: 	theAspects definitionsHolder: 	theDefinitionsHolder
	]!

isVisibleInModules: 		theModules
	definitionsHolder: 	theDefinitionsHolder


	| aThisModule |

	(theModules isNil or: [ theModules isEmpty]) ifTrue: [ ^true ].

	(theModules isNil not and: [ theModules isEmpty not]) ifTrue: [ 
		aThisModule := self module.
		aThisModule isNil ifTrue: [ ^false].
		(theModules includes: aThisModule) ifFalse: [ 
			(theModules detect: [:aModule | aModule includesModule: aModule] ifNone: [ nil]) isNil ifTrue: [ ^false]
		]
	].!

model
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type model]!

module
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type module]!

referencedType
	^self returnType!

withAllRefinedOperations
	| someOperations |
	someOperations := IdentitySet new: 13.
	self withAllRefinedOperationsInto: someOperations.
	
	^someOperations!

withAllRefinedOperationsInto: theOperations

	theOperations isNil ifTrue: [ ^self].
	(theOperations includes: self) ifTrue: [ ^self]. 
	theOperations add: self.! !

!CODEOperation publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self type isNil ifFalse: [ self type markDirtyOwner]
	].!

persistIfDirty
	^self type isNil ifFalse: [ self type persistIfDirty] ifTrue: [ nil]! !

!CODEOperation publicMethodsFor: 'initialize-release'!

initEnablementConstraint
	enablementConstraint := ''!

initExecutableExpression
	executableExpression := ''!

initIsAbstract
	isAbstract := false!

initIsExclussion
	isExclussion := false!

initMaxMult
	maxMult := self class maxMultNone!

initMinMult
	"Generated by ISF/AD. Do not modify"
	minMult := self class minMultOptional!

initOrderConstraint
	orderConstraint := ''!

initTerminalMetaOperationsFrom: theOperation
	theOperation isNil ifTrue: [ ^self].
	(theOperation isKindOf: CODEOperation) ifFalse: [ ^self].

	self minMult: 						theOperation minMult copy.
	self maxMult: 					theOperation maxMult copy.
	self isAbstract: 					theOperation isAbstract == true.
	self isExclussion: 				theOperation isExclussion == true.
	self orderConstraint: 			theOperation orderConstraint copy.
	self enablementConstraint: 	theOperation enablementConstraint copy.!

release
	self changed: #objectDisconnectedOfTree.

	self returnTypeRelease.

	self argumentsRelease.

	self typeRelease.

	self operationRefinements do: [:aOperationRefinement | aOperationRefinement release].

	self operationRefinementsRelease.

	super release! !

!CODEOperation publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aSep aType |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aType := self type.

	aType isNil  ifFalse: [  aType allQualifiedNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

argumentsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS |

	anIS := theIS , self indentStringForPersistenceAsCode.

	(self argumentsPrivate isNil not and: [ self argumentsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class argumentsPersistenceSymbol); cr
			].
			self argumentsPrivate do:  [:anArg |
				anArg persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

asReferenceArray

	| aType aTypeReferenceArray |

	aType := self type.
	aTypeReferenceArray := aType isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aType asReferenceArray].

	^Array with: self class refToOperationKindSymbol with: self name with: aTypeReferenceArray!

asReferenceAsCodeStringNOCROn: theStream

	| aSep aType |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	aType := self type.

	theStream nextPutAll: ' ( ';  nextPutAll: (self pcForV: self class refToOperationKindSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	aType isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [  aType asReferenceAsCodeStringNOCROn: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAsCodeStringNOCROn: theStream. 
	theStream cr.!

firstPersistenceIndexOperation
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initArgumentsFromValues: theValues 
	
	| someArguments |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someArguments := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someArguments isNil ifFalse: [ 
		self argumentsPrivate addAll: someArguments.
		someArguments do: [:anArg | anArg operationPrivate: self]]!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexOperation.

	self forzeMinMult:						(theValues size < aFPI  ifTrue: [nil] ifFalse: [ theValues at: aFPI ]). 
	self forzeMaxMult:						(theValues size < (aFPI + 1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 1)]). 
	self forzeIsAbstract:					(theValues size < (aFPI + 2) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 2)]). 
	self forzeIsExclussion:					(theValues size < (aFPI + 3) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 3)]). 
	self forzeOrderConstraint:				(theValues size < (aFPI + 4) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 4)]). 
	self forzeEnablementConstraint:		(theValues size < (aFPI + 5) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 5)]). 
	self forzeExecutableExpression:		(theValues size < (aFPI + 6) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 6)]). 

	theValues size < (aFPI + 7) ifFalse: [  self initReferencedReturnTypeFromValues:  (theValues at: (aFPI + 7))  ].
	theValues size < (aFPI + 8) ifFalse: [ self initArgumentsFromValues: (theValues at: (aFPI + 8))].!

initReferencedReturnTypeFromValues: theValues
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refToReturnTypeKindSymbol ifFalse: [ ^nil].

	returnTypeRefTmpValues := theValues.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep aReturnType |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS; nextPutAll: (self pcForV:  self minMult );  nextPutAll: aSep;
		nextPutAll: (self pcForV:  self maxMult ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self isAbstract ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isExclussion ); nextPutAll: aSep;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self orderConstraint ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self enablementConstraint ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self executableExpression ); cr.

	aReturnType := self returnType.
	aReturnType isNil  
		ifTrue: [ theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil)] 
		ifFalse: [  aReturnType asReferenceAsCodeStringOn:  theStream indent: anIS]. 
	theStream cr.

	self argumentsPersistenceAsCodeStringOn: theStream indent: theIS.!

numberPersistenceEntriesOperation
	^9!

ph2InitFromSolver: theSolver
	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedReturnTypeFromSolver: theSolver!

ph2InitReferencedReturnTypeFromSolver: theSolver
	
	| aType |

	(returnTypeRefTmpValues isNil or: [ returnTypeRefTmpValues isEmpty]) ifTrue: [ ^nil].

	returnTypeRefTmpValues first = self class refToValueTypeKindSymbol ifFalse: [ ^nil].
	
	aType := CODEElement resolveOrNewReferencedTypeFromPersistenceAsCode:  returnTypeRefTmpValues  solver: theSolver.
	aType isNil ifFalse: [ 
		self forzeReturnType: aType.
		aType typeOfReturnsPrivate add: self].

	returnTypeRefTmpValues := nil!

resolveOrNewReferencedArgumentNamed: theName

	| anArgument |

	theName isNil ifTrue: [ ^nil].

	anArgument := self resolveReferencedArgumentNamed: theName.
	anArgument isNil ifFalse: [ ^anArgument].

	anArgument := self preferredArgumentClass new name: theName.
	self argumentsAdd: anArgument.
	^anArgument!

resolveReferencedArgumentNamed: theName
	| anArgument |

	theName isNil ifTrue: [ ^nil].

	anArgument := self argumentNamed: theName.
	^anArgument! !

!CODEOperation publicMethodsFor: 'semantic checking'!

checkArgumentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkArgumentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkEnablementConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkExecutableExpression: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkInitializationExpression: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMaxMult: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMinMult: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOperationRefinementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOperationRefinementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOrderConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkReturnType: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkType: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEOperation publicMethodsFor: 'semantic links'!

argumentsCandidates
	"Generated by ISF/AD. Do not modify"
	^self arguments asArray!

argumentsCreate
	^CODEArgument new name: 'newArgument'!

argumentsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self argumentsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self argumentsAdd: anObject.!

argumentsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self argumentsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self argumentsCreate class
		ifUnchanged: [^self].
	self argumentsAdd: anObject!

argumentsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

maxMultCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self maxMult!

maxMultCreate
	"Generated by ISF/AD. Do not modify"
	^''!

maxMultLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self maxMult: self maxMultCreate.!

maxMultLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self maxMultCandidates
		initially: self maxMult
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self maxMult: anObject.!

maxMultLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self maxMultCandidates
		initially: self maxMult
		label: 'Select Or Create ...'
		class: self maxMultCreate class
		ifUnchanged: [^self].
	self maxMult: anObject!

maxMultScope
	"Generated by ISF/AD. Do not modify"
	^nil!

minMultCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self minMult!

minMultCreate
	"Generated by ISF/AD. Do not modify"
	^''!

minMultLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self minMult: self minMultCreate.!

minMultLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self minMultCandidates
		initially: self minMult
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self minMult: anObject.!

minMultLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self minMultCandidates
		initially: self minMult
		label: 'Select Or Create ...'
		class: self minMultCreate class
		ifUnchanged: [^self].
	self minMult: anObject!

minMultScope
	"Generated by ISF/AD. Do not modify"
	^nil!

operationRefinementsCandidates
	"Generated by ISF/AD. Do not modify"
	^self operationRefinements asArray!

operationRefinementsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEOperation new!

operationRefinementsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self operationRefinementsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self operationRefinementsAdd: anObject.!

operationRefinementsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self operationRefinementsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self operationRefinementsCreate class
		ifUnchanged: [^self].
	self operationRefinementsAdd: anObject!

operationRefinementsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

returnTypeCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

returnTypeLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self returnTypeCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self returnType: anObject]!

returnTypeLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self returnTypeCandidates
		initially: self returnType
		label: 'Select Or Create ...'
		class: self returnTypeCreate class
		ifUnchanged: [^self].
	self returnType: anObject!

returnTypeNameCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self returnTypeName!

returnTypeNameCreate
	"Generated by ISF/AD. Do not modify"
	^''!

returnTypeNameLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self returnTypeName: self returnTypeNameCreate.!

returnTypeNameLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self returnTypeNameCandidates
		initially: self returnTypeName
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self returnTypeName: anObject.!

returnTypeNameLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self returnTypeNameCandidates
		initially: self returnTypeName
		label: 'Select Or Create ...'
		class: self returnTypeNameCreate class
		ifUnchanged: [^self].
	self returnTypeName: anObject!

returnTypeNameScope
	"Generated by ISF/AD. Do not modify"
	^nil!

returnTypeScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typeCandidates
	"Generated by ISF/AD. Do not modify"
	^self type isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self type]!

typeCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

typeLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typeCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self type: anObject]!

typeLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typeCandidates
		initially: self type
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self type: anObject.!

typeLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typeCandidates
		initially: self type
		label: 'Select Or Create ...'
		class: self typeCreate class
		ifUnchanged: [^self].
	self type: anObject!

typeScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEOperation publicMethodsFor: 'semantic links-custom'!

argumentBaseLinkCreate


	| anArgumentName aNewArgument |
	anArgumentName := Dialog request: 'Please, enter name for new Argument' initialAnswer: ''.
	(anArgumentName isNil or: [ anArgumentName isEmpty]) ifTrue: [ ^self].

	aNewArgument := self preferredArgumentClass new name: anArgumentName.
	aNewArgument operation: self.
	aNewArgument minMult: self class minMultOptional.
	aNewArgument maxMult: self class maxMultNone.

	self argumentsAdd: aNewArgument.

	^aNewArgument!

argumentRefinementLinkCreate

	| someTypes aSelectedType   someOwnArguments someArgumentsToAvoid someCandidateArguments aSelectedArgument aNewArgument aModel aNLSItem aNLSSolver aNewNLSItem aSelectedArgumentValueType |

	someOwnArguments := self argumentsPrivate.
	someArgumentsToAvoid := IdentitySet new: (someOwnArguments size * 1.5) floor.
	someArgumentsToAvoid addAll: someOwnArguments.

	someOwnArguments do: [:anExistingArg | 
		anExistingArg isRefinement ifTrue: [ 
			someArgumentsToAvoid addAll: anExistingArg refinedArguments
		]
	].

	someCandidateArguments := self allArguments reject: [:anExistingArg | someArgumentsToAvoid includes: anExistingArg].

	(someCandidateArguments isNil or: [ someCandidateArguments isEmpty]) ifTrue: [ 
		Dialog warn: 'No candidate Arguments to Refine in Model'.
		^nil
	].


	someCandidateArguments := someCandidateArguments asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedArgument := Dialog 
		choose: ('Please, select a Argument to refine') withCRs
		fromList: (someCandidateArguments collect: [:aArgument | 
			Object errorSignal
				handle: [:anException | anException returnWith: aArgument name]
				do: [ aArgument nlsName , ' 	(', aArgument name, ')' ]]) 
		values: someCandidateArguments 
		lines: (((someCandidateArguments size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedArgument isNil ifTrue: [ ^nil].
	
	aSelectedArgumentValueType := aSelectedArgument valueType.
	aSelectedArgumentValueType isNil ifTrue: [ 
		Dialog warn: 'Selected Argument has no valueType (ERROR)'.
		^nil
	].

	
	someTypes := aSelectedArgumentValueType withAllSubtypes.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types to refine Argument (ERROR) \' withCRs, 
			aSelectedArgument nlsName.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedType := Dialog 
		choose: ('  Please, select a Type to as ValueType of the new Refined Argument  \', 
		'\as refinement of argument  \' , aSelectedArgument nlsName) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName , ' 	(', aType name, ')' ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	aNewArgument := self preferredArgumentRefinementClass new name: aSelectedArgument name copy.
	aNewArgument type: self.
	aNewArgument valueType: aSelectedType.
	aNewArgument initTerminalMetaArgumentsFrom: aSelectedArgument.
	
	aNewArgument refinedArgumentsAdd: aSelectedArgument.



	aModel := self model.
	aModel isNil ifFalse: [ 
		aNLSSolver := aModel nlsSolver.
		aNLSSolver isNil ifFalse: [ 
			aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedArgument nlsAppName 
				group: aSelectedArgument nameNLSGroupName item: aSelectedArgument nameNLSItemName.
			aNLSItem isNil ifFalse: [
				aNewNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: aNewArgument nlsAppName 
					group: aNewArgument nameNLSGroupName item: aNewArgument nameNLSItemName.
				aNewNLSItem isNil ifTrue: [ 
					aNewNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: aNewArgument nlsAppName group: aNewArgument nameNLSGroupName
						item: aNewArgument nameNLSItemName translation: aNewArgument nameNLSItemName.
				].
				(aNewNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
					aNewNLSItem usedItemTranslationsAdd: aNLSItem.
					aNewNLSItem changed: #itemTranslations
				]
			]
		]
	].
	aNewArgument changed: #name.

	^aNewArgument!

argumentsLinkCreate

	| aArgumentKind |

	aArgumentKind := Dialog
		choose: 'Please choose between a new Argument,\or REFINEMENT of existing Argument\or Cancel' withCRs
		labels: (Array with: 'new Argument' with: 'REFINEMENT' with: 'Cancel')
		values: #(#newArgument #REFINEMENT #cancel)
		default: #newArgument.

	aArgumentKind =  #newArgument  ifTrue: [ ^self argumentBaseLinkCreate].
	aArgumentKind =  #REFINEMENT  ifTrue: [ ^self argumentRefinementLinkCreate].
	^self!

operationRefinementsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self operationRefinementsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self operationRefinementsAdd: anObject]!

returnTypeCandidates
	self type isNil ifTrue: [ ^nil].
	^self type model allTypes!

returnTypeLinkSelect

	| someTypes aSelectedType anInitialSelection |

	someTypes := self returnTypeCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as ReturnType of Operation\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	anInitialSelection := self returnType.
	aSelectedType := Dialog 
		choose: ('	Please, select a Type as ReturnType of Operation	\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ')']]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil]
		initialSelection: anInitialSelection.
	aSelectedType isNil ifTrue: [ ^nil].

	self returnType: aSelectedType.

	^aSelectedType! !

!CODEOperation publicMethodsFor: 'testing'!

isMultiplicityMany
	^self maxMult = self class maxMultMany or: [ self maxMult = self class maxMultTwo]!

isMultiplicityNone
	^self maxMult = self class maxMultNone!

isMultiplicityOne
	^self maxMult = self class maxMultOne!

isOperation
	^true!

isOrdered
	^self isSorted not!

isSorted
	^self orderConstraint isNil not and:  [  self orderConstraint isEmpty not and: [ self orderConstraint asArrayOfSubstrings isEmpty not]]! !

!CODEOperationRefinement class publicMethodsFor: 'accessing'!

kind
	^#operationRefinement! !

!CODEOperationRefinement class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		 self modelEditorMETAPerspectivesOperationRefinement, super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesOperationRefinement
 
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RefinedOperations'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'RefinedOperations' )))
			nlsApp: 'CODE';
			nlsGroup: 'OperationRefinement_Perspectives';
			nlsItem: 'RefinedOperations';
			nlsTranslation: 'OperacionesOriginales';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsOperationRefinement!

modelEditorMETASelectorsOperationRefinement

	"METAChildSpecAutoViewEditor openOn: CODEOperation selector: #modelEditorMETASelectorsOperationRefinement target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 8)
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RefinedOperations';
			basicSelector: #refinedOperations;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'RefinedOperations';
			displaySelector: #name;
			componentsClassName: #CODEOperation;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'OperationRefinement_Selectors';
			nlsItem: 'RefinedOperations';
			nlsTranslation: 'OperacionesOriginales';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsOperationRefinement.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: super modelEditorPathSelectors metaSelectorsToSelect, aLocalView metaSelectorsToSelect!

modelEditorPathSelectorsOperationRefinement

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('RefinedOperations' )! !

!CODEOperationRefinement publicMethodsFor: 'association initialize-release'!

initRefinedOperations
	"Generated by ISF/AD. Do not modify"
	refinedOperations := OrderedCollection new.!

refinedOperationsRelease
	"Generated by ISF/AD. Do not modify"
	self refinedOperations do: [:each | self refinedOperationsRemove: each]! !

!CODEOperationRefinement publicMethodsFor: 'associations accessing'!

refinedOperations
	"Generated by ISF/AD. Do not modify"
	^self refinedOperationsPrivate copy!

refinedOperationsAsArray
	"Generated by ISF/AD. Do not modify"
	^self refinedOperations asArray! !

!CODEOperationRefinement publicMethodsFor: 'associations modifying'!

refinedOperationsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRefinedOperationsAdd: aValue) ifFalse: [^aValue].
	(self refinedOperationsIncludes: aValue) ifTrue: [^aValue].
	(self refinedOperationsPrivateAdd: aValue) operationRefinementsPrivateAdd: self.
	self changed: #refinedOperations.

	^aValue!

refinedOperationsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self refinedOperationsIncludes: aValue) ifFalse: [^aValue].
	(self refinedOperations indexOf: aValue) = self refinedOperationsSize ifTrue: [^aValue].
	self refinedOperationsPrivate remove: aValue.
	aRes := self refinedOperationsPrivateAdd: aValue.
	^aRes!

refinedOperationsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self refinedOperationsIncludes: aValue) ifFalse: [^aValue].
	(index := self refinedOperations indexOf: aValue) = self refinedOperationsSize ifTrue: [^aValue].
	index = (self refinedOperationsSize -1)
		ifTrue:
			[self refinedOperationsPrivate remove: aValue.
			aRes := self refinedOperationsPrivateAdd: aValue.
			self notifyChangeAllRefinedOperationsChildSpecs.
			^aRes].
	aRes := self refinedOperationsPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

refinedOperationsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self refinedOperationsIncludes: aValue) ifFalse: [^aValue].
	(self refinedOperations indexOf: aValue) = 1 ifTrue: [^aValue].
	self refinedOperationsPrivateMove: aValue beforeIndex: 1.!

refinedOperationsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self refinedOperationsIncludes: aValue) ifFalse: [^aValue].
	(index := self refinedOperations indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self refinedOperationsPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

refinedOperationsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRefinedOperationsRemove: aValue) ifFalse: [^aValue].
	(self refinedOperationsPrivate remove: aValue ifAbsent: [^aValue]) operationRefinementsPrivateRemove: self.
	self changed: #refinedOperations.

	^aValue! !

!CODEOperationRefinement publicMethodsFor: 'associations private'!

refinedOperationsPrivate
	"Generated by ISF/AD. Do not modify"
	refinedOperations isNil
		ifTrue: [self initRefinedOperations].
	^refinedOperations!

refinedOperationsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self refinedOperationsPrivate add: aValue.
	self changed: #refinedOperations.
	^aValue!

refinedOperationsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self refinedOperations at: anIndex.
	self refinedOperationsPrivate remove: aValue.
	self refinedOperationsPrivate add: aValue before: obj.
	self changed: #refinedOperations.
	^aValue!

refinedOperationsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self refinedOperationsPrivate remove: aValue.
	self changed: #refinedOperations.
	^aValue! !

!CODEOperationRefinement publicMethodsFor: 'associations testing'!

refinedOperationsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^refinedOperations isNil
		ifTrue: [false]
		ifFalse: [self refinedOperations includes: aValue]!

refinedOperationsSize
	"Generated by ISF/AD. Do not modify"
	^refinedOperations isNil
		ifTrue: [0]
		 ifFalse: [refinedOperations size]! !

!CODEOperationRefinement publicMethodsFor: 'derived accessing'!

allRefinedOperations

	| someOperations |
	someOperations := IdentitySet new: 13.
	self allRefinedOperationsInto: someOperations.
	^someOperations!

allRefinedOperationsInto: theSet

	(theSet includes: self) ifTrue: [ ^self].

	theSet add: self.

	self refinedOperations do: [:anOperation |  anOperation allRefinedOperationsInto: theSet]!

withAllRefinedOperationsInto: theOperations

	theOperations isNil ifTrue: [ ^self].
	(theOperations includes: self) ifTrue: [ ^self]. 
	theOperations add: self.
	self refinedOperationsPrivate do: [:aOperation |
		aOperation withAlllRefinedOperationsInto: theOperations
	].! !

!CODEOperationRefinement publicMethodsFor: 'initialize-release'!

release
	self changed: #objectDisconnectedOfTree.	

	self refinedOperationsRelease.

	super release.! !

!CODEOperationRefinement publicMethodsFor: 'persistence-code'!

firstPersistenceIndexOperationRefinement
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		self numberPersistenceEntriesOperation  +
		1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexOperationRefinement.

	theValues size < aFPI ifFalse: [  self initReferencedRefinedOperationsFromValues:  (theValues at: aFPI) ].!

initReferencedRefinedOperationsFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refinedOperationsPersistenceSymbol ifFalse: [ ^nil].

	refinedOperationsRefTmpValues := theValues.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	self referencedRefinedOperationAsCodeStringOn: theStream indent: theIS.!

numberPersistenceEntriesOperationRefinement
	^1!

ph2InitFromSolver: theSolver

	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedRefinedOperationsValuesFromSolver: theSolver.!

ph2InitReferencedRefinedOperationsValuesFromSolver: theSolver
	
	| someOperations |

	(refinedOperationsRefTmpValues isNil or: [ refinedOperationsRefTmpValues isEmpty]) ifTrue: [ ^self].

	someOperations := 
		CODEElement resolveOrNewReferencedOperationsCollectionFromPersistenceAsCode: refinedOperationsRefTmpValues  solver: theSolver.
	self refinedOperationsPrivate  addAll: someOperations.
	someOperations do: [:aC | aC operationRefinementsPrivate add: self].

	refinedOperationsRefTmpValues := nil!

referencedRefinedOperationAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	theStream isNil ifTrue: [ ^self]. 


	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self refinedOperationsPrivate isNil not and: [ self refinedOperationsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class refinedOperationsPersistenceSymbol); cr
			].
			self refinedOperationsPrivate do:  [:anOperation |
				anOperation asReferenceAsCodeStringOn: theStream 
					indent: anIS , self indentStringForPersistenceAsCode
			].

			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].! !

!CODEOperationRefinement publicMethodsFor: 'semantic checking'!

checkRefinedOperationsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRefinedOperationsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEOperationRefinement publicMethodsFor: 'semantic links'!

refinedOperationsCandidates
	"Generated by ISF/AD. Do not modify"
	^self refinedOperations asArray!

refinedOperationScope
	"Generated by ISF/AD. Do not modify"
	^nil!

refinedOperationsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEOperation new!

refinedOperationsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self refinedOperationsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self refinedOperationsAdd: anObject.!

refinedOperationsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self refinedOperationsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self refinedOperationsCreate class
		ifUnchanged: [^self].
	self refinedOperationsAdd: anObject!

refinedOperationsScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEOperationRefinement publicMethodsFor: 'semantic links-custom'!

refinedOperationsLinkCreate

	| someTypes aSelectedType |

	someTypes := self refinedOperationCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as RefinedOperation of Type\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a name < b name].

	aSelectedType := Dialog 
		choose: ('			Please, select a Type as RefinedOperation of Type			\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType displayName ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	self refinedOperationsAdd: aSelectedType.

	^aSelectedType! !

!CODEOperationRefinement publicMethodsFor: 'testing'!

isRefinement
	^true! !

!CODEParameter class publicMethodsFor: 'accessing'!

kind
	^#parameter! !

!CODEParameter class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEParameter class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^ self modelEditorMETAPerspectivesParameter, self modelEditorMETAPerspectivesGeneral, 
			super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'IsDirty'  'Value')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesParameter

	^OrderedCollection new
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsParameter!

modelEditorMETASelectorsParameter

	"METAChildSpecAutoViewEditor openOn: CODEParameter selector: #modelEditorMETASelectorsParameter target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Value';
			basicSelector: #value;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Value';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Parameter_Selectors';
			nlsItem: 'Value';
			nlsTranslation: 'Valor';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Element';
			basicSelector: #element;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Element';
			displaySelector: #name;
			objectClassName: #CODEElement;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Parameter_Selectors';
			nlsItem: 'Element';
			nlsTranslation: 'ElementoParametrizado';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsParameter.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsParameter

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #()! !

!CODEParameter publicMethodsFor: 'accessing'!

value
	"Generated by ISF/AD. Do not modify"
	value isNil
		ifTrue: [self initValue].
	^value!

value: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkValue: aValue) ifFalse: [^aValue].
	value := aValue.
	self markDirty.
	self changed: #value! !

!CODEParameter publicMethodsFor: 'accessing-private'!

forzeValue: aValue
	value := aValue.! !

!CODEParameter publicMethodsFor: 'association initialize-release'!

elementRelease
	"Generated by ISF/AD. Do not modify"
	element == nil
		ifFalse:
			[element parametersPrivateRemove: self.
				element := nil.
				self changed: #element]! !

!CODEParameter publicMethodsFor: 'associations accessing'!

element
	"Generated by ISF/AD. Do not modify"
	^element!

element: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkElement: aValue) ifFalse: [^aValue].
	element == aValue ifTrue: [ ^self].
	self elementRelease.
	element := aValue.
	aValue == nil ifFalse: [aValue parametersPrivateAdd: self].
	self changed: #element! !

!CODEParameter publicMethodsFor: 'associations private'!

elementPrivate: aValue
	| aPrevValue |
	aPrevValue := element.
	element := aValue.
	self changed: #element.
	(element isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

forzeElement: aValue
	element := aValue.! !

!CODEParameter publicMethodsFor: 'derived accessing'!

applicationConfiguration
	^self element isNil ifTrue: [ nil] ifFalse: [ self element applicationConfiguration]!

model
	^self element isNil ifTrue: [ nil] ifFalse: [ self element model]! !

!CODEParameter publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self element isNil ifFalse: [ self element markDirtyOwner]
	].!

persistIfDirty
	^self element isNil ifFalse: [ self element persistIfDirty] ifTrue: [ nil]! !

!CODEParameter publicMethodsFor: 'initialize-release'!

initValue
	"Generated by ISF/AD. Do not modify"
	value := ''.!

release
	self changed: #objectDisconnectedOfTree.

	value := nil.

	self elementRelease.

	super release! !

!CODEParameter publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aSep anElement |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	anElement := self element.

	anElement isNil  ifFalse: [  anElement allQualifiedNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

firstPersistenceIndexParameter
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		1!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.
	aFPI := self firstPersistenceIndexParameter.

	self forzeValue:	 (theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]).!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  value ); cr.!

numberPersistenceEntriesParameter
	^1! !

!CODEParameter publicMethodsFor: 'semantic checking'!

checkElement: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkValue: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEParameter publicMethodsFor: 'semantic links'!

elementCandidates
	"Generated by ISF/AD. Do not modify"
	^self element isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self element]!

elementCreate
	"Generated by ISF/AD. Do not modify"
	^CODEElement new!

elementLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self elementCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self element: anObject]!

elementLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self elementCandidates
		initially: self element
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self element: anObject.!

elementLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self elementCandidates
		initially: self element
		label: 'Select Or Create ...'
		class: self elementCreate class
		ifUnchanged: [^self].
	self element: anObject!

elementScope
	"Generated by ISF/AD. Do not modify"
	^nil!

valueCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self value!

valueCreate
	"Generated by ISF/AD. Do not modify"
	^''!

valueLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self value: self valueCreate.!

valueLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self valueCandidates
		initially: self value
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self value: anObject.!

valueLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self valueCandidates
		initially: self value
		label: 'Select Or Create ...'
		class: self valueCreate class
		ifUnchanged: [^self].
	self value: anObject!

valueScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEParametrizedElement class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesParametrizedElement, super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesParametrizedElement

	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Parameters'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Parameters' )))
			nlsApp: 'CODE';
			nlsGroup: 'ParametrizedElement_Perspectives';
			nlsItem: 'Parameters';
			nlsTranslation: 'Parametros';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsParametrizedElement!

modelEditorMETASelectorsParametrizedElement

	"METAChildSpecAutoViewEditor openOn: CODEAttribute selector: #modelEditorMETASelectorsAttribute target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Parameters';
			basicSelector: #parameters;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Parameters';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEParameter;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'ParametrizedElement_Selectors';
			nlsItem: 'Parameters';
			nlsTranslation: 'Parametros';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsParametrizedElement.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsParametrizedElement

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('Parameters' )! !

!CODEParametrizedElement publicMethodsFor: 'association initialize-release'!

initParameters
	"Generated by ISF/AD. Do not modify"
	parameters := OrderedCollection new.!

parametersRelease
	"Generated by ISF/AD. Do not modify"
	self parameters do: [:each | self parametersRemove: each]! !

!CODEParametrizedElement publicMethodsFor: 'associations accessing'!

parameters
	"Generated by ISF/AD. Do not modify"
	^self parametersPrivate copy!

parametersAsArray
	"Generated by ISF/AD. Do not modify"
	^self parameters asArray! !

!CODEParametrizedElement publicMethodsFor: 'associations modifying'!

parametersAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkParametersAdd: aValue) ifFalse: [^aValue].
	(self parametersIncludes: aValue) ifTrue: [^aValue].
	(self parametersPrivateAdd: aValue) elementPrivate: self.
	self changed: #parameters.
	^aValue!

parametersRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkParametersRemove: aValue) ifFalse: [^aValue].
	(self parametersPrivate remove: aValue ifAbsent: [^aValue]) elementPrivate: nil.
	self changed: #parameters.
	^aValue! !

!CODEParametrizedElement publicMethodsFor: 'associations private'!

forzeParameters: theParameters
	(theParameters isNil or: [ theParameters isEmpty]) ifTrue: [ ^self].
	self parametersPrivate addAll: theParameters.
	theParameters do: [:aP | aP forceElement: self].!

parametersPrivate
	"Generated by ISF/AD. Do not modify"
	parameters isNil
		ifTrue: [self initParameters].
	^parameters!

parametersPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self parametersPrivate add: aValue.
	self markDirty.
	self changed: #parameters.
	^aValue!

parametersPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self parametersPrivate remove: aValue.
	self markDirty.
	self changed: #parameters.
	^aValue! !

!CODEParametrizedElement publicMethodsFor: 'associations testing'!

parametersIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^parameters isNil
		ifTrue: [false]
		ifFalse: [self parameters includes: aValue]!

parametersSize
	"Generated by ISF/AD. Do not modify"
	^parameters isNil
		ifTrue: [0]
		 ifFalse: [parameters size]! !

!CODEParametrizedElement publicMethodsFor: 'dirty'!

cleanDirtyMark
	super cleanDirtyMark.

	self comments do: [:aComment | aComment cleanDirtyMark].
	self parameters do: [:aParm | aParm cleanDirtyMark].! !

!CODEParametrizedElement publicMethodsFor: 'initialize-release'!

release
	self changed: #objectDisconnectedOfTree.

	self parametersRelease.

	super release! !

!CODEParametrizedElement publicMethodsFor: 'persistence-code'!

firstPersistenceIndexParametrizedElement
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		1!

hasCommentsOrParametersPersistence
		
	^self hasCommentsPersistence or: [ self hasParametersPersistence]!

hasParametersPersistence

	^(self parametersPrivate isNil not and: [ self parametersPrivate isEmpty not])!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.
	aFPI := self firstPersistenceIndexParametrizedElement.

	theValues size < aFPI ifFalse: [  self initParametersFromValues: (theValues at: aFPI) ].!

initParametersFromValues: theValues 
	
	| someParameters |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someParameters := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someParameters isNil ifFalse: [ 
		self commentsPrivate addAll: someParameters.
		someParameters do: [:aC | aC elementPrivate: self]]!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	self parametersPersistenceAsCodeStringOn: theStream indent: theIS!

numberPersistenceEntriesParametrizedElement
	^1!

parametersPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self parametersPrivate isNil not and: [ self parametersPrivate isEmpty not]) 
		ifFalse: [  
			theStream isNil ifFalse: [  
				self hasCommentsPersistence ifTrue: [ theStream nextPutAll: anIS].
				theStream  nextPutAll: (self pcForV: nil) ; cr
			]
		]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
			    		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class parametersPersistenceSymbol); cr; cr
			].
			self parametersPrivate do:  [:aComment |
				aComment persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr; cr].
		].! !

!CODEParametrizedElement publicMethodsFor: 'semantic checking'!

checkParametersAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkParametersRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEParametrizedElement publicMethodsFor: 'semantic links'!

parametersCandidates
	"Generated by ISF/AD. Do not modify"
	^self parameters asArray!

parametersCreate
	"Generated by ISF/AD. Do not modify"
	^CODEParameter new!

parametersLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self parametersCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self parametersAdd: anObject]!

parametersLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self parametersCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self parametersAdd: anObject.!

parametersLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self parametersCandidates
		initially: nil
		label: 'Select Or Create'
		class: self parametersCreate class
		ifUnchanged: [^self].
	self parametersAdd: anObject!

parametersScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEPort class publicMethodsFor: 'accessing'!

kind
	^#port! !

!CODEPort class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEPort class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		self modelEditorMETAPerspectivesType, super modelEditorMETAPerspectives, 
		self modelEditorMETAPerspectivesTranslation!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'AllContainerNamespaceNames' 'IsDirty' 'IsUse' 'IsAbstract' 'IsEnumeration' 'IsPrimitive' 'IsExclussion' 'IsVirtual'  'IsHomeRooted' 'IsHomeIDProvider' 'PrimitiveInitializationString' 'ReengineredClassName' 'StoreClassName' 'StoreMethodSelector')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesType
 	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Relationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Relationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Attributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Attributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Operations'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Operations' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'SuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllSuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllSuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllNonAbstractSuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllNonAbstractSuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTiposNoAbstractos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'SubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllSubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllSubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllNonAbstractSubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllNonAbstractSubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllNonAbstractSubTypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);

		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAggregatedRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAggregatedRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAggregatedRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAggregatedRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAggregatedRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAttributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAttributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfAttributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfAttributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfAttributes';
			nlsTranslation: 'TipoDeAtributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfArguments'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfArguments' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfArguments';
			nlsTranslation: 'TipoDeArgumentosDeOperacion';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfReturns'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfReturns' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfReturns';
			nlsTranslation: 'TipoDeResultadosDeOperacion';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllRelationships';
			nlsTranslation: 'TodasLasRelaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonRefinedRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonRefinedRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonRefinedRelationships';
			nlsTranslation: 'TodasLasRelacionesNoRefinadas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionados';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllPolymorphicallyRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllPolymorphicallyRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllPolymorphicallyRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionadosPolimorficamente';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllEffectiveFeatures'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllEffectiveFeatures' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllEffectiveFeatures';
			nlsTranslation: 'TodasLasCaracteristicasEfectivas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Module'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Module' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Module';
			nlsTranslation: 'Modulo';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Observers'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Observers' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Observers';
			nlsTranslation: 'Observadores';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Types'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Types' )))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'Types';
			nlsTranslation: 'Tipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RootTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('RootTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'RootTypes';
			nlsTranslation: 'TodosLosTiposSinSuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'AllTypes';
			nlsTranslation: 'TodosLosTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllNonAbstractTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'AllNonAbstractTypes';
			nlsTranslation: 'TodosLosTiposNoAbstractos';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsType,
		self modelEditorMETASelectorsTranslation!

modelEditorMETASelectorsType

	"METAChildSpecAutoViewEditor openOn: CODEPort selector: #modelEditorMETASelectorsType target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsUse';
			basicSelector: #isUse;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsUse';
			displaySelector: nil;
			canShowInTree: false;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsUse';
			nlsTranslation: 'EsUso';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsEnumeration';
			nlsTranslation: 'EsEnumeracion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsPrimitive';
			nlsTranslation: 'EsPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsVirtual';
			basicSelector: #isVirtual;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsVirtual';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsVirtual';
			nlsTranslation: 'EsVirtual';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeRooted';
			basicSelector: #isHomeRooted;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeRooted';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeRooted';
			nlsTranslation: 'EsArraigadoEnOrigen';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeIDProvider';
			basicSelector: #isHomeIDProvider;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeIDProvider';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeIDProvider';
			nlsTranslation: 'OrigenProveeIDs';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrimitiveInitializationString';
			basicSelector: #primitiveInitializationString;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrimitiveInitializationString';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'PrimitiveInitializationString';
			nlsTranslation: 'InicializacionValorPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReengineredClassName';
			basicSelector: #reengineredClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ReengineredClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'ReengineredClassName';
			nlsTranslation: 'NombreDeClasePrograma';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreClassName';
			basicSelector: #storeClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreClassName';
			nlsTranslation: 'ClaseDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreMethodSelector';
			basicSelector: #storeMethodSelector;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreMethodSelector';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreMethodSelector';
			nlsTranslation: 'SelectorDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Operations';
			basicSelector: #operations;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Operations';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSuperTypes';
			basicSelector: #withAllSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSuperTypes';
			basicSelector: #withAllNonAbstractSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'COnTodosLosSuperTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSubTypes';
			basicSelector: #withAllSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSubTypes';
			basicSelector: #withAllNonAbstractSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSubtypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSubtypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregationRelationships';
			basicSelector: #allAggregationRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregationRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregationRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);

		addAll: self modelEditorMETASelectorsType2;
		addAll: self modelEditorMETASelectorsType3;

		yourself!

modelEditorMETASelectorsType2

	"METAChildSpecAutoViewEditor openOn: CODEPort selector: #modelEditorMETASelectorsType2 target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelationships';
			basicSelector: #allNonDummyRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonDummyRelationships';
			nlsTranslation: 'AllNonDummyRelationships';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelationships';
			basicSelector: #allRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllRelationships';
			nlsTranslation: 'TodasLasRelaciones';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonRefinedRelationships';
			basicSelector: #allNonRefinedRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonRefinedRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonRefinedRelationships';
			nlsTranslation: 'TodasLasRelacionesNoRefinadas';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelatedTypes';
			basicSelector: #allNonDummyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelatedTypes';
			basicSelector: #allRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllPolymorphicallyRelatedTypes';
			basicSelector: #allPolymorphicallyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllPolymorphicallyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllPolymorphicallyRelatedTypes';
			nlsTranslation: 'TodosLosTiposPolimorficamenteRelacionados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyAggregationRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Module';
			basicSelector: #module;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Module';
			displaySelector: #name;
			canShowInTree: true;
			objectClassName: #CODEModule;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Module';
			nlsTranslation: 'Modulo';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfAttributes';
			basicSelector: #typeOfValues;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfAttributes';
			nlsTranslation: 'TipoDeAtributos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfArguments';
			basicSelector: #typeOfArguments;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfArguments';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEArgument;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfArguments';
			nlsTranslation: 'TipoDeArgumentosDeOperacion';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfOperationReturns';
			basicSelector: #typeOfReturns;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfOperationReturns';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfOperationReturns';
			nlsTranslation: 'TipoDeResultadosDeOperacion';
			yourself);

		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllEffectiveFeatures';
			basicSelector: #allEffectiveFeatures;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllEffectiveFeatures';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEElement;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllEffectiveFeatures';
			nlsTranslation: 'TodasLasCaracteristicasEfectivas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Observers';
			basicSelector: #observers;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Observers';
			displaySelector: #displayName;
			canShowInTree: true;
			componentsClassName: #CMTypeObserver;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Observers';
			nlsTranslation: 'Observadores';
			yourself);
		yourself!

modelEditorMETASelectorsType3

	"METAChildSpecAutoViewEditor openOn: CODEPort selector: #modelEditorMETASelectorsType3 target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Types';
			basicSelector: #types;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types';
			displaySelector: #name;
			componentsClassName: #CODEPort;
			sortSelector: #nlsName;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Types';
			nlsTranslation: 'Tipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RootTypes';
			basicSelector: #rootTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types without Supertypes';
			displaySelector: #name;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'RootTypes';
			nlsTranslation: 'TiposRaiz';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllTypes';
			basicSelector: #allTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'All the Types in the Module and subModules';
			displaySelector: #name;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllTypes';
			nlsTranslation: 'TodosLosTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractTypes';
			basicSelector: #allNonAbstractTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractTypes';
			displaySelector: #name;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractTypes';
			nlsTranslation: 'TodosLosTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllContainerNamespaceNames';
			basicSelector: #allContainerNamespaceNames;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllContainerNamespaceNames';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllContainerNamespaceNames';
			nlsTranslation: 'Namespace contenedor completamente cualificado';
			yourself);

		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsType.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsType

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('Relationships' 'Attributes' 'Operations' 'SuperTypes' 'SubTypes'  'TypeOfAttributes' 'TypeOfArguments' 'TypeOfReturns' 'AllEffectiveFeatures' 'WithAllSuperTypes'  'WithAllNonAbstractSuperTypes'  'WithAllSubTypes'  'WithAllNonAbstractSubTypes' 
			'AllAggregatedRelatedTypes' 'AllAggregatedRelationships' 'AllAttributes' 'AllRelationships' 'AllNonRefinedRelationships' 'AllRelatedTypes' 
			'AllPolymorphicallyRelatedTypes'  'AllNonAbstractPolymorphicallyRelatedTypes' 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes' 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes' 'Observers'  'Types'  'RootTypes' 'AllTypes' 'AllNonAbstractTypes')!

xmetaSelectors

	"METAChildSpecAutoViewEditor openOn: CODEPort selector: #metaSelectors target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 27)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Name';
			basicSelector: #name;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Name';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelationships';
			basicSelector: #allAggregatedRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelationships';
			basicSelector: #allNonDummyRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelationships';
			basicSelector: #allRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelatedTypes';
			basicSelector: #allNonDummyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODEPort;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelatedTypes';
			basicSelector: #allRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODEPort;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: #superType;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelationshipsToGenerate';
			basicSelector: #relationshipsToGenerate;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelationshipsToGenerate';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: #superType;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AttributesToGenerate';
			basicSelector: #attributesToGenerate;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AttributesToGenerate';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			componentsClassName: #CODEPort;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelatedWith';
			basicSelector: #relatedWith;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelatedWith';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Module';
			basicSelector: #module;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Module';
			displaySelector: #name;
			objectClassName: #CODEModule;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Model';
			basicSelector: #model;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Model';
			displaySelector: #name;
			objectClassName: #CODEModel;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'BaseOutFileName';
			basicSelector: #baseOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'BaseOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ImplOutFileName';
			basicSelector: #implOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ImplOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IfcOutFileName';
			basicSelector: #ifcOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IfcOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TrxOutFileName';
			basicSelector: #trxOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TrxOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrivOutFileName';
			basicSelector: #privOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrivOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Skip';
			basicSelector: #skip;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Skip';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsRootType';
			basicSelector: #isRootType;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsRootType';
			displaySelector: nil;
			yourself);
		yourself!

xmodelEditorMETASelectorsType

	"METAChildSpecAutoViewEditor openOn: CODEPort selector: #modelEditorMETASelectorsType target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsUse';
			basicSelector: #isUse;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsUse';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsUse';
			nlsTranslation: 'EsUso';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsEnumeration';
			nlsTranslation: 'EsEnumeracion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsPrimitive';
			nlsTranslation: 'EsPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsVirtual';
			basicSelector: #isVirtual;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsVirtual';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsVirtual';
			nlsTranslation: 'EsVirtual';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeRooted';
			basicSelector: #isHomeRooted;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeRooted';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeRooted';
			nlsTranslation: 'EsArraigadoEnOrigen';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeIDProvider';
			basicSelector: #isHomeIDProvider;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeIDProvider';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeIDProvider';
			nlsTranslation: 'OrigenProveeIDs';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrimitiveInitializationString';
			basicSelector: #primitiveInitializationString;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrimitiveInitializationString';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'PrimitiveInitializationString';
			nlsTranslation: 'InicializacionValorPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReengineredClassName';
			basicSelector: #reengineredClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ReengineredClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'ReengineredClassName';
			nlsTranslation: 'NombreDeClasePrograma';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreClassName';
			basicSelector: #storeClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreClassName';
			nlsTranslation: 'ClaseDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreMethodSelector';
			basicSelector: #storeMethodSelector;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreMethodSelector';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreMethodSelector';
			nlsTranslation: 'SelectorDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Operations';
			basicSelector: #operations;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Operations';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSuperTypes';
			basicSelector: #withAllSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSuperTypes';
			basicSelector: #withAllNonAbstractSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'COnTodosLosSuperTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSubTypes';
			basicSelector: #withAllSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSubTypes';
			basicSelector: #withAllNonAbstractSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSubtypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEPort;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSubtypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregationRelationships';
			basicSelector: #allAggregationRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregationRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregationRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);

		addAll: self modelEditorMETASelectorsType2;
		addAll: self modelEditorMETASelectorsType3;

		yourself! !

!CODEPort class publicMethodsFor: 'persistence-code'!

attributesPersistenceSymbol	
	^#attributes!

refToSuperTypeKindSymbol
	^self refToTypeKindSymbol!

relationshipsPersistenceSymbol	
	^#relationships!

superTypesPersistenceSymbol	
	^#supertypes! !

!CODEPort publicMethodsFor: 'accessing'!

baseOutFileName
	"Generated by ISF/AD. Do not modify"
	baseOutFileName isNil
		ifTrue: [self initBaseOutFileName].
	^baseOutFileName!

isAbstract
	"Generated by ISF/AD. Do not modify"
	isAbstract isNil
		ifTrue: [self initIsAbstract].
	^isAbstract!

isAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsAbstract: aValue  == true) ifFalse: [^aValue].
	isAbstract := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isAbstract.
	self allPolymorphicallyRelatedTypes do: [:aT | 
		aT changed: #allNonAbstractPolymorphicallyRelatedTypes].!

isEnumeration
	"Generated by ISF/AD. Do not modify"
	isEnumeration isNil
		ifTrue: [self initIsEnumeration].
	^isEnumeration!

isEnumeration: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsEnumeration: aValue  == true) ifFalse: [^aValue].
	isEnumeration := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isEnumeration!

isExclussion
	"Generated by ISF/AD. Do not modify"
	isExclussion isNil
		ifTrue: [self initIsExclussion].
	^isExclussion!

isExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	isExclussion := aValue.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isExclussion!

isHomeRooted
	isHomeRooted isNil
		ifTrue: [self initIsHomeRooted].
	^isHomeRooted!

isHomeRooted: aValue
	(self checkIsHomeRooted: aValue  == true) ifFalse: [^aValue].
	isHomeRooted := aValue == true.
	self markDirty.
	self changed: #isHomeRooted!

isJustUsed
	"Generated by ISF/AD. Do not modify"
	isJustUsed isNil
		ifTrue: [self initIsJustUsed].
	^isJustUsed!

isJustUsed: aValue
	self isJustUsed = aValue ifTrue: [ ^aValue].
	isJustUsed := aValue == true.

	self changed: #isJustUsed.!

isPrimitive
	"Generated by ISF/AD. Do not modify"
	isPrimitive isNil
		ifTrue: [self initIsPrimitive].
	^isPrimitive!

isPrimitive: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsPrimitive: aValue  == true) ifFalse: [^aValue].
	isPrimitive := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.
	self changed: #isPrimitive!

isUse
	"Generated by ISF/AD. Do not modify"
	isUse isNil
		ifTrue: [self initIsUse].
	^isUse!

isUse: aValue
	(self checkIsUse: aValue  == true) ifFalse: [^aValue].
	self isUse = aValue ifTrue: [ ^aValue].
	isUse := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self updateUses.

	self changed: #isUse.!

name: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkName: aValue) ifFalse: [^aValue].
	name := aValue.
	self markDirty.
	self changed: #name.

	self notifyFullyQualifiedNameChanged!

observers
	^observers!

primitiveInitializationString
	^primitiveInitializationString!

primitiveInitializationString: aValue
	primitiveInitializationString := aValue.
	self changed: #primitiveInitializationString!

reengineredClassName
	^reengineredClassName!

reengineredClassName: aValue
	reengineredClassName := aValue.
	self changed: #reengineredClassName!

storeClassName
	^storeClassName!

storeClassName: elValor
	| unValor unosStrings |
	unValor := (elValor isNil or: [ elValor isEmpty])
		ifTrue: [ nil] 
		ifFalse: [ 	
			unosStrings := elValor  asArrayOfSubstrings.
			unosStrings isEmpty
				ifTrue: [ nil]
				ifFalse: [ 
					unosStrings size > 1
						ifTrue: [ unosStrings first asSymbol]
						ifFalse: [ elValor asSymbol]
				]
		].
	
	unValor = storeClassName  ifTrue: [ ^self].

	storeClassName := unValor.
	self markDirty.

	self changed: #storeClassName!

storeMethodSelector
	^storeMethodSelector!

storeMethodSelector: elValor
	| unValor unosStrings |
	unValor := (elValor isNil or: [ elValor isEmpty])
		ifTrue: [ nil] 
		ifFalse: [ 	
			unosStrings := elValor  asArrayOfSubstrings.
			unosStrings isEmpty
				ifTrue: [ nil]
				ifFalse: [ 
					unosStrings size > 1
						ifTrue: [ unosStrings first asSymbol]
						ifFalse: [ elValor asSymbol]
				]
		].
	
	unValor = storeMethodSelector  ifTrue: [ ^self].

	storeMethodSelector := unValor.
	self markDirty.

	self changed: #storeMethodSelector! !

!CODEPort publicMethodsFor: 'accessing-find'!

hasTypeNamed: theTypeName
	
	^(self typeNamed: theTypeName) isNil not!

typeNamed: theTypeName
	
	| anExistingType |
	theTypeName isNil ifTrue: [ ^self].
	(theTypeName findString: '::' startingAt: 1 ) > 0 ifTrue: [  ^self findTypeNamed: theTypeName].

	anExistingType := self typesPrivate detect: [:aType | aType name = theTypeName] ifNone: [ nil].
	^anExistingType! !

!CODEPort publicMethodsFor: 'accessing-private'!

forzeIsAbstract: aValue
	isAbstract := aValue == true.!

forzeIsEnumeration: aValue
	isEnumeration := aValue == true.!

forzeIsExclussion: aValue
	isExclussion := aValue == true.!

forzeIsHomeRooted: aValue
	isHomeRooted := aValue == true.!

forzeIsJustUsed: aValue
	isJustUsed := aValue == true.!

forzeIsPrimitive: aValue
	isPrimitive := aValue == true.!

forzeIsUse: aValue
	isUse := aValue == true.!

forzePrimitiveInitializationString: aValue
	primitiveInitializationString := aValue!

forzeReengineredClassName: aValue
	reengineredClassName := aValue!

forzeStoreClassName: aValue
	storeClassName := aValue!

forzeStoreMethodSelector: aValue
	storeMethodSelector := aValue! !

!CODEPort publicMethodsFor: 'association initialize-release'!

initSubTypes
	"Generated by ISF/AD. Do not modify"
	subTypes := IdentitySet new.!

initSuperTypes
	"Generated by ISF/AD. Do not modify"
	superTypes := OrderedCollection new.!

initTypes
	"Generated by ISF/AD. Do not modify"
	types := OrderedCollection new.!

moduleRelease
	"Generated by ISF/AD. Do not modify"
	module == nil
		ifFalse:
			[module typesPrivateRemove: self.
				module := nil.
				self changed: #module]!

subTypesRelease
	"Generated by ISF/AD. Do not modify"
	self subTypes do: [:each | self subTypesRemove: each]!

superTypesRelease
	"Generated by ISF/AD. Do not modify"
	self superTypes do: [:each | self superTypesRemove: each]!

typesRelease
	"Generated by ISF/AD. Do not modify"
	self types do: [:each | self typesRemove: each]! !

!CODEPort publicMethodsFor: 'associations accessing'!

module
	"Generated by ISF/AD. Do not modify"
	^module!

module: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkModule: aValue) ifFalse: [^aValue].
	module == aValue ifTrue: [ ^self].
	self moduleRelease.
	module := aValue.
	aValue == nil ifFalse: [aValue typesPrivateAdd: self].
	self changed: #module!

subTypes
	"Generated by ISF/AD. Do not modify"
	^self subTypesPrivate copy!

subTypesAsArray
	"Generated by ISF/AD. Do not modify"
	^self subTypes asArray!

superTypes
	"Generated by ISF/AD. Do not modify"
	^self superTypesPrivate copy!

superTypesAsArray
	"Generated by ISF/AD. Do not modify"
	^self superTypes asArray!

types
	"Generated by ISF/AD. Do not modify"
	^self typesPrivate copy!

typesAsArray
	"Generated by ISF/AD. Do not modify"
	^self types asArray! !

!CODEPort publicMethodsFor: 'associations modifying'!

subTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSubTypesAdd: aValue) ifFalse: [^aValue].
	(self subTypesIncludes: aValue) ifTrue: [^aValue].
	(self subTypesPrivateAdd: aValue) superTypesPrivateAdd: self.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ 
		aValue invalidateMemberInstanceTypesCache.
		aValue invalidateEffectiveFeaturesCaches
	].
	self changed: #subTypes.
	^aValue!

subTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSubTypesRemove: aValue) ifFalse: [^aValue].
	(self subTypesPrivate remove: aValue ifAbsent: [^aValue]) superTypesPrivateRemove: self.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ 
		aValue invalidateMemberInstanceTypesCache.
		aValue invalidateEffectiveFeaturesCaches
	].
	self changed: #subTypes.
	^aValue!

superTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSuperTypesAdd: aValue) ifFalse: [^aValue].
	(self superTypesIncludes: aValue) ifTrue: [^aValue].
	(self superTypesPrivateAdd: aValue) subTypesPrivateAdd: self.

	self invalidateEffectiveFeaturesCaches.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ aValue invalidateMemberInstanceTypesCache].

	self isUse ifTrue: [ self updateUses].
	self updateRefinedFeatures.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].

	^aValue!

superTypesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(self superTypes indexOf: aValue) = self superTypesSize ifTrue: [^aValue].
	self superTypesPrivate remove: aValue.
	aRes := self superTypesPrivateAdd: aValue.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(index := self superTypes indexOf: aValue) = self superTypesSize ifTrue: [^aValue].
	index = (self superTypesSize -1)
		ifTrue:
			[self superTypesPrivate remove: aValue.
			aRes := self superTypesPrivateAdd: aValue.
			self notifyChangeAllRelationshipsChildSpecs.
			^aRes].
	aRes := self superTypesPrivateMove: aValue beforeIndex: index + 2.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(self superTypes indexOf: aValue) = 1 ifTrue: [^aValue].
	self superTypesPrivateMove: aValue beforeIndex: 1.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].!

superTypesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(index := self superTypes indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self superTypesPrivateMove: aValue beforeIndex: index - 1.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSuperTypesRemove: aValue) ifFalse: [^aValue].
	(self superTypesPrivate remove: aValue ifAbsent: [^aValue]) subTypesPrivateRemove: self.

	self removeRefinementFeaturesFromMissingSuperTypes.

	self invalidateEffectiveFeaturesCaches.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ aValue invalidateMemberInstanceTypesCache].

	self isUse ifTrue: [ self updateUses].
	self updateRefinedFeatures.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].

	^aValue!

typesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesAdd: aValue) ifFalse: [^aValue].
	(self typesIncludes: aValue) ifTrue: [^self typesMoveBottom: aValue].
	(self typesPrivateAdd: aValue) modulePrivate: self.
	self changed: #types.
	^aValue!

typesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	self typesPrivate remove: aValue.
	^self typesPrivateAdd: aValue!

typesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	index = (self typesSize -1)
		ifTrue:
			[self typesPrivate remove: aValue.
			^self typesPrivateAdd: aValue].
	^self typesPrivateMove: aValue beforeIndex: index + 2!

typesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = 1 ifTrue: [^aValue].
	self typesPrivateMove: aValue beforeIndex: 1!

typesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = 1 ifTrue: [^aValue].
	^self typesPrivateMove: aValue beforeIndex: index - 1!

typesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesRemove: aValue) ifFalse: [^aValue].
	(self typesPrivate remove: aValue ifAbsent: [^aValue]) modulePrivate: nil.
	self changed: #types.
	^aValue! !

!CODEPort publicMethodsFor: 'associations private'!

modulePrivate: aValue
	| aPrevValue |
	aPrevValue := module.
	module := aValue.
	self changed: #module.
	(module isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

subTypesPrivate
	"Generated by ISF/AD. Do not modify"
	subTypes isNil
		ifTrue: [self initSubTypes].
	^subTypes!

subTypesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self subTypesPrivate add: aValue.
	self changed: #subTypes.
	^aValue!

subTypesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self subTypesPrivate remove: aValue.
	self changed: #subTypes.
	^aValue!

superTypesPrivate
	"Generated by ISF/AD. Do not modify"
	superTypes isNil
		ifTrue: [self initSuperTypes].
	^superTypes!

superTypesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self superTypesPrivate add: aValue.
	self changed: #superTypes.
	^aValue!

superTypesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self superTypes at: anIndex.
	self superTypesPrivate remove: aValue.
	self superTypesPrivate add: aValue before: obj.
	self changed: #superTypes.
	^aValue!

superTypesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self superTypesPrivate remove: aValue.
	self changed: #superTypes.
	^aValue!

typesPrivate
	"Generated by ISF/AD. Do not modify"
	types isNil
		ifTrue: [self initTypes].
	^types!

typesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate add: aValue.
	self markDirty.

	self changed: #types.
	^aValue!

typesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self types at: anIndex.
	self typesPrivate remove: aValue.
	self typesPrivate add: aValue before: obj.
	self markDirty.

	self changed: #types.
	^aValue!

typesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate remove: aValue.
	self markDirty.

	self changed: #types.
	^aValue! !

!CODEPort publicMethodsFor: 'associations testing'!

subTypesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^subTypes isNil
		ifTrue: [false]
		ifFalse: [self subTypes includes: aValue]!

subTypesSize
	"Generated by ISF/AD. Do not modify"
	^subTypes isNil
		ifTrue: [0]
		 ifFalse: [subTypes size]!

superTypesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^superTypes isNil
		ifTrue: [false]
		ifFalse: [self superTypes includes: aValue]!

superTypesSize
	"Generated by ISF/AD. Do not modify"
	^superTypes isNil
		ifTrue: [0]
		 ifFalse: [superTypes size]!

typesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [false]
		ifFalse: [self types includes: aValue]!

typesSize
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [0]
		 ifFalse: [types size]! !

!CODEPort publicMethodsFor: 'changing'!

notifyFullyQualifiedNameChanged
	
	self changed: #allContainerNamespaceNames.

	self types do: [:aType | aType notifyFullyQualifiedNameChanged]! !

!CODEPort publicMethodsFor: 'derivations cache'!

initEffectiveFeaturesCaches
	| someFeatures someAttributes someRelationships someOperations |

	effectiveAttributesCache := nil.
	effectiveRelationshipsCache := nil.
	effectiveStructuralFeaturesCache := nil.
	effectiveOperationsCache := nil.
	effectiveFeaturesCache := nil.
	effectiveIDAttributeCache := nil.
	effectiveNameAttributeCache := nil.

	someFeatures := self allEffectiveFeaturesNoCache.
	someFeatures isNil ifTrue: [ ^self].

	someAttributes := OrderedCollection new: someFeatures size.
	someRelationships := OrderedCollection new: someFeatures size.
	someOperations := OrderedCollection new: someFeatures size.

	someFeatures do: [:aFeature |
		aFeature isAttribute ifTrue: [ 
			someAttributes add: aFeature.
			effectiveIDAttributeCache isNil ifTrue: [ aFeature isIDAttribute ifTrue: [ effectiveIDAttributeCache := aFeature]].
			effectiveNameAttributeCache isNil ifTrue: [ aFeature isNameAttribute ifTrue: [ effectiveNameAttributeCache := aFeature]].
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [ someRelationships add: aFeature] ifFalse: [ 
		aFeature isOperation ifTrue: [ someOperations add: aFeature] ifFalse: [ 
		
		]]]
	].

	effectiveFeaturesCache := someFeatures.
	effectiveAttributesCache := someAttributes asArray.
	effectiveRelationshipsCache := someRelationships asArray.
	effectiveStructuralFeaturesCache := effectiveAttributesCache , effectiveRelationshipsCache.
	effectiveOperationsCache := someOperations asArray.
	effectiveFeaturesCache := effectiveStructuralFeaturesCache , effectiveOperationsCache.

	effectiveIDAttributeCache isNil ifTrue: [ effectiveIDAttributeCache := self class alreadyDerivedAttribute].
	effectiveNameAttributeCache isNil ifTrue: [ effectiveNameAttributeCache := self class alreadyDerivedAttribute].! !

!CODEPort publicMethodsFor: 'derived accessing'!

allContainerModuleNamesInto: theStream

	| aModule |
	theStream isNil ifTrue: [ ^self].

	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].!

allContainerNamespaceNames

	self module isNil ifTrue: [ ^'' copy].
	^self module allNamespaceNames!

allContainerPackageNames

	self module isNil ifTrue: [ ^'' copy].
	^self module allPackageNames!

allDefinedAspectsInto: theSet
	theSet isNil ifTrue: [ ^self].

	super allDefinedAspectsInto: theSet.
	self attributes do: [:anAttribute | anAttribute allDefinedAspectsInto: theSet].
	self relationships do: [:aRelationship | aRelationship allDefinedAspectsInto: theSet].!

allFeatures

	| someFeatures someSortedFeatures |

	someFeatures := IdentitySet new: 37.

	self allFeaturesInto: someFeatures.
		
	someSortedFeatures := someFeatures asSortedCollection: [:aFeature :otherFeature |
		aFeature name < otherFeature name].

	^someSortedFeatures!

allFeaturesInto: theSet

	theSet isNil ifTrue: [ ^nil].

	theSet addAll: self attributes.
	theSet addAll: self relationships.

	self superTypes do: [:aType | 
		aType allFeaturesInto: theSet	
	].
		
	^theSet!

allLocalEffectiveFeatures

	| someAttributes someRelationships someFeatures |

	someAttributes := self attributes.
	someRelationships := self relationships.
	someFeatures := OrderedCollection new: someAttributes size + someRelationships size.
	someAttributes do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			someFeatures add: aFeature
		]
	].
	someRelationships do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			someFeatures add: aFeature
		]
	].
	^someFeatures!

allModuleNamesInto: theStream

	| aModule aSep |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

allModules

	| aModule someModules |
	aModule := self module.
	aModule isNil ifTrue: [ ^Array new].

	someModules := IdentitySet new: 13.
	aModule allModulesInto: someModules.
	^someModules!

allNamespaceNames
	| aPackages |
	self module isNil ifTrue: [ ^self name copy].
	aPackages := self module allNamespaceNames.
	^(aPackages isEmpty ifTrue: [''] ifFalse: [ aPackages , '::']) , self name!

allNonAbstractTypes
	| someTypes someNonAbstractTypes |
	someTypes := self allTypes.
	someNonAbstractTypes := someTypes reject: [:aType | aType isAbstract].
	^someNonAbstractTypes!

allPackageNames
	| aPackages |
	self module isNil ifTrue: [ ^self name copy].
	aPackages := self module allPackageNames.
	^(aPackages isEmpty ifTrue: [''] ifFalse: [ aPackages , '.']) , self name!

allSubTypes
	^self allSubtypes!

allSubtypes
	| someSubTypes |
	someSubTypes := IdentitySet new: 13.
	self subTypesPrivate do: [:aSubType |	
		aSubType allSubTypesInto: someSubTypes
	].
	^someSubTypes!

allSubtypes: theSubTypes includes: theType

	theSubTypes isNil ifFalse: [ 
		(theSubTypes includes: self) 
			ifTrue: [ ^false]
			ifFalse: [  theSubTypes add: self]
	].

	(self subTypesIncludes: theType) ifTrue: [ ^true].

	^(self subTypes detect: [:aSubtype | aSubtype allSubtypes: theSubTypes includes: theType] ifNone: [ nil]) notNil!

allSubtypesIncludes: theType
	| someSubTypes |
	someSubTypes := IdentitySet new.
	^self allSubtypes: someSubTypes includes: theType!

allSubTypesInto: theSubTypes
	
	^self allSubtypesInto: theSubTypes!

allSubtypesInto: theSubTypes
	
	(theSubTypes includes: self) ifTrue: [ ^self].
	theSubTypes add: self.
	self subTypesPrivate do: [:aSubype |	
		aSubype allSubtypesInto: theSubTypes
	]!

allSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesInto: someSuperTypes
	].
	^someSuperTypes!

allSuperTypesInto: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesInto: theSuperTypes
	].!

allSuperTypesWithFeature: theFeature
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesWithFeature: theFeature into: someSuperTypes
	].
	^someSuperTypes!

allSuperTypesWithFeature: theFeature into: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].
	
	(self hasEffectiveFeature: theFeature) ifFalse: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesWithFeature: theFeature into: theSuperTypes
	].!

allTypes
	| someTypes |
	someTypes := IdentitySet new: 111.
	self allTypesInto: someTypes.
	^someTypes!

allTypesInto: theSet
	| someTypes |
	theSet isNil ifTrue: [ ^self].

	someTypes := self typesPrivate.
	theSet addAll: someTypes.
	someTypes do: [:aType | aType allTypesInto: theSet].!

applicationConfiguration
	^self module isNil ifTrue: [ nil] ifFalse: [ self module applicationConfiguration]!

features
	^self attributesPrivate asArray , self relationshipsPrivate asArray!

fullyQualifiedName

	| aModuleFullyQualifiedName aFullyQualifiedName |
	self module isNil ifTrue: [ ^self name].
	
	aModuleFullyQualifiedName := self module fullyQualifiedName.
	(aModuleFullyQualifiedName isNil or: [ aModuleFullyQualifiedName isEmpty]) ifTrue: [ 
		^self name
	].

	aFullyQualifiedName := aModuleFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

fullyQualifiedNameArray

	| aModuleFullyQualifiedName aFullyQualifiedNameArray |
	self module isNil ifTrue: [ ^Array with: self name].
	
	aModuleFullyQualifiedName := self module fullyQualifiedNameArray.
	(aModuleFullyQualifiedName isNil or: [ aModuleFullyQualifiedName isEmpty]) ifTrue: [ 
		^Array with: self name
	].

	aFullyQualifiedNameArray := aModuleFullyQualifiedName, (Array with: self name).
	^aFullyQualifiedNameArray!

hasEffectiveFeature: theFeature

	| aResult |

	theFeature isNil  ifTrue: [ ^false].

	aResult := self allEffectiveFeatures includes: theFeature.
	^aResult!

hasEffectiveFeatureNamed: theName

	^(self effectiveFeatureNamed: theName) isNil not!

hasEffectiveStructuralFeature: theFeature

	| aResult |

	theFeature isNil  ifTrue: [ ^false].

	aResult := self allEffectiveStructuralFeatures includes: theFeature.
	^aResult!

hasSuperType: theSuperType

	theSuperType isNil ifTrue: [ ^false].

	^(self superTypesPrivate detect: [:aSuperType |
		aSuperType == theSuperType or: [
			aSuperType hasSuperType: theSuperType 
		]
	] ifNone: [ nil]) isNil not!

isVisibleInModules: 		theModules
	andAspects: 			theAspects
	definitionsHolder: 	theDefinitionsHolder

	((theModules isNil or: [ theModules isEmpty]) and: [  
		theAspects isNil or: [ theAspects isEmpty]]) ifTrue: [ 
		^true
	].

	^(  self isVisibleInModules: 	theModules definitionsHolder: 	theDefinitionsHolder) and: [ 
		self isVisibleInAspects: 	theAspects definitionsHolder: 	theDefinitionsHolder
	]!

isVisibleInModules: 		theModules
	definitionsHolder: 	theDefinitionsHolder


	| aThisModule |

	(theModules isNil or: [ theModules isEmpty]) ifTrue: [ ^true ].

	(theModules isNil not and: [ theModules isEmpty not]) ifTrue: [ 
		aThisModule := self module.
		aThisModule isNil ifTrue: [ ^false].
		(theModules includes: aThisModule) ifFalse: [ 
			(theModules detect: [:aModule | aModule includesModule: aModule] ifNone: [ nil]) isNil ifTrue: [ ^false]
		]
	].!

model
	^self module isNil ifTrue: [ nil] ifFalse: [ self module model]!

nameAttribute

	| aNameAttribute |
	aNameAttribute := self allEffectiveAttributes detect: [:anAttribute | anAttribute isNameAttribute] ifNone: [ nil].
	^aNameAttribute!

nameRelationship

	| aNameRelationship |
	aNameRelationship := self allEffectiveRelationships detect: [:anRelationship | anRelationship isNameRelationship] ifNone: [ nil].
	^aNameRelationship!

rootTypes
	| someTypes |
	someTypes := IdentitySet new: 37.
	self rootTypesInto: someTypes.
	^someTypes!

rootTypesInto: theSet
	| someTypes |
	theSet isNil ifTrue: [ ^self].

	someTypes := self types.
	someTypes do: [:aType | aType isRootType ifTrue: [ theSet add: aType]].
	someTypes do: [:aType | aType rootTypesInto: theSet].!

superType
	self superTypesSize < 1 ifTrue: [ ^nil].
	^self superTypes first!

typePrefix
	^self model isNil ifTrue: [ nil] ifFalse: [ self model typePrefix]!

withAllNonAbstractSubtypes
	^self withAllSubtypes reject: [:aT | aT isAbstract]!

withAllNonAbstractSubtypes: theSubTypes
	theSubTypes isNil ifTrue: [ ^theSubTypes].
	self isAbstract ifFalse: [ 
		(theSubTypes includes: self) ifFalse: [ 
			theSubTypes add: self]].

	self subTypes do: [:aSubtype | aSubtype withAllNonAbstractSubtypes: theSubTypes].
	^theSubTypes!

withAllNonAbstractSuperTypes
	^self withAllSuperTypes reject: [:aT | aT isAbstract]!

withAllSubtypes
	| someSubTypes |
	someSubTypes := OrderedCollection new.
	self withAllSubtypes: someSubTypes.
	^someSubTypes!

withAllSubtypes: theSubTypes
	theSubTypes isNil ifTrue: [ ^theSubTypes].
	(theSubTypes includes: self) ifTrue: [ ^theSubTypes].
	theSubTypes add: self.
	self subTypesPrivate do: [:aSubtype | aSubtype withAllSubtypes: theSubTypes].
	^theSubTypes!

withAllSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new.
	self withAllSuperTypes: someSuperTypes.
	^someSuperTypes!

withAllSuperTypes: theSuperTypes
	theSuperTypes isNil ifTrue: [ ^theSuperTypes].
	(theSuperTypes includes: self) ifTrue: [ ^theSuperTypes].
	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType | aSuperType withAllSuperTypes: theSuperTypes].
	^theSuperTypes! !

!CODEPort publicMethodsFor: 'derived col accessing'!

allAbstractSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allAbstractSuperTypesInto: someSuperTypes
	].
	^someSuperTypes!

allAbstractSuperTypesInto: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].

	self isAbstract ifFalse: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allAbstractSuperTypesInto: theSuperTypes
	].! !

!CODEPort publicMethodsFor: 'derived effective features'!

allEffectiveFeatures

	^self allEffectiveFeaturesFromCache!

allEffectiveFeaturesFromCache

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	^effectiveFeaturesCache!

allEffectiveFeaturesNoCache

	| someFeatures someFeaturesNotToInclude someFeatureNamesNotToInclude |
"Transcript show: 'EF ' , self name; cr."

	someFeatures := OrderedCollection new: 32.

	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someFeaturesNotToInclude := IdentitySet new: 13.
		someFeatureNamesNotToInclude := Set new: 13.
		self attributes do: [:aFeature | 
			aFeature allRefinedAttributesInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self relationships do: [:aFeature | 
			aFeature allRefinedRelationshipsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self operations do: [:aFeature | 
			aFeature allRefinedOperationsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveFeatures do: [:aFeature |
				((someFeaturesNotToInclude includes: aFeature) or: [ 
					someFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
					(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
				]
			]
		].
	].

	self attributes do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	self relationships do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	self operations do: [:aFeature | 
		aFeature isExclussion not ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	^someFeatures!

effectiveFeatureNamed: theName

	^self effectiveFeatureNamedFromCache: theName!

effectiveFeatureNamedFromCache: theName

	| aFoundFeature |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveFeaturesCache isNil ifTrue: [ ^nil].

	aFoundFeature := nil.
	effectiveFeaturesCache detect: [:aFeature | 
		aFeature isExclussion ifFalse: [ 
			(aFeature isAttribute or: [ aFeature isRelationship]) 
				ifTrue: [ 
					(aFeature maxMult = aFeature class  maxMultNone) ifFalse: [ 
						aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
					]
				]
				ifFalse: [ 
					aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
				]								
		].
		aFoundFeature isNil not
	] ifNone: [ nil].

	^aFoundFeature!

effectiveFeatureTypedNamed: theName

	^self effectiveFeatureTypedNamedFromCache: theName!

effectiveFeatureTypedNamedFromCache: theName

	| aFoundFeature |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveFeaturesCache isNil ifTrue: [ ^nil].

	aFoundFeature := nil.
	effectiveFeaturesCache detect: [:aFeature |  | aFeatureReferencedType |
		aFeature isExclussion ifFalse: [ 
			(aFeature isAttribute or: [ aFeature isRelationship]) 
				ifTrue: [ 
					(aFeature maxMult = aFeature class  maxMultNone) ifFalse: [ 
						aFeatureReferencedType := aFeature referencedType.
						(aFeatureReferencedType isNil not and: [ aFeatureReferencedType name = theName])  ifTrue: [ aFoundFeature := aFeature].
					]
				]
				ifFalse: [ 
					aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
				]								
		].
		aFoundFeature isNil not
	] ifNone: [ nil].

	^aFoundFeature!

effectiveNameAttribute

	^self effectiveNameAttributeFromCache!

effectiveNameAttributeFromCache

	effectiveNameAttributeCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveNameAttributeCache isNil ifTrue: [ ^nil].

	effectiveNameAttributeCache == self class alreadyDerivedAttribute ifTrue: [ ^nil].

	^effectiveNameAttributeCache!

effectiveNameAttributeNoCache

	| someAttributesNotToInclude someAttributeNamesNotToInclude aNameAttribute |

	someAttributesNotToInclude := IdentitySet new: 13.
	someAttributeNamesNotToInclude := IdentitySet new: 13.

	aNameAttribute := self effectiveNameAttributeNotInclude: someAttributesNotToInclude notIncludeNamed: someAttributeNamesNotToInclude.
	^aNameAttribute! !

!CODEPort publicMethodsFor: 'derived use'!

initUseFeatures: theFeatures! !

!CODEPort publicMethodsFor: 'dirty'!

cleanDirtyMark
	super cleanDirtyMark.
	self attributes do: [:anAttrib | anAttrib cleanDirtyMark].
	self relationships do: [:aRel | aRel cleanDirtyMark].!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self module isNil ifFalse: [ self module markDirtyOwner]
	].!

markDirtyOwner
	self mustStore 
		ifTrue: [ self markDirty]
		ifFalse: [ self module isNil ifFalse: [ self module markDirty]]!

persistIfDirty
	^self module isNil ifFalse: [ self module persistIfDirty] ifTrue: [ nil]! !

!CODEPort publicMethodsFor: 'find'!

featureNamed: theFeatureName
	
	| anExistingFeature |

	theFeatureName isNil ifTrue: [ ^self].

	anExistingFeature := self attributes detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self relationships detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self operations detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	^nil!

featureOrInheritedNamed: theFeatureName
	
	| anExistingFeature someSuperTypes |

	theFeatureName isNil ifTrue: [ ^nil].

	anExistingFeature := self attributes detect: [:anAttribute | anAttribute name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self relationships detect: [:aRelationship | aRelationship name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^nil].

	someSuperTypes detect: [:aSuperType |  | aFeature |
		aFeature := aSuperType featureOrInheritedNamed: theFeatureName.
		aFeature isNil ifFalse: [ ^aFeature] ifTrue: [ false]
	] ifNone: [ nil].

	^nil!

hasOrInheritsFeature: theFeature
	
	| someSuperTypes aResult |

	theFeature isNil ifTrue: [ ^false].

	(self attributesIncludes: theFeature) 			ifTrue: [ ^true].
	(self relationshipsIncludes: theFeature) 		ifTrue: [ ^true].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSuperTypes detect: [:aSuperType | 
		aSuperType hasOrInheritsFeature: theFeature] ifNone: [ nil]) isNil not.

	^aResult!

hasOrInheritsFeatureNamed: theFeatureName
	
	| anExistingFeature someSuperTypes aResult |

	theFeatureName isNil ifTrue: [ ^false].

	anExistingFeature := self attributes detect: [:anAttribute | anAttribute name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^true].

	anExistingFeature := self relationships detect: [:aRelationship | aRelationship name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^true].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSuperTypes detect: [:aSuperType | 
		aSuperType hasOrInheritsFeatureNamed: theFeatureName] ifNone: [ nil]) isNil not.

	^aResult!

operationNamed: theOperationName
	
	| anExistingOperation |
	theOperationName isNil ifTrue: [ ^self].
	anExistingOperation := self operations detect: [:anOperation | anOperation name = theOperationName] ifNone: [ nil].
	^anExistingOperation!

operationOrInheritedNamed: theFeatureName
	
	| anExistingFeature someSuperTypes |

	theFeatureName isNil ifTrue: [ ^nil].

	anExistingFeature := self operations detect: [:anOperation | anOperation name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^nil].

	someSuperTypes detect: [:aSuperType |  | aFeature |
		aFeature := aSuperType operationOrInheritedNamed: theFeatureName.
		aFeature isNil ifFalse: [ ^aFeature] ifTrue: [ false]
	] ifNone: [ nil].

	^nil!

relationshipNamed: theRelationshipName
	
	| anExistingRelationship |
	theRelationshipName isNil ifTrue: [ ^self].
	anExistingRelationship := self relationships detect: [:aRelationship | aRelationship name = theRelationshipName] ifNone: [ nil].
	^anExistingRelationship!

relationshipOrInheritedNamed: theFeatureName
	
	| anExistingFeature someSuperTypes |

	theFeatureName isNil ifTrue: [ ^nil].

	anExistingFeature := self relationships detect: [:aRelationship | aRelationship name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^nil].

	someSuperTypes detect: [:aSuperType |  | aFeature |
		aFeature := aSuperType relationshipOrInheritedNamed: theFeatureName.
		aFeature isNil ifFalse: [ ^aFeature] ifTrue: [ false]
	] ifNone: [ nil].

	^nil! !

!CODEPort publicMethodsFor: 'initialize-release'!

initIsAbstract
	isAbstract := false!

initIsEnumeration
	isEnumeration := false!

initIsExclussion
	isExclussion := false!

initIsHomeIDProvider
	isHomeIDProvider := false!

initIsHomeRooted
	isHomeRooted := false!

initIsJustUsed
	isJustUsed := true!

initIsPrimitive
	isPrimitive := false!

initIsUse
	isUse := false!

initIsVirtual
	isVirtual := false!

initSkip
	skip := false!

observersRelease
	observers isNil ifTrue: [ ^self].
	observers do: [:anObserver | anObserver release].
	observers := nil!

release
	self changed: #objectDisconnectedOfTree.

	self relatedWithRelease.
	self typeOfValuesRelease.
	self typeOfArgumentsRelease.
	self typeOfReturnsRelease.
	self superTypesRelease.
	self subTypesRelease.
	self relationshipsRelease.
	self attributesRelease.
	self operationsRelease.
	self moduleRelease.
	self observersRelease.
	self typesRelease.

	effectiveAttributesCache := nil.
	effectiveRelationshipsCache := nil.
	effectiveStructuralFeaturesCache := nil.
	effectiveOperationsCache := nil.
	effectiveFeaturesCache := nil.
	effectiveIDAttributeCache  := nil.
	effectiveNameAttributeCache := nil.

	memberInstanceTypesCache := nil.

	super release! !

!CODEPort publicMethodsFor: 'integrity'!

integrityReportOn: theReport justFirst: theJustFirst

	| someTypes someAttributes someRelationships someOperations |

	theReport isNil  ifTrue: [ ^self].

	(theJustFirst == true and: [ theReport isEmpty not]) ifTrue:  [ ^self].

	someTypes := self types.
	someTypes do: [:aType | | aSuperType aReportEntry |
		aSuperType := aType module.
		self == aSuperType ifFalse: [ 
			aReportEntry := theReport at: aType ifAbsent: [ nil].
			aReportEntry ifTrue: [ 
				aReportEntry := OrderedCollection new: 2.
				theReport at: aType put: aReportEntry
			].
			aReportEntry add: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].

	someAttributes:= self attributes.
	someAttributes do: [:aAttribute |
		aAttribute integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].

	someRelationships:= self relationships.
	someRelationships do: [:aRelationship |
		aRelationship integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].
	someOperations:= self operations.
	someOperations do: [:aOperation |
		aOperation integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].! !

!CODEPort publicMethodsFor: 'parse'!

featuresFromLine: theLine andStream: theStream
	
	| aStream  |
	theLine isNil ifTrue: [ ^self].
	theLine isEmpty ifTrue: [ ^self].
	(theLine first == $/ or: [ theLine first == $#]) ifTrue: [ ^self].
self logTranscript ifTrue: [ Transcript show: (String with: Character tab); show: ' features ';  cr].

	aStream := ReadStream on: theLine.
	[ aStream atEnd] whileFalse: [ | aWord  |
		aWord := aStream upTo: Character space.
		aWord isEmpty ifFalse: [ 
			aWord = '}' ifTrue: [ ^self].
			aWord = 'attribute' ifTrue: [  self attributeFromLineStream: aStream andStream: theStream] ifFalse: [ 
			aWord = 'relationship' ifTrue: [  self relationshipFromLineStream: aStream andStream: theStream] ifFalse: [ 
			]]			
		]
	]!

featuresFromStream: theStream

	theStream isNil ifTrue: [ ^nil].
	theStream atEnd ifTrue: [ ^nil].
	self model isNil ifTrue: [ ^nil].

	[ theStream atEnd] whileFalse: [ |  aLine aTrimmedLine |
		aLine := theStream upTo: Character cr.
		aTrimmedLine := aLine trimSeparators.
		aTrimmedLine isEmpty ifFalse: [ 
			aTrimmedLine first = $} ifTrue: [ ^self].
			self featuresFromLine: aTrimmedLine andStream: theStream	
		]	
	]!

findTypeNamed: theTypeName
	
	| anExistingType anSpacedTypeName someNames |
	theTypeName isNil ifTrue: [ ^self].
	theTypeName isEmpty ifTrue: [ ^self].

	(theTypeName findString: '::' startingAt: 1 ) > 0 
		ifFalse: [  
			anExistingType := self types detect: [:aType | aType name = theTypeName] ifNone: [ nil].
			anExistingType isNil ifFalse: [ ^anExistingType].
			someNames := Array with: theTypeName
		]
		ifTrue: [ 
			anSpacedTypeName := theTypeName copyReplaceAll: '::' with: ' '.
			someNames := anSpacedTypeName asArrayOfSubstrings
		].
	
	^self findTypeNamedArray: someNames!

findTypeNamedArray: theNames
	
	| aName aModule otherNames aSuperModule aType |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ 
		aType := self typeNamed: aName.
		aType isNil ifFalse: [ ^aType].
	].

	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ 
		aSuperModule := self superModule.
		aSuperModule isNil ifTrue: [ ^nil].
		^aSuperModule findTypeNamedArray: theNames].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames!

fromLineStream: theLineStream andStream: theStream

	theLineStream isNil ifTrue: [ ^nil].
	theLineStream atEnd ifTrue: [ ^nil].
self logTranscript ifTrue: [ Transcript  show: ' >> ';  show: self name; cr].

	[ theLineStream atEnd] whileFalse: [ 	| aWord |
		aWord := self nextTokenFrom: theLineStream.
		aWord isNil ifTrue: [ ^nil].
		aWord = ';' ifTrue: [ ^nil].
		aWord = ':' 
			ifTrue: [ self superTypeFromLineStream: theLineStream andStream: theStream]
			ifFalse: [ 
				aWord = '{' 
					ifTrue: [ self featuresFromStream: theStream]
					ifFalse: [ 
						aWord = '}' ifTrue: [ ^self]
					]	
			]	

	]!

superTypeFromLineStream: theLineStream andStream: theStream

	| aWord aSuperType |
	theLineStream isNil ifTrue: [ ^nil].
	theLineStream atEnd ifTrue: [ ^nil].
	self model isNil ifTrue: [ ^nil].

  [ theLineStream atEnd] whileFalse: [ 

	aWord := self nextTokenFrom: theLineStream stopAt: '{'.
	aWord isNil ifTrue: [ ^nil].
	aWord isEmpty ifTrue: [ ^self].
	aWord = '{' ifTrue: [ ^self].
	aWord = ','  ifFalse: [ 
	aSuperType := self module findTypeNamed: aWord.
	aSuperType isNil ifFalse: [ 
self logTranscript ifTrue: [ Transcript show: (String with: Character tab); show: ' super '; show: aWord; cr].
"Transcript show: (String with: Character tab); show: self name, ' super '; show: aWord; cr."
		aSuperType subTypesAdd: self.
	]
   ]
  ]!

typeFromLineStream: theLineStream andStream: theStream
	
	| aTypeName   anExistingType aNewType anErrorName |

	theLineStream isNil ifTrue: [ ^self].
	theLineStream atEnd ifTrue: [ ^self].
	
	aTypeName := self nextTokenFrom: theLineStream.
	aTypeName isEmpty ifTrue: [ ^self].
	
	anExistingType := self typeNamed: aTypeName.
	anExistingType isNil
		ifFalse: [ 
			self model errorLineKind isNil ifFalse: [ 
				anErrorName := self model errorLineName.
				anErrorName = 'Enumeration' ifTrue: [ anExistingType isEnumeration: true].
				anErrorName = 'primitive' ifTrue: [ anExistingType isPrimitive: true].
			].
			self model foundIsAbstract ifTrue: [ 
				 anExistingType isAbstract: true].

			anExistingType fromLineStream: theLineStream andStream: theStream]
		ifTrue: [  
self logTranscript ifTrue: [ Transcript show: '+ T '; show: aTypeName; cr].
					
			aNewType := CODEPort new.
			aNewType name: aTypeName.
			self typesAdd: aNewType.
			self model errorLineKind isNil ifFalse: [ 
				anErrorName := self model errorLineName.
				anErrorName = 'Enumeration' ifTrue: [ aNewType isEnumeration: true].
				anErrorName = 'primitive' ifTrue: [ aNewType isPrimitive: true].
			].
			aNewType fromLineStream: theLineStream andStream: theStream
		].!

typeNamedArray: theNames
	
	| aName aModule otherNames |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ ^self typeNamed: aName].
	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ ^nil].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames! !

!CODEPort publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aModule aSep |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].

	theStream 
		nextPutAll: (self pcForV: self class qualifiedNameTypeStepSymbol); nextPutAll: aSep;
		 nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

asReferenceArray

	| someModuleNames aModule |

	aModule := self module.
	someModuleNames := aModule isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aModule allModuleNamesArray].

	^(Array with: self class refToTypeKindSymbol with: self name), someModuleNames!

asReferenceAsCodeString

	| aModule aStream |

	aStream := WriteStream on: (OrderedCollection new: 8).

	aModule := self module.

	aStream nextPut: self class refToTypeKindSymbol;  
		nextPut: self name.

	aModule isNil  ifFalse: [ aModule allModuleNamesInto: aStream].!

asReferenceAsCodeStringArray

	| someModuleNames aModule |

	aModule := self module.
	someModuleNames := aModule isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aModule allModuleNamesArray].
	someModuleNames isEmpty ifFalse: [ someModuleNames := someModuleNames copyFrom: 2 to: someModuleNames size].

	^(Array with: self class refToTypeKindSymbol with: self name), someModuleNames!

asReferenceAsCodeStringNOCROn: theStream

	| aSep aModule |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	theStream nextPutAll: ' ( ';  nextPutAll: (self pcForV: self class refToTypeKindSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	aModule isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [ aModule allModuleNamesInto: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAsCodeStringNOCROn: theStream. 
	theStream cr.!

attributesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self attributesPrivate isNil not and: [ self attributesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class attributesPersistenceSymbol); cr
			].
			self attributesPrivate do:  [:anAttrib |
				anAttrib persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

firstPersistenceIndexType
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initAttributesFromValues: theValues 
	
	| someAttributes |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someAttributes := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someAttributes isNil ifFalse: [ 
		self attributesPrivate addAll: someAttributes.
		someAttributes do: [:aC | aC typePrivate: self]]!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexType.

	self forzeIsAbstract:	 					(theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]).
	self forzeIsEnumeration:	 				(theValues size < (aFPI + 1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 1)]).
	self forzeIsPrimitive:						(theValues size < (aFPI + 2) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 2)]).
	self forzeStoreClassName: 				(theValues size < (aFPI + 3) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 3)]). 
	self forzeStoreMethodSelector: 			(theValues size < (aFPI + 4) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 4)]). 
	self forzeReengineredClassName:		(theValues size < (aFPI + 5) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 5)]). 
	self forzeIsExclussion:	 				(theValues size < (aFPI + 6) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 6)]).
	self forzeIsVirtual:						(theValues size < (aFPI + 7) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 7)]).
	self forzeIsHomeRooted:					(theValues size < (aFPI + 8) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 8)]).
	self forzeIsHomeIDProvider:				(theValues size < (aFPI + 9) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 9)]).
	self forzePrimitiveInitializationString:		(theValues size < (aFPI + 10) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 10)]).



	theValues size < (aFPI + 11) ifFalse: [  self initReferencedSuperTypesFromValues: (theValues at: (aFPI + 11)) ].
	theValues size < (aFPI + 12) ifFalse: [ self initAttributesFromValues: (theValues at: (aFPI + 12))].
	theValues size < (aFPI + 13) ifFalse: [ self initRelationshipsFromValues: (theValues at: (aFPI + 13)) ].
	theValues size < (aFPI + 14) ifFalse: [ self initOperationsFromValues: (theValues at: (aFPI + 14)) ].
	theValues size < (aFPI + 15) ifFalse: [ self initTypesFromValues: (theValues at: (aFPI + 15)) ].

	self forzeIsUse:	 						(theValues size < (aFPI + 16) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 16)]).!

initOperationsFromValues: theValues 
	
	| someOperations |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someOperations := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someOperations isNil ifFalse: [ 
		self operationsPrivate addAll: someOperations.
		someOperations do: [:aC | aC typePrivate: self]]!

initReferencedSuperTypesFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class superTypesPersistenceSymbol ifFalse: [ ^nil].

	superTypesRefsTmpValues := theValues.!

initRelationshipsFromValues: theValues 
	
	| someRelationships |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someRelationships := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someRelationships isNil ifFalse: [ 
		self relationshipsPrivate addAll: someRelationships.
		someRelationships do: [:aR | aR typePrivate: self]]!

initTypesFromValues: theValues
	
	| someTypes |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someTypes := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someTypes isNil ifFalse: [ 
		self typesPrivate addAll: someTypes.
		someTypes do: [:aC | aC modulePrivate: self]]!

inner: theIsInner persistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| aSep aNewStream aNewChunk |

	aSep := self separatorForPersistenceAsCode.
		
	aNewStream :=  nil.
	aNewChunk := nil.

	theIsInner
		ifTrue: [ 
			self mustStore 
				ifFalse: [ 
					theStream isNil ifFalse: [ 
						theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self kind);  
							nextPutAll: aSep; nextPutAll: self name printString; cr].
					self localValuesPersistenceAsCodeStringChunks: theCollection 
						on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.
					theStream isNil ifFalse: [ theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr]
				]
				ifTrue: [ 
					self persistenceRefToMethodAsCodeStringOn: theStream indent: theIS.
					theDoSubChunks ifTrue: [ 

						(self mustStoreWithFilter: theFilter) ifTrue: [ 
							aNewStream := WriteStream on: (String new: self subPartsSize * 256).
							aNewChunk := Array with: self with: aNewStream.
							theCollection add: aNewChunk
						].
						self inner: false persistenceAsCodeStringChunks: theCollection 
							on: aNewStream filter: theFilter indent: self indentStringForPersistenceAsCode 
							doSubChunks: theDoSubChunks
					]
				]
		]
		ifFalse: [ 
			theStream isNil ifFalse: [ 
				theStream nextPutAll: theIS; nextPutAll: '#( ';  nextPutAll: (self pcForV: self kind);  
					nextPutAll: aSep; nextPutAll: self name printString; cr].
			self localValuesPersistenceAsCodeStringChunks: theCollection 
				on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.
			theStream isNil ifFalse: [ theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr]
		]!

localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isAbstract ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isEnumeration ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isPrimitive ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self storeClassName );  nextPutAll: aSep; 
		nextPutAll: (self pcForV:  self storeMethodSelector ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self reengineredClassName );  cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  isExclussion ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isVirtual ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeRooted ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeIDProvider );cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self primitiveInitializationString ); cr.


	self referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS.
	self attributesPersistenceAsCodeStringOn: theStream indent: theIS.
	self relationshipsPersistenceAsCodeStringOn: theStream indent: theIS.
	self operationsPersistenceAsCodeStringOn: theStream indent: theIS.

	(self typesPrivate isNil not and: [ self typesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	   	  		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class typesPersistenceSymbol); cr
			].
			self typesPrivate do:  [:aType |
				aType inner: true persistenceAsCodeStringChunks: theCollection on: theStream 
					filter: theFilter indent: anIS , self indentStringForPersistenceAsCode doSubChunks: theDoSubChunks
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
	].

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isUse ); cr!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

self halt: 'This method should not be invoked on CODEPort, but rather #localValuesPersistenceAsCodeStringChunks:on:filter:indent:doSubChunks:'.

self shouldNotImplement.

	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isAbstract ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isEnumeration ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isPrimitive ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self storeClassName );  nextPutAll: aSep; 
		nextPutAll: (self pcForV:  self storeMethodSelector ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self reengineredClassName );  cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self  isExclussion ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isVirtual ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeRooted ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeIDProvider );cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self primitiveInitializationString ); cr.


	self referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS.
	self attributesPersistenceAsCodeStringOn: theStream indent: theIS.
	self relationshipsPersistenceAsCodeStringOn: theStream indent: theIS.
	self operationsPersistenceAsCodeStringOn: theStream indent: theIS.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isUse ); cr!

mustStore

	^self storeMethodSelector isNil not and: [ 
		self storeMethodSelector isEmpty not and: [ 
			self storeClassName isNil not and: [ 
				self storeClassName isEmpty not]]]!

numberPersistenceEntriesType
	^17!

operationsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self operationsPrivate isNil not and: [ self operationsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class operationsPersistenceSymbol); cr
			].
			self operationsPrivate do:  [:anAttrib |
				anAttrib persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

persistenceAsCodeString

	| aCollection |

	aCollection := self persistenceAsCodeStringChunksFilter: true doSubChunks: false.
	(aCollection isNil or: [ aCollection isEmpty]) ifTrue: [ ^nil].

	^aCollection first at: 2!

persistenceRefToMethodAsCodeStringOn: theStream indent: theIS

	| aSep |
	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
		
	theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self class refToTypeMethodKind);  
		nextPutAll: aSep; nextPutAll: self name printString;  
		nextPutAll: aSep; nextPutAll: (self pcForV: self storeMethodSelector); nextPutAll: aSep; nextPutAll: (self pcForV: self storeClassName);  
		nextPutAll: ' )' ; cr; cr.!

ph2InitFromSolver: theSolver
	super ph2InitFromSolver: theSolver.

(self module name = 'CategoryPage' and: [ self name = 'Body']) ifTrue: [ self halt: 'Body in CategoryPage'].

	self ph2InitReferencedSuperTypesValuesFromSolver: theSolver.
	self attributesPrivate do: [:aType | aType ph2InitFromSolver: theSolver].	
	self relationshipsPrivate do: [:aType | aType ph2InitFromSolver: theSolver].
	self typesPrivate do: [:aType | aType ph2InitFromSolver: theSolver].!

ph2InitReferencedSuperTypesValuesFromSolver: theSolver
	
	| someTypes |

	(superTypesRefsTmpValues isNil or: [ superTypesRefsTmpValues isEmpty]) ifTrue: [ ^self].

	someTypes := 
		CODEElement resolveOrNewReferencedTypesCollectionFromPersistenceAsCode: superTypesRefsTmpValues  solver: theSolver.
	self superTypesPrivate  addAll: someTypes.
	someTypes do: [:aC | aC subTypesPrivate add: self].

	superTypesRefsTmpValues := nil!

referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self superTypesPrivate isNil not and: [ self superTypesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil); cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	    	 			nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class superTypesPersistenceSymbol); cr
			].
			self superTypesPrivate do:  [:aType |
				aType asReferenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

relationshipsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self relationshipsPrivate isNil not and: [ self relationshipsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class relationshipsPersistenceSymbol); cr
			].
			self relationshipsPrivate do:  [:aRel |
				aRel persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

resolveOrNewReferencedAspectName: theName elementNames: theElementNames
	| anElementName someElementNames anAttributeName anAttribute aRelationshipName aRelationship |
	theName isNil ifTrue: [ ^nil].
 
	(theElementNames isNil or: [ theElementNames isEmpty]) ifTrue: [
		^self resolveOrNewReferencedAspectName: theName
	].

	anElementName := theElementNames first.

	anElementName = self class qualifiedNameAttributeStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		anAttributeName := theElementNames at: 2. 
		anAttribute := self attributeNamed: anAttributeName.
		anAttribute isNil ifTrue: [ ^nil].
		someElementNames := theElementNames copyFrom: 2 to: theElementNames size.
		anAttribute resolveOrNewReferencedAspectName: theName elementNames: someElementNames	
	].

	anElementName = self class qualifiedNameRelationshipStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		aRelationshipName := theElementNames at: 2. 
		aRelationship := self typeNamed: aRelationshipName.
		aRelationship isNil ifTrue: [ ^nil].
		theElementNames size < 3 ifTrue: [ ^aRelationship].
		someElementNames := theElementNames copyFrom: 3 to: theElementNames size.
		aRelationship resolveOrNewReferencedAspectName: theName elementNames: someElementNames	
	].

	^nil!

resolveOrNewReferencedAttributeNamed: theName

	| anAttribute |

	theName isNil ifTrue: [ ^nil].

	anAttribute := self resolveReferencedAttributeNamed: theName.
	anAttribute isNil ifFalse: [ ^anAttribute].

	anAttribute := self preferredAttributeClass new name: theName.
	self attributesAdd: anAttribute.
	^anAttribute!

resolveOrNewReferencedElementName: theName elementNames: theElementNames
	| anElementName anAttributeName anAttribute aRelationshipName aRelationship |
	theName isNil ifTrue: [ ^nil].
 
	(theElementNames isNil or: [ theElementNames isEmpty]) ifTrue: [
		^self
	].

	anElementName := theElementNames first.

	anElementName = self class qualifiedNameAttributeStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		anAttributeName := theElementNames at: 2. 
		anAttribute := self attributeNamed: anAttributeName.
		^anAttribute	
	].

	anElementName = self class qualifiedNameRelationshipStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		aRelationshipName := theElementNames at: 2. 
		aRelationship := self typeNamed: aRelationshipName.
		^aRelationship
	].

	^nil!

resolveOrNewReferencedOperationNamed: theName

	| anOperation |

	theName isNil ifTrue: [ ^nil].

	anOperation := self resolveReferencedOperationNamed: theName.
	anOperation isNil ifFalse: [ ^anOperation].

	anOperation := self preferredOperationClass new name: theName.
	self attributesAdd: anOperation.
	^anOperation!

resolveOrNewReferencedRelationshipNamed: theName

	| aRel |

	theName isNil ifTrue: [ ^nil].

	aRel := self resolveReferencedRelationshipNamed: theName.
	aRel isNil ifFalse: [ ^aRel].

	aRel := self preferredRelationshipClass new name: theName.
	self relationshipsAdd: aRel.
	^aRel!

resolveOrNewReferencedRelationshipNamed: theName forInverseType: theType

	| aRel |

	theName isNil ifTrue: [ ^nil].

	aRel := self resolveReferencedRelationshipNamed: theName forInverseType: theType.
	aRel isNil ifFalse: [ ^aRel].

	aRel := self preferredRelationshipClass new name: theName.
	self relationshipsAdd: aRel.
	^aRel!

resolveOrNewReferencedTypeName: theName
	| aType |

	theName isNil ifTrue: [ ^nil].

	aType := self typeNamed: theName.
	aType isNil ifFalse: [ ^aType].

	aType := self preferredTypeClass new name: theName.
	self typesAdd: aType.
	^aType!

resolveReferencedAttributeNamed: theName
	| anAttribute |

	theName isNil ifTrue: [ ^nil].

	anAttribute := self attributeNamed: theName.
	^anAttribute!

resolveReferencedOperationNamed: theName
	| anOperation |

	theName isNil ifTrue: [ ^nil].

	anOperation := self operationNamed: theName.
	^anOperation!

resolveReferencedRelationshipNamed: theName
	| aRelationship |

	theName isNil ifTrue: [ ^nil].

	aRelationship := self relationshipNamed: theName.
	^aRelationship!

resolveReferencedRelationshipNamed: theName forInverseType: theType
	| aRefToTypeValues anExistingRelationship someRelationshipsSameName |

	theName isNil ifTrue: [ ^nil].

	someRelationshipsSameName := OrderedCollection new: 8.
	self relationships do: [:aRel | 
		aRel name = theName ifTrue: [ someRelationshipsSameName add: aRel]
	].

	someRelationshipsSameName isEmpty ifTrue:  [ ^nil].
	someRelationshipsSameName size = 1 ifTrue: [ ^someRelationshipsSameName first].


	aRefToTypeValues := theType asReferenceAsCodeStringArray.
	anExistingRelationship := someRelationshipsSameName detect: [:aRel |  | aRelRefToTypeValues |
		aRelRefToTypeValues := aRel referencedInverseRefToTypeValues.
		aRelRefToTypeValues = aRefToTypeValues] ifNone: [ nil].
	anExistingRelationship isNil ifTrue: [ self halt].

	^anExistingRelationship!

resolveReferencedTypeName: theName
	| aType |

	theName isNil ifTrue: [ ^nil].

	aType := self typeNamed: theName.
	^aType! !

!CODEPort publicMethodsFor: 'primitive types'!

primitiveBroker

	| aNonVirtualType |

	primitiveBroker isNil ifFalse: [ ^primitiveBroker].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^nil].

	aNonVirtualType isPrimitive ifFalse: [ ^nil].

	aNonVirtualType == self ifFalse:  [ ^aNonVirtualType primitiveBroker].

	primitiveBroker := self preferredSystemPrimitiveBrokerClass primitiveBrokerForType: self.
	^primitiveBroker!

resetPrimitiveBroker

	primitiveBroker := nil! !

!CODEPort publicMethodsFor: 'semantic checking'!

checkIsAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsHomeRooted: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsPrimitive: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsUse: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkModel: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkModule: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSubTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSubTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSuperTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSuperTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEPort publicMethodsFor: 'semantic links'!

moduleCandidates
	"Generated by ISF/AD. Do not modify"
	^self module isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self module]!

moduleCreate
	"Generated by ISF/AD. Do not modify"
	^CODEModule new!

moduleLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self moduleCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self module: anObject]!

moduleLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self moduleCandidates
		initially: self module
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self module: anObject.!

moduleLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self moduleCandidates
		initially: self module
		label: 'Select Or Create ...'
		class: self moduleCreate class
		ifUnchanged: [^self].
	self module: anObject!

moduleScope
	"Generated by ISF/AD. Do not modify"
	^nil!

subTypesCandidates
	"Generated by ISF/AD. Do not modify"
	^self subTypes asArray!

subTypesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEPort new!

subTypesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self subTypesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self subTypesAdd: anObject]!

subTypesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self subTypesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self subTypesAdd: anObject.!

subTypesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self subTypesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self subTypesCreate class
		ifUnchanged: [^self].
	self subTypesAdd: anObject!

subTypesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

superTypeScope
	"Generated by ISF/AD. Do not modify"
	^nil!

superTypesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEPort new!

superTypesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self superTypesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self superTypesAdd: anObject.!

superTypesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self superTypesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self superTypesCreate class
		ifUnchanged: [^self].
	self superTypesAdd: anObject!

superTypesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typesCandidates
	"Generated by ISF/AD. Do not modify"
	^self types asArray!

typesCreate
	^self preferredTypeClass new!

typesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self typesAdd: anObject]!

typesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self typesAdd: anObject.!

typesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self typesCreate class
		ifUnchanged: [^self].
	self typesAdd: anObject!

typesScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEPort publicMethodsFor: 'semantic links-custom'!

superTypesCandidates
	
	| aModel someSubTypes someTypes someCandidateTypes someSuperTypes |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].

	someSubTypes := self withAllSubtypes.
	someTypes := aModel allTypes.
	someSuperTypes := self withAllSuperTypes.
	someTypes removeAll: someSuperTypes.

	someCandidateTypes := OrderedCollection new: someTypes size - someSubTypes size - 1.
	someTypes do: [:aType |
		((aType == self) not and: [ (someSubTypes includes: aType) not])  ifTrue: [ 
			someCandidateTypes add: aType
		]
	].
	^someCandidateTypes!

superTypesLinkCreate

	| someTypes aSelectedType aModel aNLSSolver aNLSItem aThisNLSItem |

	someTypes := self superTypesCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as SuperType of Type\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedType := Dialog 
		choose: ('							Please, select a Type as SuperType of Type							\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ') ', aType allContainerNamespaceNames ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	self superTypesAdd: aSelectedType.


	(Dialog confirm: 'Do you want to use the SuperType ItemTranslation?' initialAnswer: true) ifTrue: [ 

		aModel := self model.
		aModel isNil ifFalse: [ 
			aNLSSolver := aModel nlsSolver.
			aNLSSolver isNil ifFalse: [ 
				aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedType nlsAppName 
					group: aSelectedType nameNLSGroupName item: aSelectedType nameNLSItemName.
				aNLSItem isNil ifFalse: [
					aThisNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: self nlsAppName 
						group: self nameNLSGroupName item: self nameNLSItemName.
					aThisNLSItem isNil ifTrue: [ 
						aThisNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: self nlsAppName group: self nameNLSGroupName
							item: self nameNLSItemName translation: self name
					].
					(aThisNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
						aThisNLSItem usedItemTranslationsAdd: aNLSItem.
						self changed: #itemTranslations
					]
				]
			]
		]
	].

	self changed: #name.

	^aSelectedType! !

!CODEPort publicMethodsFor: 'updating refinements'!

updateRefinedFeatures

	self updateRefinedFeaturesHere.
	self subTypes do: [:aType | aType updateRefinedFeatures]!

updateRefinedFeaturesHere

	| someAllFeatures someOwnAttributes someOwnRelationships someOwnFeatures someInheritedFeaturesPropagatingUse    |

	someAllFeatures := self allEffectiveStructuralFeatures.
	someOwnAttributes := self attributes.
	someOwnRelationships := self relationships.

	someOwnFeatures := IdentitySet new: ((someOwnAttributes size + someOwnRelationships size) * 1.5) floor.
	someOwnFeatures addAll: someOwnAttributes ; addAll: someOwnRelationships.

	someInheritedFeaturesPropagatingUse := someAllFeatures select: [:aFeature |
		((someOwnFeatures includes: aFeature) not and: [ aFeature isRefinementRequired and: [  aFeature isPropagateUse not]])
	].

	someInheritedFeaturesPropagatingUse isEmpty ifTrue: [ ^self].
	
	someInheritedFeaturesPropagatingUse do: [:aFeature |  
		| aValueType aRefinedAttribute  aRelatedType aRefinedRelationship anInverse aRefinedInverseRelationship |

		aFeature isAttribute ifTrue: [
			aValueType := aFeature valueType.
			aValueType isNil ifFalse: [ 
				aRefinedAttribute := self preferredAttributeRefinementClass new name: aFeature name.
				aRefinedAttribute type: self.
				aRefinedAttribute valueType: aValueType.
				aRefinedAttribute forzeIsPropagateUse: false.
				aRefinedAttribute forzeIsJustUsed: false.
				aRefinedAttribute forzeIsRefinementRequired: true.

				aRefinedAttribute refinedAttributesAdd: aFeature.

				aRefinedAttribute initTerminalMetaAttributesFrom: aFeature.
			]
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [
			anInverse := aFeature inverse.
			anInverse isNil ifFalse: [ 
				aRelatedType := aFeature relatedType.
				aRelatedType isNil ifFalse: [ 
					aRefinedRelationship := self preferredRelationshipRefinementClass new name: aFeature name.
					aRefinedRelationship type: self.
					aRefinedRelationship relatedType: aRelatedType.
					aRefinedRelationship forzeIsPropagateUse: false.
					aRefinedRelationship forzeIsJustUsed: false.
					aRefinedRelationship forzeIsRefinementRequired: true.

					aRefinedInverseRelationship := self preferredRelationshipRefinementClass new name: anInverse name.
					aRefinedInverseRelationship type: aRelatedType.
					aRefinedInverseRelationship relatedType: self.
					aRefinedInverseRelationship forzeIsPropagateUse: false.
					aRefinedInverseRelationship forzeIsJustUsed: false.
					aRefinedInverseRelationship forzeIsRefinementRequired: anInverse isRefinementRequired.

					aRefinedRelationship inverse: aRefinedInverseRelationship.
				
					aRefinedRelationship refinedRelationshipsAdd: aFeature.
					aRefinedInverseRelationship refinedRelationshipsAdd: anInverse.

					aRefinedRelationship initTerminalMetaAttributesFrom: aFeature.
					aRefinedInverseRelationship initTerminalMetaAttributesFrom: anInverse.

				]
			]
		] ifFalse: [ 
		]]
	].! !

!CODEPort publicMethodsFor: 'updating uses'!

updateUses

	self updateUsesHere.
	self subTypes do: [:aType | aType updateUses]!

updateUsesHere

	| someAllFeatures someOwnAttributes someOwnRelationships someOwnFeatures someInheritedFeaturesPropagatingUse    |

	self isUse ifFalse: [ ^self].

	someAllFeatures := self allEffectiveStructuralFeatures.
	someOwnAttributes := self attributes.
	someOwnRelationships := self relationships.

	someOwnFeatures := IdentitySet new: ((someOwnAttributes size + someOwnRelationships size) * 1.5) floor.
	someOwnFeatures addAll: someOwnAttributes ; addAll: someOwnRelationships.

	someInheritedFeaturesPropagatingUse := someAllFeatures select: [:aFeature |
		((someOwnFeatures includes: aFeature) not and: [ aFeature isPropagateUse and: [ aFeature isRefinementRequired not]])
	].

	someInheritedFeaturesPropagatingUse isEmpty ifTrue: [ ^self].
	
	someInheritedFeaturesPropagatingUse do: [:aFeature |  
		| someLocalTypes aValueType aRefinedValueType aRefinedAttribute 
		 aRelatedType aRefinedRelatedType aRefinedRelationship anInverse aRefinedInverseRelationship |

		someLocalTypes := self types.
		aFeature isAttribute ifTrue: [
			aValueType := aFeature valueType.
			aValueType isNil ifFalse: [ 
				aRefinedValueType := someLocalTypes detect: [:aLocalType |
					aLocalType superTypesIncludes: aValueType ] ifNone: [ nil].
				aRefinedValueType isNil ifTrue: [ 
					aRefinedValueType := self preferredTypeClass new name: aValueType name.
					self typesAdd: aRefinedValueType.
					aRefinedValueType isUse: true.
					aRefinedValueType forzeIsJustUsed: true.
					aRefinedValueType superTypesAdd: aValueType
				].
				aRefinedAttribute := self preferredAttributeRefinementClass new name: aFeature name.
				aRefinedAttribute type: self.
				aRefinedAttribute valueType: aRefinedValueType.
				aRefinedAttribute forzeIsPropagateUse: true.
				aRefinedAttribute forzeIsJustUsed: true.
				aRefinedAttribute forzeIsRefinementRequired: false.

				aRefinedAttribute refinedAttributesAdd: aFeature.

				aRefinedAttribute initTerminalMetaAttributesFrom: aFeature.
			]
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [
			anInverse := aFeature inverse.
			anInverse isNil ifFalse: [ 
				aRelatedType := aFeature relatedType.
				aRelatedType isNil ifFalse: [ 
					aRefinedRelatedType := someLocalTypes detect: [:aLocalType |
						aLocalType superTypesIncludes: aRelatedType ] ifNone: [ nil].
					aRefinedRelatedType isNil ifTrue: [ 
						aRefinedRelatedType := self preferredTypeClass new name: aRelatedType name.
						self typesAdd: aRefinedRelatedType.
						aRefinedRelatedType isUse: true.
						aRefinedRelatedType forzeIsJustUsed: true.
						aRefinedRelatedType superTypesAdd: aRelatedType
					].
					aRefinedRelationship := self preferredRelationshipRefinementClass new name: aFeature name.
					aRefinedRelationship type: self.
					aRefinedRelationship relatedType: aRefinedRelatedType.
					aRefinedRelationship forzeIsPropagateUse: true.
					aRefinedRelationship forzeIsJustUsed: true.
					aRefinedRelationship forzeIsRefinementRequired: false.

					aRefinedInverseRelationship := self preferredRelationshipRefinementClass new name: anInverse name.
					aRefinedInverseRelationship type: aRefinedRelatedType.
					aRefinedInverseRelationship relatedType: self.
					aRefinedInverseRelationship forzeIsPropagateUse: false.
					aRefinedInverseRelationship forzeIsJustUsed: true.
					aRefinedInverseRelationship forzeIsRefinementRequired: false.

					aRefinedRelationship inverse: aRefinedInverseRelationship.
				
					aRefinedRelationship refinedRelationshipsAdd: aFeature.
					aRefinedInverseRelationship refinedRelationshipsAdd: anInverse.

					aRefinedRelationship initTerminalMetaAttributesFrom: aFeature.
					aRefinedInverseRelationship initTerminalMetaAttributesFrom: anInverse.

				]
			]
		] ifFalse: [ 
		]]
	].! !

!CODEReengine class publicMethodsFor: 'instance creation'!

new
	^self basicNew initialize! !

!CODEReengine publicMethodsFor: 'accessing'!

classPrefixes
	^classPrefixes!

classPrefixes: theValue
	classPrefixes := theValue.
	self changed: #classPrefixes!

factoryForAttribute
	^factoryForAttribute!

factoryForAttribute: theFactory
	factoryForAttribute := theFactory.
	self changed: #factoryForAttribute!

factoryForComment
	^factoryForComment!

factoryForComment: theFactory
	factoryForComment := theFactory.
	self changed: #factoryForComment!

factoryForModel
	^factoryForModel!

factoryForModel: theFactory
	factoryForModel := theFactory.
	self changed: #factoryForModel!

factoryForModule
	^factoryForModule!

factoryForModule: theFactory
	factoryForModule := theFactory.
	self changed: #factoryForModule!

factoryForParameter
	^factoryForParameter!

factoryForParameter: theFactory
	factoryForParameter := theFactory.
	self changed: #factoryForParameter!

factoryForRelationship
	^factoryForRelationship!

factoryForRelationship: theFactory
	factoryForRelationship := theFactory.
	self changed: #factoryForRelationship!

factoryForType
	^factoryForType!

factoryForType: theFactory
	factoryForType := theFactory.
	self changed: #factoryForType!

name
	^name!

name: theValue
	name := theValue.
	self changed: #name! !

!CODEReengine publicMethodsFor: 'initialize-release'!

initialize

	super initialize! !

!CODEReengine publicMethodsFor: 'reengineering'!

nameForReenClass: theClass
	| aName  somePrefixes |
	theClass isNil ifTrue:  [ ^nil].
	aName := theClass name.
	
	somePrefixes := self classPrefixes.
	somePrefixes isNil ifFalse: [ 
		somePrefixes do: [:aPrefix |
			(aPrefix isNil not and: [ aPrefix isEmpty not and: [ 
				(aName copyFrom: 1 to: (aPrefix size min: aName size)) = aPrefix]]) ifTrue: [ 
					aName := aName copyFrom: aPrefix size + 1 to: aName size.
					^aName
			]
		]
	].

	^aName!

nameForReenInstVar: theInstVarName
	| |

	theInstVarName isNil ifTrue:  [ ^nil].
	^theInstVarName!

newAttributeNamed: theName
	
	| aFactory anAttribute |
	aFactory := self factoryForAttribute.
	aFactory isNil ifTrue: [ ^nil].
	anAttribute := aFactory new name: theName.
	^anAttribute!

newTypeNamed: theName
	
	| aFactory aType |
	aFactory := self factoryForType.
	aFactory isNil ifTrue: [ ^nil].
	aType := aFactory new name: theName.
	^aType!

reengineClass: theClass onModule: theModule 
	| aName aType someInstVarNames |
	theClass isNil ifTrue: [ ^nil].
	theModule isNil ifTrue: [ ^nil].

	aName := self nameForReenClass: theClass.
	aType := theModule typeNamed: aName.
	aType isNil ifTrue: [ 
		aType := self newTypeNamed: aName.
		aType isNil ifTrue: [ ^nil].
		aType reengineredClassName: theClass name.
		theModule typesAdd: aType.
		self registerClass: theClass withType: aType.
	].

	someInstVarNames := theClass instVarNames.
	someInstVarNames do: [:anInstVarName |
		self reengineInstVarNamed: anInstVarName inType: aType
	].

	^aType!

reengineClassAndSubClasses: theClass onModule: theModule  including: theClasses
	| aType someSubClasses |
	theClass isNil ifTrue: [ ^nil].
	theModule isNil ifTrue: [ ^nil].

	aType := self reengineClass: theClass onModule: theModule.
	aType isNil ifTrue: [ ^nil].

	someSubClasses := theClass subclasses select: [:aClass | theClasses includes: aClass].
	someSubClasses do: [:aClass | | aSubType |
		aSubType := self reengineClassAndSubClasses: aClass onModule: theModule including: theClasses.
		aSubType isNil ifFalse: [  aType subTypesAdd: aSubType]
	].

	^aType!

reengineFromRootClass: theClass onModule: theModule  including: theClasses
	| aType someSubClasses |
	theClass isNil ifTrue: [ ^nil].
	theModule isNil ifTrue: [ ^nil].

	aType := self reengineClass: theClass onModule: theModule.
	aType isNil ifTrue: [ ^nil].

	someSubClasses := aType subclasses select: [:aClass | theClasses includes: aClass].
	someSubClasses do: [:aClass | | aSubType |
		aSubType := self reengineClassAndSubClasses: theClass onModule: theModule including: theClasses.
		aSubType isNil ifFalse: [  aType subTypesAdd: aSubType]
	].!

reengineInstVarNamed: theInstVarName inType: theType

	| aName anAttrib |
	theInstVarName isNil ifTrue: [ ^nil].
	theType isNil ifTrue: [ ^nil].

	aName := self nameForReenInstVar: theInstVarName.
	anAttrib := theType attributeNamed: aName.
	anAttrib isNil ifTrue: [ 
		anAttrib := self newAttributeNamed: aName.
		anAttrib isNil ifTrue: [ ^nil].
		anAttrib reengineredInstVarName: theInstVarName.
		theType attributesAdd: anAttrib.
	].! !

!CODEReengine publicMethodsFor: 'reengineering-private'!

classesToTypesDict
	classesToTypesDict isNil ifTrue: [ classesToTypesDict := IdentityDictionary new: 37].
	^classesToTypesDict!

registerClass: theClass withType: theType
	theClass isNil ifTrue: [ ^nil].
	theType isNil ifTrue: [ ^nil].

	self classesToTypesDict at: theClass put: theType!

registeredTypeForClass: theClass 
	| aType |
	theClass isNil ifTrue: [ ^nil].

	aType  := self classesToTypesDict at: theClass ifAbsent: [ nil].
	^aType! !

!CODERelationship class publicMethodsFor: 'accessing'!

kind
	^#relationship! !

!CODERelationship class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODERelationship class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		 self modelEditorMETAPerspectivesRelationship, super modelEditorMETAPerspectives, 
			self modelEditorMETAPerspectivesTranslation, self modelEditorMETAPerspectivesConstraints!

modelEditorMETAPerspectivesConstraints
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Constraints'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'IsExclussion' 'IsChangeable' 'IsDuplicatesAllowed' 'IsNameRelationship' 'IsInitializationPropagationAllowed' 'IsInitializationPropagationOnConnectAllowed' 'ComputationKind' 'OrderConstraint' 'CandidatesPath' 'CandidatesConstraint' 'InitializationExpression' 'ReengineredInstVarName')))
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Perspectives';
			nlsItem: 'Constraints';
			nlsTranslation: 'Constricciones';
			yourself);
		yourself!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'IsDirty' 'IsAbstract'  'RelationshipKind' 'MinMult' 'MaxMult'  'IsPropagateUse' 'IsJustUsed' 'IsRefinementRequired')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesRelationship
 
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RelatedType'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'RelatedType' )))
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Perspectives';
			nlsItem: 'RelatedType';
			nlsTranslation: 'TipoRelacionado';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Inverse'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Inverse' )))
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Perspectives';
			nlsItem: 'Inverse';
			nlsTranslation: 'RelacionInversa';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RelationshipRefinements'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'RelationshipRefinements' )))
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Perspectives';
			nlsItem: 'RelationshipRefinements';
			nlsTranslation: 'RelacionesRefinadas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Type'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Type')))
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Perspectives';
			nlsItem: 'Type';
			nlsTranslation: 'Tipo';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Dependencies'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Dependencies' )))
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Perspectives';
			nlsItem: 'Dependencies';
			nlsTranslation: 'Observadores';
			yourself);
		yourself!

modelEditorMETAPerspectivesTranslation
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Traducciones'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('NLSName' 'NLSKind' 'NLSNameOne' 'NLSAppName' 'NLSGroupName' 'NLSItemName' 'NLSItemNameOne')))
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Perspectives';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'Traducciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'ItemTranslations'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('ItemTranslations')))
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Perspectives';
			nlsItem: 'ItemTranslations';
			nlsTranslation: 'ElementosDeTraduccion';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsRelationship,
		self modelEditorMETASelectorsTranslation, self modelEditorMETASelectorsMoreTranslation!

modelEditorMETASelectorsMoreTranslation

	"METAChildSpecAutoViewEditor openOn: CODEElement selector: #modelEditorMETASelectorsTranslation target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 5)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSItemNameOne';
			basicSelector: #nameNLSItemNameOne;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSItemNameOne';
			nlsTranslation: 'NombreItemTraduccionSingular';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'NLSNameOne';
			basicSelector: #nlsNameOne;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'NLSNameOne';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Translation_Selectors';
			nlsItem: 'NLSNameOne';
			nlsTranslation: 'TraduccionSingular';
			yourself);
		yourself!

modelEditorMETASelectorsRelationship

	"METAChildSpecAutoViewEditor openOn: CODERelationship selector: #modelEditorMETASelectorsRelationship target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 8)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelationshipKind';
			basicSelector: #relationshipKind;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelationshipKind';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: 'AGGREGATES isAGGREGATED REFERENCES';
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'RelationshipKind';
			nlsTranslation: 'ClaseDeRelacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MinMult';
			basicSelector: #minMult;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MinMult';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: '0 1 2 *';
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'MinMult';
			nlsTranslation: 'NumeroMinimoDeElementos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'MaxMult';
			basicSelector: #maxMult;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'MaxMult';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: '0 1 2 *';
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'MaxMult';
			nlsTranslation: 'NumeroMaximoDeElementos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPropagateUse';
			basicSelector: #isPropagateUse;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPropagateUse';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'IsPropagateUse';
			nlsTranslation: 'EsPropagacionDeUso';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsJustUsed';
			basicSelector: #isJustUsed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsJustUsed';
			displaySelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'IsJustUsed';
			nlsTranslation: 'EsSoloUsado';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsRefinementRequired';
			basicSelector: #isRefinementRequired;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsRefinementRequired';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'IsRefinementRequired';
			nlsTranslation: 'Requiere Especializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsChangeable';
			basicSelector: #isChangeable;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsChangeable';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'IsChangeable';
			nlsTranslation: 'EsModificable';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsDuplicatesAllowed';
			basicSelector: #isDuplicatesAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsDuplicatesAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relatioinship_Selectors';
			nlsItem: 'IsDuplicatesAllowed';
			nlsTranslation: 'PermiteDuplicados';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsNameRelationship';
			basicSelector: #isNameRelationship;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsNameRelationship';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relatioinship_Selectors';
			nlsItem: 'IsNameRelationship';
			nlsTranslation: 'EsParteDelNombre';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsInitializationPropagationAllowed';
			basicSelector: #isInitializationPropagationAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsInitializationPropagationAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'IsInitializationPropagationAllowed';
			nlsTranslation: 'PropagacionInitializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsInitializationPropagationOnConnectAllowed';
			basicSelector: #isInitializationPropagationOnConnectAllowed;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsInitializationPropagationOnConnectAllowed';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'IsInitializationPropagationOnConnectAllowed';
			nlsTranslation: 'PropagacionOnConnectInitializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ComputationKind';
			basicSelector: #computationKind;
			type: #Enum;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ComputationKind';
			displaySelector: nil;
			canShowInTree: true;
			enumValuesString: 'NOCOMPUTATION ALWAYS  INITIALVALUE INITIALIZEDINCONSTRUCTOR AFTERCONNECTION   FROMHOMEIDCOUNTER';
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'ComputationKind';
			nlsTranslation: 'ClaseDeComputacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'OrderConstraint';
			basicSelector: #orderConstraint;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'OrderConstraint';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'OrderConstraint';
			nlsTranslation: 'ConstriccionDeOrden';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'CandidatesPath';
			basicSelector: #candidatesPath;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'CandidatesPath';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'CandidatesPath';
			nlsTranslation: 'CaminoACandidatos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'CandidatesConstraint';
			basicSelector: #candidatesConstraint;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'CandidatesConstraint';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'CandidatesConstraint';
			nlsTranslation: 'ConstriccionDeCandidatos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'InitializationExpression';
			basicSelector: #initializationExpression;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'InitializationExpression';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'InitializationExpression';
			nlsTranslation: 'ExpressionDeInicializacion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReengineredInstVarName';
			basicSelector: #reengineredInstVarName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ReengineredInstVarName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'ReengineredInstVarName';
			nlsTranslation: 'ReengineredInstVarName';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelatedType';
			basicSelector: #relatedType;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelatedType';
			displaySelector: #name;
			canShowInTree: true;
			objectClassName: #CODEType;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'RelatedType';
			nlsTranslation: 'TipoRelacionado';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Inverse';
			basicSelector: #inverse;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Inverse';
			displaySelector: #relationshipName;
			canShowInTree: true;
			objectClassName: #CODERelationship;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'Inverse';
			nlsTranslation: 'RelacionInversa';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelationshipRefinements';
			basicSelector: #relationshipRefinements;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelationshipRefinements';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'RelationshipRefinements';
			nlsTranslation: 'RelacionesRefinadas';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Type';
			basicSelector: #type;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Type';
			displaySelector: #name;
			canShowInTree: true;
			objectClassName: #CODEType;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'Type';
			nlsTranslation: 'Tipo';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Dependencies';
			basicSelector: #dependencies;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Dependencies';
			displaySelector: #displayName;
			canShowInTree: true;
			componentsClassName: #CMTypeDependency;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Relationship_Selectors';
			nlsItem: 'Dependencies';
			nlsTranslation: 'Dependencias';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsRelationship.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsRelationship

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('RelatedType' 'Inverse' 'RelationshipRefinements' 'Type' 'Dependencies')! !

!CODERelationship class publicMethodsFor: 'refinements'!

refinableMetaAttributeNames
	^#(
		#kind:
		#minMult:
		#maxMult:
		#derived:
		#dummy:
		#isAbstract:
		#reengineredInstVarName:
		#isExclussion:
		#orderConstraint:
		#candidatesPath:
		#candidatesConstraint:
		#initializationExpression:
		#computationKind:
		#isChangeable:
		#isDuplicatesAllowed:
		#isNameRelationship:
		#isInitializationPropagationAllowed:
		#isInitializationPropagationOnConnectAllowed:
	) copy! !

!CODERelationship class publicMethodsFor: 'testing'!

isAggregationRelationshipKind: theRelationshipKind
	^theRelationshipKind = self aggregationRelationshipKind! !

!CODERelationship publicMethodsFor: 'accessing'!

bmgrOutFileName
	"Generated by ISF/AD. Do not modify"
	bmgrOutFileName isNil
		ifTrue: [self initBmgrOutFileName].
	^bmgrOutFileName!

candidatesConstraint
	candidatesConstraint isNil
		ifTrue: [self initCandidatesConstraint].
	^candidatesConstraint!

candidatesConstraint: aValue
	
	(self checkCandidatesConstraint: aValue) ifFalse: [^aValue].
	candidatesConstraint := aValue.
	self markDirty.

	self updateRefinements: #candidatesConstraint: value: aValue.

	self changed: #candidatesConstraint!

candidatesPath
	candidatesPath isNil
		ifTrue: [self initCandidatesPath].
	^candidatesPath!

candidatesPath: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkCandidatesPath: aValue) ifFalse: [^aValue].
	candidatesPath := aValue.
	self markDirty.

	self updateRefinements: #candidatesPath: value: aValue.

	self changed: #candidatesPath!

computationKind
	computationKind isNil
		ifTrue: [self initComputationKind].
	^computationKind!

computationKind: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkComputationKind: aValue) ifFalse: [^aValue].
	computationKind := aValue.
	self markDirty.

	self updateRefinements: #computationKind: value: aValue.

	self changed: #computationKind!

derived
	"Generated by ISF/AD. Do not modify"
	derived isNil
		ifTrue: [self initDerived].
	^derived!

derived: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDerived: aValue) ifFalse: [^aValue].
	derived := aValue.
	self markDirty.

	self updateRefinements: #derived: value: aValue.

	self changed: #derived!

dummy
	"Generated by ISF/AD. Do not modify"
	dummy isNil
		ifTrue: [self initDummy].
	^dummy!

dummy: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDummy: aValue) ifFalse: [^aValue].
	dummy := aValue.
	self markDirty.

	self updateRefinements: #dummy: value: aValue.

	self changed: #dummy!

initializationExpression
	"Generated by ISF/AD. Do not modify"
	initializationExpression isNil
		ifTrue: [self initInitializationExpression].
	^initializationExpression!

initializationExpression: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkInitializationExpression: aValue  == true) ifFalse: [^aValue].
	initializationExpression := aValue.
	self markDirty.

	self updateRefinements: #initializationExpression: value: aValue.

	self changed: #initializationExpression!

inverseName
	^self inverse isNil ifTrue: [nil] ifFalse: [ self inverse name]!

isAbstract
	"Generated by ISF/AD. Do not modify"
	isAbstract isNil
		ifTrue: [self initIsAbstract].
	^isAbstract!

isAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsAbstract: aValue  == true) ifFalse: [^aValue].
	isAbstract := aValue == true.
	self markDirty.

	self updateRefinements: #isAbstract: value: aValue.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #isAbstract!

isChangeable
	"Generated by ISF/AD. Do not modify"
	isChangeable isNil
		ifTrue: [self initIsChangeable].
	^isChangeable!

isChangeable: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsChangeable: aValue) ifFalse: [^aValue].
	isChangeable := aValue == true.
	self markDirty.

	self updateRefinements: #isChangeable: value: aValue.

	self changed: #isChangeable!

isDuplicatesAllowed
	"Generated by ISF/AD. Do not modify"
	isDuplicatesAllowed isNil
		ifTrue: [self initIsDuplicatesAllowed].
	^isDuplicatesAllowed!

isDuplicatesAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsDuplicatesAllowed: aValue  == true) ifFalse: [^aValue].
	isDuplicatesAllowed := aValue == true.
	self markDirty.

	self updateRefinements: #isDuplicatesAllowed: value: aValue.

	self changed: #isDuplicatesAllowed!

isExclussion
	"Generated by ISF/AD. Do not modify"
	isExclussion isNil
		ifTrue: [self initIsExclussion].
	^isExclussion!

isExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	isExclussion := aValue.

	self markDirty.

	self updateRefinements: #isExclussion: value: aValue.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #isExclussion!

isInitializationPropagationAllowed
	"Generated by ISF/AD. Do not modify"
	isInitializationPropagationAllowed isNil
		ifTrue: [self initIsInitializationPropagationAllowed].
	^isInitializationPropagationAllowed!

isInitializationPropagationAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsInitializationPropagationAllowed: aValue  == true) ifFalse: [^aValue].
	isInitializationPropagationAllowed := aValue == true.
	self markDirty.

	self updateRefinements: #isInitializationPropagationAllowed: value: aValue.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #isInitializationPropagationAllowed!

isInitializationPropagationOnConnectAllowed
	"Generated by ISF/AD. Do not modify"
	isInitializationPropagationOnConnectAllowed isNil
		ifTrue: [self initIsInitializationPropagationOnConnectAllowed].
	^isInitializationPropagationOnConnectAllowed!

isInitializationPropagationOnConnectAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsInitializationPropagationOnConnectAllowed: aValue  == true) ifFalse: [^aValue].
	isInitializationPropagationOnConnectAllowed := aValue == true.
	self markDirty.

	self updateRefinements: #isInitializationPropagationOnConnectAllowed: value: aValue.

	self changed: #isInitializationPropagationOnConnectAllowed!

isJustUsed
	"Generated by ISF/AD. Do not modify"
	isJustUsed isNil
		ifTrue: [self initIsJustUsed].
	^isJustUsed!

isJustUsed: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsJustUsed: aValue) ifFalse: [^aValue].
	isJustUsed := aValue == true.

	self changed: #isJustUsed!

isNameRelationship
	"Generated by ISF/AD. Do not modify"
	isNameRelationship isNil
		ifTrue: [self initIsNameRelationship].
	^isNameRelationship!

isNameRelationship: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsNameRelationship: aValue  == true) ifFalse: [^aValue].
	isNameRelationship := aValue == true.
	self markDirty.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #isNameRelationship!

isPropagateUse
	"Generated by ISF/AD. Do not modify"
	isPropagateUse isNil
		ifTrue: [self initIsPropagateUse].
	^isPropagateUse!

isPropagateUse: aValue
	"Generated by ISF/AD. Do not modify"
	| anInverse |
	(self checkIsPropagateUse: aValue) ifFalse: [^aValue].
	isPropagateUse := aValue == true.
	self markDirty.

	self invalidateEffectiveRelationshipsCaches.

	self updateUses.
	
	anInverse := self inverse.
	anInverse isNil ifFalse: [ anInverse isPropagateUse: (aValue == true) not].

	self changed: #isPropagateUse!

isRefinementRequired
	"Generated by ISF/AD. Do not modify"
	isRefinementRequired isNil
		ifTrue: [self initIsRefinementRequired].
	^isRefinementRequired!

isRefinementRequired: aValue
	(self checkIsRefinementRequired: aValue) ifFalse: [^aValue].
	self isRefinementRequired = aValue ifTrue: [^aValue].
	isRefinementRequired := aValue == true.
	self markDirty.

	self updateRefinedFeatures.

	self changed: #isRefinementRequired!

maxMult
	"Generated by ISF/AD. Do not modify"
	maxMult isNil
		ifTrue: [self initMaxMult].
	^maxMult!

maxMult: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMaxMult: aValue) ifFalse: [^aValue].
	maxMult := aValue.

	self markDirty.

	self updateRefinements: #maxMult: value: aValue.

	self changed: #maxMult!

minMult
	"Generated by ISF/AD. Do not modify"
	minMult isNil
		ifTrue: [self initMinMult].
	^minMult!

minMult: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMinMult: aValue) ifFalse: [^aValue].
	minMult := aValue.
	self markDirty.

	self updateRefinements: #minMult: value: aValue.

	self changed: #minMult!

name: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkName: aValue) ifFalse: [^aValue].
	name := aValue.
	self markDirty.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #name!

orderConstraint
	orderConstraint isNil
		ifTrue: [self initOrderConstraint].
	^orderConstraint!

orderConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOrderConstraint: aValue) ifFalse: [^aValue].
	orderConstraint := aValue.
	self markDirty.

	self updateRefinements: #orderConstraint: value: aValue.

	self changed: #orderConstraint!

reengineredInstVarName
	^reengineredInstVarName!

reengineredInstVarName: theValue
	(self checkReengineredInstVarName: theValue) ifFalse: [^theValue].
	reengineredInstVarName := theValue.
	self markDirty.

	self updateRefinements: #reengineredInstVarName: value: theValue.

	self changed: #reengineredInstVarName!

relatedConstraint
	^nil!

relationshipKind
	"Generated by ISF/AD. Do not modify"
	kind isNil
		ifTrue: [self initKind].
	^kind!

relationshipKind: aValue
	
	(self checkKind: aValue) ifFalse: [^aValue].
	kind := aValue.
	self inverse isNil ifFalse: [ 
		(kind = self class aggregatesRelationshipKind and: [ 
			(self inverse relationshipKind = self class isAggregatedRelationshipKind) not])
		 ifTrue: [ self inverse relationshipKind: self class  isAggregatedRelationshipKind].
		(kind = self class isAggregatedRelationshipKind and: [ 
			(self inverse relationshipKind = self class aggregatesRelationshipKind) not])
		 ifTrue: [ self inverse relationshipKind: self class  aggregatesRelationshipKind].
		(kind = self class referencesRelationshipKind and: [ 
			(self inverse relationshipKind = self class referencesRelationshipKind) not])
		 ifTrue: [ self inverse relationshipKind: self class  referencesRelationshipKind].
	].
	self markDirty.

	self updateRefinements: #reengineredInstVarName: value: aValue.

	self changed: #relationshipKind!

relationshipName
	| aName aType aTypeName |
	aName := self name.
	aName isNil ifTrue: [ aName := 'anon'].
	aType := self type.
	aTypeName := aType isNil ifTrue: [  'no type'] ifFalse: [ aType name].
	^ aName , ' in ', aTypeName! !

!CODERelationship publicMethodsFor: 'accessing-private'!

forzeCandidatesConstraint: aValue
	candidatesConstraint := aValue!

forzeCandidatesPath: aValue
	candidatesPath := aValue!

forzeComputationKind: aValue
	computationKind :=  aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeInitializationExpression: aValue
	initializationExpression := aValue!

forzeIsAbstract: aValue
	isAbstract := aValue == true.!

forzeIsChangeable: aValue
	isChangeable := aValue == true.!

forzeIsDuplicatesAllowed: aValue
	isDuplicatesAllowed := aValue == true.!

forzeIsExclussion: aValue
	isExclussion := aValue == true.!

forzeIsInitializationPropagationAllowed: aValue
	isInitializationPropagationAllowed := aValue == true.!

forzeIsInitializationPropagationOnConnectAllowed: aValue
	isInitializationPropagationOnConnectAllowed := aValue == true.!

forzeIsJustUsed: aValue
	isJustUsed := aValue == true.!

forzeIsNameRelationship: aValue
	isNameRelationship := aValue == true.!

forzeIsPropagateUse: aValue
	isPropagateUse := aValue == true.!

forzeIsRefinementRequired: aValue
	isRefinementRequired := aValue == true.!

forzeKind: aValue
	kind := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeMaxMult: aValue
	maxMult := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeMinMult: aValue
	minMult :=  aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].!

forzeOrderConstraint: aValue
	orderConstraint := aValue!

forzeReengineredInstVarName: aValue
	reengineredInstVarName := aValue.!

forzeRelationshipKind: aValue
	kind := aValue isNil ifTrue: [ nil] ifFalse: [ aValue asSymbol].! !

!CODERelationship publicMethodsFor: 'association initialize-release'!

initRelationshipRefinements
	"Generated by ISF/AD. Do not modify"
	relationshipRefinements := OrderedCollection new.!

inverseRelease
	"Generated by ISF/AD. Do not modify"
	inverse == nil
			ifFalse:
				 [inverse inversePrivate: nil.
				inverse := nil.
				self changed: #inverse]!

relatedTypeRelease
	"Generated by ISF/AD. Do not modify"
	relatedType == nil
		ifFalse:
			[relatedType relatedWithPrivateRemove: self.
				relatedType := nil.
				self changed: #relatedType]!

relationshipRefinementsRelease
	"Generated by ISF/AD. Do not modify"
	self relationshipRefinements do: [:each | self relationshipRefinementsRemove: each]!

reverseRelease
	"Generated by ISF/AD. Do not modify"
	reverse == nil
			ifFalse:
				 [reverse inversePrivate: nil.
				reverse := nil.
				self changed: #reverse]!

typeRelease
	"Generated by ISF/AD. Do not modify"
	type == nil
		ifFalse:
			[type relationshipsPrivateRemove: self.
				type := nil.
				self changed: #type]! !

!CODERelationship publicMethodsFor: 'associations accessing'!

inverse
	"Generated by ISF/AD. Do not modify"
	^inverse!

inverse: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkInverse: aValue) ifFalse: [^aValue].
	aValue == inverse
		ifFalse:
			[aValue isNil ifFalse: [aValue inverseRelease].
			self inverseRelease.
			inverse := aValue.
			inverse isNil ifFalse: [inverse inversePrivate: self].
	self invalidateEffectiveRelationshipsCaches.

			self changed: #inverse]!

relatedType
	"Generated by ISF/AD. Do not modify"
	^relatedType!

relatedType: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRelatedType: aValue) ifFalse: [^aValue].
	relatedType == aValue ifTrue: [ ^self].
	self relatedTypeRelease.
	relatedType := aValue.
	aValue == nil ifFalse: [aValue relatedWithPrivateAdd: self].
	self invalidateEffectiveRelationshipsCaches.

	self changed: #relatedType!

relationshipRefinements
	"Generated by ISF/AD. Do not modify"
	^self relationshipRefinementsPrivate copy!

relationshipRefinementsAsArray
	"Generated by ISF/AD. Do not modify"
	^self relationshipRefinements asArray!

reverse
	"Generated by ISF/AD. Do not modify"
	^reverse!

reverse: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkReverse: aValue) ifFalse: [^aValue].
	aValue == reverse
		ifFalse:
			[aValue isNil ifFalse: [aValue inverseRelease].
			self reverseRelease.
			reverse := aValue.
			reverse isNil ifFalse: [reverse inversePrivate: self].
	self invalidateEffectiveRelationshipsCaches.

			self changed: #reverse]!

type
	"Generated by ISF/AD. Do not modify"
	^type!

type: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkType: aValue) ifFalse: [^aValue].
	type == aValue ifTrue: [ ^self].
	self typeRelease.
	type := aValue.
	aValue == nil ifFalse: [aValue relationshipsPrivateAdd: self].
	type = nil ifTrue: [ self release].

	self changed: #type! !

!CODERelationship publicMethodsFor: 'associations modifying'!

relationshipRefinementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRelationshipRefinementsAdd: aValue) ifFalse: [^aValue].
	(self relationshipRefinementsIncludes: aValue) ifTrue: [^aValue].
	(self relationshipRefinementsPrivateAdd: aValue) refinedRelationshipsPrivateAdd: self.
	self changed: #relationshipRefinements.
	^aValue!

relationshipRefinementsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self relationshipRefinementsIncludes: aValue) ifFalse: [^aValue].
	(self relationshipRefinements indexOf: aValue) = self relationshipRefinementsSize ifTrue: [^aValue].
	self relationshipRefinementsPrivate remove: aValue.
	aRes := self relationshipRefinementsPrivateAdd: aValue.
	^aRes!

relationshipRefinementsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self relationshipRefinementsIncludes: aValue) ifFalse: [^aValue].
	(index := self relationshipRefinements indexOf: aValue) = self relationshipRefinementsSize ifTrue: [^aValue].
	index = (self relationshipRefinementsSize -1)
		ifTrue:
			[self relationshipRefinementsPrivate remove: aValue.
			aRes := self relationshipRefinementsPrivateAdd: aValue.
			self notifyChangeAllRelationshipRefinementsChildSpecs.
			^aRes].
	aRes := self relationshipRefinementsPrivateMove: aValue beforeIndex: index + 2.
	^aRes!

relationshipRefinementsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self relationshipRefinementsIncludes: aValue) ifFalse: [^aValue].
	(self relationshipRefinements indexOf: aValue) = 1 ifTrue: [^aValue].
	self relationshipRefinementsPrivateMove: aValue beforeIndex: 1.!

relationshipRefinementsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self relationshipRefinementsIncludes: aValue) ifFalse: [^aValue].
	(index := self relationshipRefinements indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self relationshipRefinementsPrivateMove: aValue beforeIndex: index - 1.
	^aRes!

relationshipRefinementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRelationshipRefinementsRemove: aValue) ifFalse: [^aValue].
	(self relationshipRefinementsPrivate remove: aValue ifAbsent: [^aValue]) refinedRelationshipsPrivateRemove: self.
	self changed: #relationshipRefinements.
	^aValue! !

!CODERelationship publicMethodsFor: 'associations private'!

forzeInverse: aValue
	inverse := aValue.!

forzeRelatedType: aValue
	relatedType := aValue.!

inversePrivate: aValue
	"Generated by ISF/AD. Do not modify"
	inverse := aValue.
	self changed: #inverse!

relatedTypePrivate: aValue
	"Generated by ISF/AD. Do not modify"
	relatedType := aValue.
	self changed: #relatedType!

relationshipRefinementsPrivate
	"Generated by ISF/AD. Do not modify"
	relationshipRefinements isNil
		ifTrue: [self initRelationshipRefinements].
	^relationshipRefinements!

relationshipRefinementsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self relationshipRefinementsPrivate add: aValue.
	self changed: #relationshipRefinements.
	^aValue!

relationshipRefinementsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self relationshipRefinements at: anIndex.
	self relationshipRefinementsPrivate remove: aValue.
	self relationshipRefinementsPrivate add: aValue before: obj.
	self changed: #relationshipRefinements.
	^aValue!

relationshipRefinementsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self relationshipRefinementsPrivate remove: aValue.
	self changed: #relationshipRefinements.
	^aValue!

reversePrivate: aValue
	"Generated by ISF/AD. Do not modify"
	reverse := aValue.
	self changed: #reverse!

typePrivate: aValue
	| aPrevValue |
	(type isNil and: [ aValue isNil]) ifTrue: [ ^self].
	aPrevValue := type.
	type := aValue.
	self changed: #type.
	(type isNil and: [ aPrevValue isNil not]) ifTrue: [ self release].! !

!CODERelationship publicMethodsFor: 'associations testing'!

relationshipRefinementsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^relationshipRefinements isNil
		ifTrue: [false]
		ifFalse: [self relationshipRefinements includes: aValue]!

relationshipRefinementsSize
	"Generated by ISF/AD. Do not modify"
	^relationshipRefinements isNil
		ifTrue: [0]
		 ifFalse: [relationshipRefinements size]! !

!CODERelationship publicMethodsFor: 'derivation expressions'!

candidateFactoryTypes
	
	| aRelatedType someCandidateFactoryTypes |

	self candidatePathAllowsCreate ifFalse: [ ^nil].

	aRelatedType := self relatedType.
	aRelatedType isNil ifTrue: [ ^nil].
	
	someCandidateFactoryTypes := aRelatedType candidateFactoryTypes.
	^someCandidateFactoryTypes!

candidatePathAllowsCreate
	
	| aCandidatesPath someStrings |

	aCandidatesPath := self candidatesPath.
	(aCandidatesPath isNil or: [ aCandidatesPath isEmpty]) ifTrue:  [ ^true].

	someStrings := aCandidatesPath asArrayOfSubstrings.
	someStrings size < 2 ifTrue: [ ^true].

	^someStrings first asSymbol = self class candidatesPathCreate!

candidateReferencedObjects: theObject
	^self candidateRelatedObjects: theObject!

candidateRelatedObjects: theObject
	
	| aCandidatesPath aDerivationPath aMetaInfo someCandidates someStrings somePotentialCandidates aNewExpression aStream aCalcResult aFirstIndex aCandidatesConstraint someConstrainedCandidates |
	theObject isNil ifTrue: [ ^nil].

	aCandidatesPath := self candidatesPath.
	(aCandidatesPath isNil or: [ aCandidatesPath isEmpty]) ifTrue:  [ ^nil].

	someStrings := aCandidatesPath asArrayOfSubstrings.
	someStrings size < 2 ifTrue: [ ^nil].

	aFirstIndex := someStrings first = '$self' ifTrue: [ 3] ifFalse: [ 2].
	aFirstIndex := (someStrings at: aFirstIndex) = '2' ifTrue: [ aFirstIndex + 1 ] ifFalse: [ aFirstIndex].

	(someStrings at: aFirstIndex)  asSymbol  =  self class initExpressionCalc 
		ifTrue: [
			aNewExpression := someStrings size = aFirstIndex 
				ifTrue: [ someStrings at: aFirstIndex] 
				ifFalse: [ 
					aStream := WriteStream on: (String new: 32 * (someStrings size - 1)).
					aFirstIndex to: someStrings size do: [:anIndex | 
						anIndex > aFirstIndex ifTrue: [ aStream space].
						aStream nextPutAll: (someStrings at: anIndex)
					].
					aStream contents
				].

			aCalcResult := theObject metaInfo computeDerivedValueFrom: theObject calcExpression: aNewExpression.
			somePotentialCandidates := aCalcResult isNil ifTrue: [ nil] ifFalse: [ aCalcResult asArray "first"].
		]
		ifFalse: [ 
			(someStrings at: aFirstIndex)  asSymbol =  self class initExpressionExtent  
				ifTrue: [ 
					aMetaInfo := self relatedType.
					aMetaInfo isNil ifTrue: [ ^nil].

					somePotentialCandidates := aMetaInfo extentFromObject: theObject includeSubTypes: true.
				]
				ifFalse: [ 

					aDerivationPath := someStrings copyFrom: aFirstIndex to: someStrings size.
					aDerivationPath isEmpty ifTrue: [ ^nil].

					aMetaInfo := theObject metaInfo.
					aMetaInfo isNil ifTrue: [ ^nil].

					somePotentialCandidates := aMetaInfo object: theObject derive: aDerivationPath clone: false.
				]
		].

	(somePotentialCandidates isNil or: [ somePotentialCandidates isEmpty]) ifTrue:  [ ^nil].

	someCandidates := somePotentialCandidates select: [:anObject | 
		self relatedIsTypeOfObjectInstance: anObject
	].
	(someCandidates isNil or: [ someCandidates isEmpty]) ifTrue:  [ ^nil].

	aCandidatesConstraint := self candidatesConstraint.
	(aCandidatesConstraint isNil or: [ aCandidatesConstraint isEmpty]) ifTrue:  [ ^someCandidates].

	someConstrainedCandidates := someCandidates select: [:anObject | | aConstraintResult |
		aConstraintResult  := anObject metaInfo computeDerivedValueFrom: anObject expression: aCandidatesConstraint.
		aConstraintResult isNil not and: [ (aConstraintResult isKindOf: Collection) and: [  
			(aConstraintResult isKindOf: String) not and: [ aConstraintResult isEmpty not and: [ aConstraintResult first == true]]]]
	].
	(someConstrainedCandidates isNil or: [ someConstrainedCandidates isEmpty]) ifTrue:  [ ^nil].

	^someConstrainedCandidates!

cloneObject: theObject into: theNewObject
	self isMultiplicityMany
		ifTrue:  [ self cloneObjectMany: theObject into: theNewObject]
		ifFalse: [ self cloneObjectOne: theObject into: theNewObject]!

cloneObjectMany: theObject into: theNewObject

	|   someRelatedObjects |

	theObject isNil ifTrue: [ ^self].
	theNewObject isNil ifTrue: [ ^self].

	someRelatedObjects := self getObjectFeatureValueTC: theObject.
	(someRelatedObjects isNil or: [ someRelatedObjects isEmpty]) ifTrue: [ ^self].

	someRelatedObjects do: [:aRelatedObject  |   |   aRelatedObjectMetaInfo aNewValue |
	
		aRelatedObjectMetaInfo := aRelatedObject metaInfo.
		aRelatedObjectMetaInfo  isNil ifFalse: [
	
			self isAggregation
				ifTrue: [ 
					aNewValue := aRelatedObjectMetaInfo cloneObject: aRelatedObject.
					aNewValue isNil ifFalse: [ 
						self object: theNewObject setTC: aNewValue
					]
				]
				ifFalse: [ 
					self inverse isAggregation ifTrue: [ ^self].
					self inverse isMultiplicityMany ifFalse: [ ^self].
					self object: theNewObject setTC: aNewValue
				]
		]
	]!

cloneObjectOne: theObject into: theNewObject

	| aNonVirtualType aNewValue aRelatedObject aRelatedObjectType aRelatedObjectMetaInfo |

	theObject isNil ifTrue: [ ^self].
	theNewObject isNil ifTrue: [ ^self].

	aRelatedObject := self getObjectFeatureValueTC: theObject.
	aRelatedObject isNil ifTrue: [ ^self].

	aRelatedObjectType := self referencedType.
	aRelatedObjectType isNil ifTrue: [ ^self].

	aNonVirtualType := aRelatedObjectType nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^self].
	
	aRelatedObjectMetaInfo := aRelatedObject metaInfo.
	aRelatedObjectMetaInfo  isNil ifTrue: [ ^self]. 
	
	self isAggregation
		ifTrue: [ 
			aNewValue := aRelatedObjectMetaInfo cloneObject: aRelatedObject.
			aNewValue isNil ifFalse: [ 
				self object: theNewObject setTC: aNewValue
			]
		]
		ifFalse: [ 
			self inverse isAggregation ifTrue: [ ^self].
			self inverse isMultiplicityMany ifFalse: [ ^self].
			self object: theNewObject setTC: aNewValue
		]!

computeObjectRelationshipValue: theObject
	| aInitExpression someStrings aClone aDerivationPath aMetaInfo aValue |
	theObject isNil ifTrue: [ ^nil].

	aInitExpression := self initializationExpression.
	(aInitExpression isNil or: [ aInitExpression isEmpty]) ifTrue: [ ^nil].

	someStrings := aInitExpression asArrayOfSubstrings.
	someStrings  size < 2 ifTrue: [ ^self].

	aClone := someStrings first =  self class initExpressionCloneTrue.

	aDerivationPath := someStrings copyFrom: 2 to: someStrings size.
	aDerivationPath isEmpty ifTrue: [ ^self].

	aMetaInfo := theObject metaInfo.
	aMetaInfo isNil ifTrue: [ ^self].

	aValue := aMetaInfo object: theObject derive: aDerivationPath clone: aClone.
	^aValue! !

!CODERelationship publicMethodsFor: 'derivations cache'!

invalidateEffectiveRelationshipsCaches
	
	| aInverse |
	self invalidateThisEffectiveRelationshipsCaches.

	aInverse := self inverse.
	aInverse isNil ifTrue:  [ ^self].

	aInverse invalidateThisEffectiveRelationshipsCaches!

invalidateThisEffectiveRelationshipsCaches
	
	| aType |

	aType := self type.
	aType isNil ifTrue:  [ ^self].

	aType invalidateEffectiveRelationshipsCaches! !

!CODERelationship publicMethodsFor: 'derived accessing'!

allRefinedRelationshipsInto: theSet

	(theSet includes: self) ifTrue: [ ^self].

	theSet add: self.!

applicationConfiguration
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type applicationConfiguration]!

displayNameWithTypeAndRelatedType
	^self name, '   :  ', self typeName, '  ->  ', self relatedTypeName!

fullyQualifiedName

	| aFullyQualifiedName aTypeFullyQualifiedName |
	self type isNil ifTrue: [ ^self name].
	
	aTypeFullyQualifiedName := self type fullyQualifiedName.
	(aTypeFullyQualifiedName isNil or: [ aTypeFullyQualifiedName isEmpty]) ifTrue: [ 
		^self name
	].

	aFullyQualifiedName := aTypeFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

isAggregated
	^self relationshipKind asSymbol = self  class isAggregatedRelationshipKind!

isAggregation
	^self relationshipKind asSymbol = self  class aggregationRelationshipKind!

isDerivedOrInverseDerived
	^self derived or: [ self inverse isNil not and: [ self inverse derived]]!

isInverseDerived
	^self inverse isNil not and: [ self inverse derived]!

isManyRelationship
	^(self maxMult = #'1'  or: [self maxMult = #'0']) not!

isMultiplicityMany
	^self maxMult = self class maxMultMany or: [ self maxMult = self class maxMultTwo]!

isMultiplicityNone
	^self maxMult = self class maxMultNone!

isMultiplicityOne
	^self maxMult = self class maxMultOne!

isOrdered
	^self isSorted not!

isReferences
	^self relationshipKind asSymbol = self  class referencesRelationshipKind!

isSorted
	^self orderConstraint isNil not and:  [  self orderConstraint isEmpty not and: [ self orderConstraint asArrayOfSubstrings isEmpty not]]!

isVisibleInModules: 		theModules
	andAspects: 			theAspects
	definitionsHolder: 	theDefinitionsHolder

	((theModules isNil or: [ theModules isEmpty]) and: [  
		theAspects isNil or: [ theAspects isEmpty]]) ifTrue: [ 
		^true
	].

	^(  self isVisibleInModules: 	theModules definitionsHolder: 	theDefinitionsHolder) and: [ 
		self isVisibleInAspects: 	theAspects definitionsHolder: 	theDefinitionsHolder
	]!

isVisibleInModules: 		theModules
	definitionsHolder: 	theDefinitionsHolder


	| aThisModule |

	(theModules isNil or: [ theModules isEmpty]) ifTrue: [ ^true ].

	(theModules isNil not and: [ theModules isEmpty not]) ifTrue: [ 
		aThisModule := self module.
		aThisModule isNil ifTrue: [ ^false].
		(theModules includes: aThisModule) ifFalse: [ 
			(theModules detect: [:aModule | aModule includesModule: aModule] ifNone: [ nil]) isNil ifTrue: [ ^false]
		]
	].!

model
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type model]!

module
	^self type isNil 
		ifTrue: [ nil]
		ifFalse: [ self type module]!

referencedType
	^self relatedType!

relatedTypeName
	^self relatedType isNil ifTrue: [ 'unknown_relatedType' copy] ifFalse: [ self relatedType name]!

skip
	^(self type isNil not and: [self type skip]) or: [self relatedType isNil not and: [self relatedType skip]]!

typeName
	^self type isNil ifTrue: [ 'unknown_type' copy] ifFalse: [ self type name]!

typePrefix
	^self type isNil ifTrue: [ nil] ifFalse: [ self type typePrefix]!

withAllRefinedRelationships
	| someRelationships |
	someRelationships := IdentitySet new: 13.
	self withAllRefinedRelationshipsInto: someRelationships.
	
	^someRelationships!

withAllRefinedRelationshipsInto: theRelationships

	theRelationships isNil ifTrue: [ ^self].
	(theRelationships includes: self) ifTrue: [ ^self]. 
	theRelationships add: self.! !

!CODERelationship publicMethodsFor: 'dirty'!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self type isNil ifFalse: [ self type markDirtyOwner]
	].!

persistIfDirty
	^self type isNil ifFalse: [ self type persistIfDirty] ifTrue: [ nil]! !

!CODERelationship publicMethodsFor: 'generate'!

generateActions: theTemplateFileName forType: theType relatedConcreteType: theRelatedConcreteType

	| aTemplateStream aChunk aText aKey anExpansion aRelatedConcreteTypeName aChooserTreeConfigFactory anAllConcreteTypePackageNames |

	self skip ifTrue: [ ^self].

	theTemplateFileName isNil ifTrue: [ ^self].

	aRelatedConcreteTypeName := theRelatedConcreteType upperInitialName.
	aChooserTreeConfigFactory := theRelatedConcreteType expand: 'FullPrefixedChooserTreeConfigFactory'.
	anAllConcreteTypePackageNames := theRelatedConcreteType  allContainerPackageNames.


[
	aTemplateStream := theTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self bmgrOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'RelatedConcreteTypeName'
				ifTrue: [self bmgrOutStream nextPutAll: aRelatedConcreteTypeName] ifFalse: [
			aKey = 'AllConcreteTypePackageNames'
				ifTrue: [self bmgrOutStream nextPutAll: anAllConcreteTypePackageNames] ifFalse: [
			aKey = 'FullPrefixedRelatedConcreteTypeChooserTreeConfigFactory'
				ifTrue: [self bmgrOutStream nextPutAll: aChooserTreeConfigFactory] ifFalse: [
			aKey = 'FullMetaRelatedConcreteTypePrefixedClassName'
				ifTrue: [self bmgrOutStream nextPutAll: 
					(self relatedType module fullPackageName), '.meta.', 
					(self relatedType model typePrefix , self relatedType upperInitialName) , 'Meta'] ifFalse: [
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self bmgrOutStream nextPutAll: anExpansion]]]]]]
	].
	self bmgrOutStream cr;cr.
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateActionsInstantiation: theKind forType: theType relatedConcreteType: theRelatedConcreteType
"          // new EAIAction_$TypeName$_setNew_$RelationshipName$_$RelatedConcreteTypeName$( theNode),
"
	
	self skip ifTrue: [ ^self].

	self bmgrOutStream tab; tab; tab; nextPutAll: 
		'new EAIAction_', (self expand: 'TypeName'), '_', theKind , '_' , 
		self name, '_', theRelatedConcreteType upperInitialName, '( theNode),'; cr!

generateAddChosenActionsForType: theType

	| aRelatedType someTypes aTemplateFileName |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	aTemplateFileName := self templateFileNameForAction: 'AddChosen'.

	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self generateActions: aTemplateFileName forType: theType relatedConcreteType: aRelatedConcreteType].!

generateAddChosenActionsInstantiationForType: theType

	| aRelatedType someTypes  |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].


	aRelatedType := self relatedType.
	someTypes := aRelatedType withAllNonAbstractSubtypes.

	someTypes do: [:aRelatedConcreteType |
		self generateActionsInstantiation: 'addChosen' forType: theType relatedConcreteType: aRelatedConcreteType].!

generateAddChosenSeparateActionsForType: theType

	| aRelatedType someTypes aTemplateFileName |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	aTemplateFileName := self templateFileNameForSeparateAction: 'AddChosen'.

	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self generateSeparateActions: aTemplateFileName forType: theType relatedConcreteType: aRelatedConcreteType 
			actionKind: 'addChosen'].!

generateAddNewActionsForType: theType

	| aRelatedType someTypes aTemplateFileName |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	aTemplateFileName := self templateFileNameForAction: 'AddNew'.

	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self generateActions: aTemplateFileName forType: theType relatedConcreteType: aRelatedConcreteType].!

generateAddNewActionsInstantiationForType: theType

	| aRelatedType someTypes  |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].


	aRelatedType := self relatedType.
	someTypes := aRelatedType withAllNonAbstractSubtypes.

	someTypes do: [:aRelatedConcreteType |
		self generateActionsInstantiation: 'addNew' forType: theType relatedConcreteType: aRelatedConcreteType].!

generateAddNewSeparateActionsForType: theType

	| aRelatedType someTypes aTemplateFileName |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	aTemplateFileName := self templateFileNameForSeparateAction: 'AddNew'.

	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self generateSeparateActions: aTemplateFileName forType: theType relatedConcreteType: aRelatedConcreteType 
			actionKind: 'addNew'].!

generateBaseImplementationForType: theType

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |


	self skip ifTrue: [ ^self].

	(self dummy and: [ self isInverseDerived]) ifTrue: [ ^self].

	aTemplateFileName :=  self derived 
		ifTrue: [ self templateFileNameForDerivedRelationshipFor: 'base']
		ifFalse: [ self templateFileNameFor: 'base'].
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType baseOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType baseOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateBaseStorageDefinitionForType: theType


	| aClassName |
	self skip ifTrue: [ ^self].

	self isDerivedOrInverseDerived  ifTrue: [ ^self].

	aClassName := self type isGenerationStyleDynamicReduced 
		ifTrue: [self expand: 'FullIfcRelatedTypePrefixedClassName']
		ifFalse: [self expand: 'FullPrivRelatedTypePrefixedClassName'].
	
	theType  baseOutStream 
		tab;
		nextPutAll: 'protected ';
		nextPutAll: aClassName;
		nextPutAll: (self isManyRelationship ifTrue: [ '[] '] ifFalse: [' ']);
		nextPutAll: (self expand: 'RelationshipVariableName').

	self isManyRelationship ifTrue: [ 
		theType  baseOutStream 
			nextPutAll: ' = new ';
			nextPutAll: aClassName;
			nextPutAll: '[0]'
	].
	theType  baseOutStream nextPutAll: '; '; cr; cr!

generateBmgrConfig

	| anStream someTypes |


	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	anStream := self wholeTreeConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab; nextPutAll: 'MMBranchClassNodesConfigIfc  a', 
			(self expand: 'TypeAndRelationshipName'), 'BCNC  = new MMBranchClassNodesConfig( a', 
				(self expand: 'TypeAndRelationshipName'),  'BMgr);'; cr.

			self relatedType isNil ifFalse: [ 
				someTypes := self relatedType withAllNonAbstractSubtypes.
				someTypes do: [:aType | aType generateClassNodeConfigOverrideForRelationship: self]
"    aPackage_packagesBCNC.addClassNodeConfigOverride(   new MMClassNodeConfigOverride( theCtxt.getMMFactory().getClassForType( theCtxt, 'Package'), aPackageNMgr, null ));
"
			].

		anStream tab; tab; nextPutAll: 'gConfig.addBranchClassNodesConfig( a', 
			(self expand: 'TypeAndRelationshipName'), 'BCNC);';cr ; cr.


	"MMBranchClassNodesConfigIfc  aProject_packagesBCNC = new MMBranchClassNodesConfig( aProject_packagesBMgr);
	aProject_packagesBCNC.addClassNodeConfigOverride(   new MMClassNodeConfigOverride( theCtxt.getMMFactory().getClassForType( theCtxt, 'Package'), aPackageNMgr, null ));
	gConfig.addBranchClassNodesConfig( aPackage_packagesBCNC);
"
	

	]!

generateBMgrForType: theType

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |


	self skip ifTrue: [ ^self].


	self mustGenerateBMgr ifFalse: [ ^self].

	aTemplateFileName := self templateFileNameForBMgr.
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self bmgrOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'AddNewActions'
				ifTrue: [ self generateAddNewActionsForType: theType] ifFalse: [
			aKey = 'AddChosenActions'
				ifTrue: [ self generateAddChosenActionsForType: theType] ifFalse: [
			aKey = 'SetNewActions'
				ifTrue: [ self generateSetNewActionsForType: theType] ifFalse: [
			aKey = 'SetChosenActions'
				ifTrue: [ self generateSetChosenActionsForType: theType] ifFalse: [
			aKey = 'AddNewActionsInstantiation'
				ifTrue: [ self generateAddNewActionsInstantiationForType: theType] ifFalse: [
			aKey = 'AddChosenActionsInstantiation'
				ifTrue: [ self generateAddChosenActionsInstantiationForType: theType] ifFalse: [
			aKey = 'SetNewActionsInstantiation'
				ifTrue: [ self generateSetNewActionsInstantiationForType: theType] ifFalse: [
			aKey = 'SetChosenActionsInstantiation'
				ifTrue: [ self generateSetChosenActionsInstantiationForType: theType] ifFalse: [
			aKey = 'SeparateActionsClassNames'
				ifTrue: [ self generateSeparateActionClassNamesForType: theType] ifFalse: [

			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self bmgrOutStream nextPutAll: anExpansion]]]]]]]]]]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
	bmgrOutStream isNil ifFalse: [ bmgrOutStream close. bmgrOutStream := nil].
]!

generateBmgrStaticDeclaration

	| anStream |


	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	anStream := self wholeTreeConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; nextPutAll: 'public static ', (self expand: 'FullPrefixedBMgrName'), 
			' a', (self expand: 'TypeAndRelationshipName'), 'BMgr  = new ', (self expand: 'FullPrefixedBMgrName'),  '();'; cr; cr.
	]!

generateBranchConfigOverrideForType: theType
	| anStream |


	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	anStream := self wholeTreeConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab; nextPutAll: 'a', theType upperInitialName , 
			'NBC.addBranchConfigOverride( new MMBranchConfigOverride( a' , 
			(self expand: 'TypeAndRelationshipName'), 'BMgr, null));'; cr.

	"aProjectNBC.addBranchConfigOverride( new MMBranchConfigOverride( aProject_packagesBMgr, null));"

	]!

generateIfcDeclarationForType: theType

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |


	self skip ifTrue: [ ^self].

	(self dummy and: [ self isInverseDerived]) ifTrue: [ ^self].

	aTemplateFileName :=  self derived 
		ifTrue: [ self templateFileNameForDerivedRelationshipFor: 'ifc']
		ifFalse: [ self templateFileNameFor: 'ifc'].
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType ifcOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType ifcOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateImplImplementationForType: theType

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |


	self skip ifTrue: [ ^self].

	(self dummy and: [ self isInverseDerived]) ifTrue: [ ^self].

	aTemplateFileName :=  self derived 
		ifTrue: [ self templateFileNameForDerivedRelationshipFor: 'impl']
		ifFalse: [ self templateFileNameFor: 'impl'].
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType implOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType implOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateImportsForRelatedMetamodelElements!

generateM3Phase1InitializationForType: theType


	| aStream |
	self skip ifTrue: [ ^self].
	aStream := theType  metaOutStream.

	aStream 
		tab; tab; nextPutAll: (self expand: 'MetaRelationshipVariableName'); nextPutAll: ' = (',
			self metaRelationshipFullIfcPrefixedClassName,') theCtxt.getMMFactory("', self type model m3FactoryName, 
			'").createMMElementOfType( theCtxt, "Relationship", "core",',
			'"', self name, '");';cr;
		tab; tab; nextPutAll: 'vm3Type.addRelationships( theCtxt, '; nextPutAll: (self expand: 'MetaRelationshipVariableName');
			nextPutAll: ');'; cr.

	self generateM3Phase1InitializationForType: theType setAttr: 'kind' value: self relationshipKind.
	self generateM3Phase1InitializationForType: theType setAttr: 'minMult' value: self minMult.
	self generateM3Phase1InitializationForType: theType setAttr: 'maxMult' value: self maxMult.
	self generateM3Phase1InitializationForType: theType setAttr: 'isDerived' value: self derived.
	self generateM3Phase1InitializationForType: theType setAttr: 'isDummy' value: self dummy.

	aStream cr.

   "

	vm3RelPackages = new com.d_a_t.eai.studio.m3.impl.EAIRelationshipImpl( new EAIMMName( 'Project'));
	vm3RelPackages.setKind( theCtxt, 'Aggregates');
	vm3RelPackages.setMinMult( theCtxt, '0');
	vm3RelPackages.setMaxMult( theCtxt, '*');
	vmM3Type.addRelationships( theCtxt, vm3RelPackages);
"!

generateM3Phase1InitializationForType: theType setAttr: theAttrName value: theValue 
	| aValue aStream |
	theValue isNil ifTrue: [ ^self].

	aValue := self toSetAttributeArgumentValue: theValue.

	aStream := theType  metaOutStream.

	aStream
		tab; tab;
		nextPutAll: (self expand: 'MetaRelationshipVariableName');
		nextPutAll: '.set';
		nextPutAll: (self toUpperInitial: theAttrName);
		nextPutAll: '( theCtxt, ';
		nextPutAll: aValue;
		nextPutAll: ');'; 
		cr!

generateM3Phase2InitializationForType: theType


	| aStream |
	self skip ifTrue: [ ^self].

	aStream := theType  metaOutStream.

	aStream 
		tab; tab; nextPutAll: (self expand: 'MetaRelationshipVariableName'); nextPutAll: '.setInverse( theCtxt, ';
			nextPutAll: (self inverse type expand: 'FullMetaPrefixedClassName'); 
			nextPutAll: '.' , (self inverse expand: 'MetaRelationshipVariableName');  nextPutAll: ');'; cr;

		tab; tab; nextPutAll: (self expand: 'MetaRelationshipVariableName'); nextPutAll: '.setRelatedType( theCtxt, ';
			nextPutAll: (self relatedType expand: 'FullMetaPrefixedClassName'); 
			nextPutAll: '.vm3Type);'; cr; cr.

   "
	vm3RelPackages.setInverse( theCtxt, EAIPackageBase.vm3RelProject);
	vm3RelPackages.setRelatedType( theCtxt, EAIProject.vm3Type);
"!

generateM3Phase2LocalStorageInitializationForType: theType


	| aStream |
	self skip ifTrue: [ ^self].

	aStream := theType  metaOutStream.

	aStream 
		tab; tab; nextPutAll: (self expand: 'MetaRelationshipVariableName'); nextPutAll: '.setInverse( theCtxt, ';
			nextPutAll: (self inverse type expand: 'FullMetaPrefixedClassName'); 
			nextPutAll: '.' , (self inverse expand: 'MetaRelationshipVariableName');  nextPutAll: ');'; cr;

		tab; tab; nextPutAll: (self expand: 'MetaRelationshipVariableName'); nextPutAll: '.setRelatedType( theCtxt, ';
			nextPutAll: (self relatedType expand: 'FullMetaPrefixedClassName'); 
			nextPutAll: '.vm3Type);'; cr; cr.

   "
	vm3RelPackages.setInverse( theCtxt, EAIPackageBase.vm3RelProject);
	vm3RelPackages.setRelatedType( theCtxt, EAIProject.vm3Type);
"!

generateM3Phase2MultiInheritedInitializationForType: theType

	| aStream |
	self skip ifTrue: [ ^self].

	aStream := theType  metaOutStream.

	aStream 
		tab; tab; nextPutAll: (self expand: 'MetaRelationshipVariableName'); 
		nextPutAll: ' = ';
		nextPutAll: (self type expand: 'FullMetaPrefixedClassName'); 
		nextPutAll: '.' , (self expand: 'MetaRelationshipVariableName');
		nextPutAll: ';'; cr; cr.

   "vm3RelOwnedInfoTypes = com.dosmil_e.kit.core.model.structural.base.KitInfoTypeOwnerBase.vm3RelOwnedInfoTypes;"!

generateM3RelationshipPhase1InitializationForType: theType setAttr: theAttrName value: theValue 
	| aValue aWriteStream aStream |
	theValue isNil ifTrue: [ ^self].

	aValue := (theValue isKindOf: String)
		ifTrue: [ '"' , theValue, '"']
		ifFalse: [
			(theValue isKindOf: Array)
				ifTrue: [
					aWriteStream := WriteStream on: (String new: 256).
					aWriteStream nextPutAll: ' new String[] { '.
					theValue do: [:anElem |
						anElem isNil ifFalse: [ 
							aWriteStream nextPutAll: 
								((theValue isKindOf: String) ifTrue: [ '"' , theValue, '"'] ifFalse: [ theValue printString ]).
							anElem == theValue last ifFalse: [ aWriteStream nextPutAll: ','].
						]		
					].
					aWriteStream nextPutAll: ' } '.
					aWriteStream contents.
				]
				ifFalse: [ theValue printString ]].

	aStream := theType  metaOutStream.

	aStream
		tab; tab;
		nextPutAll: ' vm3Type.set';
		nextPutAll: (self toUpperInitial: theAttrName);
		nextPutAll: '( theCtxt, ';
		nextPutAll: aValue;
		nextPutAll: '"));'; 
		cr!

generateM3StorageDefinitionForType: theType


	| aStream |
	self skip ifTrue: [ ^self].

	aStream := theType  metaOutStream.

	aStream 
		tab;
		nextPutAll: 'public static ';
		nextPutAll: self metaRelationshipFullIfcPrefixedClassName;
		nextPutAll: ' ';
		nextPutAll: (self expand: 'MetaRelationshipVariableName');
		nextPutAll: ';'; 
		cr; cr!

generatePortCreationForType: theType

"     newPort( 'Packages',    Integer.MAX_VALUE);
"
"     newPort( 'Project',    1);
"


	self skip ifTrue: [ ^self].

	theType  baseOutStream 
		nextPutAll: '    newPort("'; nextPutAll: (self expand: 'UpperRelationshipName'); nextPutAll: '", ';
	 		nextPutAll: (self isManyRelationship ifTrue: [ 'Integer.MAX_VALUE'] ifFalse: [ '1']); nextPutAll: ');'; cr.!

generatePortSynchChangeDetectionForType: theType

"    if( theRole.equals( 'Project')) {
	  syncPort( theCtxt, 'Project',           new EAIMMElementIfc[] { getProject( theCtxt)},  'Packages');
	  return;
	}
"
"    if( theRole.equals( 'Project')) {
	  syncPort( theCtxt, 'Packages',       getPackages( theCtxt),  'Project');
	  return;
	}
"

	self skip ifTrue: [ ^self].

	self isManyRelationship
		ifFalse: [ 
			theType  baseOutStream 
				nextPutAll: '    if( theRole.equals( "'; nextPutAll: (self expand: 'UpperRelationshipName'); nextPutAll: '")) {';cr;
	      		nextPutAll: '      syncPort( theCtxt, "'; nextPutAll: (self expand: 'UpperRelationshipName'); 
					nextPutAll: '", new EAIMMElementIfc[] { get'; nextPutAll: (self expand: 'UpperRelationshipName'); 
					nextPutAll: '( theCtxt)}, "'; nextPutAll: (self expand: 'UpperInverseRelationshipName'); nextPutAll: '");'; cr;
	 				nextPutAll: '      return;'; cr;
	   			nextPutAll: '    }'; cr
		]
		ifTrue: [ 
			theType  baseOutStream 
				nextPutAll: '    if( theRole.equals( "'; nextPutAll: (self expand: 'UpperRelationshipName'); nextPutAll: '")) {';cr;
	      		nextPutAll: '      syncPort( theCtxt, "'; nextPutAll: (self expand: 'UpperRelationshipName'); 
					nextPutAll: '", get'; nextPutAll: (self expand: 'UpperRelationshipName'); 
					nextPutAll: '( theCtxt), "'; nextPutAll: (self expand: 'UpperInverseRelationshipName'); nextPutAll: '");'; cr;
	 				nextPutAll: '      return;'; cr;
	   			nextPutAll: '    }'; cr
		]!

generatePrivDeclarationForType: theType

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |


	self skip ifTrue: [ ^self].

	(self dummy and: [ self isInverseDerived]) ifTrue: [ ^self].

	aTemplateFileName :=  self derived 
		ifTrue: [ self templateFileNameForDerivedRelationshipFor: 'priv']
		ifFalse: [ self templateFileNameFor: 'priv'].
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType privOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType privOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateRelationshipDeleteForType: theType
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	self skip ifTrue: [ ^self].

	self isDerivedOrInverseDerived  ifTrue: [ ^self].

	aTemplateFileName := self templateFileNameForDelete.
	aTemplateFileName isNil ifTrue: [ ^self].

	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType baseOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType baseOutStream nextPutAll: anExpansion]]
	]!

generateRemoveSeparateActionsForType: theType

	| aTemplateFileName aTypeName aFileName aPath anActionOutStream aTemplateStream aChunk aText aKey anExpansion |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].
	self isAggregation ifTrue: [ ^self].

	aTemplateFileName := self templateFileNameForSeparateAction: 'Remove'.

	aTypeName := theType upperInitialName.

	aFileName := (theType expand: 'TypePrefix') , aTypeName , '_',  self name, '_remove.java'.

	aFileName isNil ifTrue: [ ^nil].
	aPath := (self type module outputDirectoryWithPackageAndFolder: 'custommgrs'),
		(String with: Filename separator), aFileName.




[
	anActionOutStream := aPath asFilename writeStream.
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			anActionOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				anActionOutStream nextPutAll: anExpansion]]
	].
	anActionOutStream cr;cr.
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
	anActionOutStream isNil ifFalse: [ anActionOutStream close].
]!

generateSeparateActionClassNamesForType: theType

	| aRelatedType someTypes anActionKind |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	anActionKind := 	self isManyRelationship
		ifTrue: [ 
			self isAggregation ifTrue: [ 'addNew']
				ifFalse: [ 'addChosen']
		]
		ifFalse: [ 
			self isAggregation
				ifTrue: [ 'setNew']
				ifFalse: [ 'setChosen']
		].


	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self bmgrOutStream tab; tab; tab; tab; tab;
			nextPutAll: (self type expand: 'TypePrefix') , self type upperInitialName , '_', self name, '_', 
				anActionKind , '_', aRelatedConcreteType name , '.class,'; cr
	].!

generateSeparateActions: theTemplateFileName forType: theType relatedConcreteType: theRelatedConcreteType
	actionKind: theActionKind

	| aTemplateStream aChunk aText aKey anExpansion aRelatedConcreteTypeName aChooserTreeConfigFactory anAllConcreteTypePackageNames aTypeName aFileName aPath anActionOutStream |

	self skip ifTrue: [ ^self].

	theTemplateFileName isNil ifTrue: [ ^self].	

	aTypeName := theType upperInitialName.
	aRelatedConcreteTypeName := theRelatedConcreteType upperInitialName.
	aChooserTreeConfigFactory := theRelatedConcreteType expand: 'FullPrefixedChooserTreeConfigFactory'.
	anAllConcreteTypePackageNames := theRelatedConcreteType  allContainerPackageNames.

	aFileName := (theType expand: 'TypePrefix') , aTypeName , '_', self name, '_', 
		theActionKind , '_', aRelatedConcreteTypeName , '.java'.

	aFileName isNil ifTrue: [ ^nil].
	aPath := (self type module outputDirectoryWithPackageAndFolder: 'custommgrs'),
		(String with: Filename separator), aFileName.

[
	anActionOutStream := aPath asFilename writeStream.
	aTemplateStream := theTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			anActionOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'RelatedConcreteTypeName'
				ifTrue: [anActionOutStream nextPutAll: aRelatedConcreteTypeName] ifFalse: [
			aKey = 'AllConcreteTypePackageNames'
				ifTrue: [anActionOutStream nextPutAll: anAllConcreteTypePackageNames] ifFalse: [
			aKey = 'FullPrefixedRelatedConcreteTypeChooserTreeConfigFactory'
				ifTrue: [anActionOutStream nextPutAll: aChooserTreeConfigFactory] ifFalse: [
			aKey = 'FullMetaRelatedConcreteTypePrefixedClassName'
				ifTrue: [anActionOutStream nextPutAll: 
					(theRelatedConcreteType module fullPackageName), '.meta.', 
					(theRelatedConcreteType model typePrefix ,theRelatedConcreteType upperInitialName) , 'Meta'] ifFalse: [

			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				anActionOutStream nextPutAll: anExpansion]]]]]]
	].
	anActionOutStream cr;cr.
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
	anActionOutStream isNil ifFalse: [ anActionOutStream close].
]!

generateSeparateActionsForType: theType


	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	self isManyRelationship
		ifTrue: [ 
			self isAggregation
				ifTrue: [ 
					self generateAddNewSeparateActionsForType: theType.
				]
				ifFalse: [
					self generateAddChosenSeparateActionsForType: theType.
				]
		]
		ifFalse: [ 
			self isAggregation
				ifTrue: [ 
					self generateSetNewSeparateActionsForType: theType.
				]
				ifFalse: [
					self generateSetChosenSeparateActionsForType: theType.
				]
		].
	
	self generateRemoveSeparateActionsForType: theType.!

generateSetChosenActionsForType: theType

	| aRelatedType someTypes aTemplateFileName |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	aTemplateFileName := self templateFileNameForAction: 'SetChosen'.

	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self generateActions: aTemplateFileName forType: theType relatedConcreteType: aRelatedConcreteType].!

generateSetChosenActionsInstantiationForType: theType

	| aRelatedType someTypes  |


	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.
	someTypes := aRelatedType withAllNonAbstractSubtypes.

	someTypes do: [:aRelatedConcreteType |
		self generateActionsInstantiation: 'setChosen' forType: theType relatedConcreteType: aRelatedConcreteType].!

generateSetChosenSeparateActionsForType: theType

	| aRelatedType someTypes aTemplateFileName |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	aTemplateFileName := self templateFileNameForSeparateAction: 'SetChosen'.

	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self generateSeparateActions: aTemplateFileName forType: theType relatedConcreteType: aRelatedConcreteType 
			actionKind: 'setChosen'].!

generateSetNewActionsForType: theType

	| aRelatedType someTypes aTemplateFileName |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	aTemplateFileName := self templateFileNameForAction: 'SetNew'.

	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self generateActions: aTemplateFileName forType: theType relatedConcreteType: aRelatedConcreteType].!

generateSetNewActionsInstantiationForType: theType

	| aRelatedType someTypes  |


	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.
	someTypes := aRelatedType withAllNonAbstractSubtypes.

	someTypes do: [:aRelatedConcreteType |
		self generateActionsInstantiation: 'setNew' forType: theType relatedConcreteType: aRelatedConcreteType].!

generateSetNewSeparateActionsForType: theType

	| aRelatedType someTypes aTemplateFileName |

	self skip ifTrue: [ ^self].
	self isDerivedOrInverseDerived ifTrue: [ ^self].

	aRelatedType := self relatedType.

	aTemplateFileName := self templateFileNameForSeparateAction: 'SetNew'.

	someTypes := aRelatedType withAllNonAbstractSubtypes.
	someTypes do: [:aRelatedConcreteType |
		self generateSeparateActions: aTemplateFileName forType: theType relatedConcreteType: aRelatedConcreteType 
			actionKind: 'setNew'].!

generateTrxDeclarationForType: theType

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |


	self skip ifTrue: [ ^self].

	(self dummy and: [ self isInverseDerived]) ifTrue: [ ^self].

	aTemplateFileName :=  self derived 
		ifTrue: [ self templateFileNameForDerivedRelationshipFor: 'trx']
		ifFalse: [ self templateFileNameFor: 'trx'].
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			theType trxOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				theType trxOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]! !

!CODERelationship publicMethodsFor: 'generate-streams'!

baseOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type baseOutStream]!

bmgrOutStream	
	bmgrOutStream isNil ifTrue: [ self openBmgrOutStream].
	^bmgrOutStream!

ifcOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type ifcOutStream]!

implOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type implOutStream]!

initBmgrOutFileName
	bmgrOutFileName := (self expand: 'PrefixedTypeName'), '_' , (self expand: 'RelationshipName'), 'BMgr.java'.!

openBmgrOutStream
	| aFileName aPath |

	aFileName := self bmgrOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self type module outputDirectoryWithPackageAndFolder: 'custommgrs'),
		(String with: Filename separator), aFileName.
	bmgrOutStream := aPath asFilename writeStream.!

privOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type privOutStream]!

trxOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type trxOutStream]!

wholeTraversalConfigOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type wholeTraversalConfigOutStream]!

wholeTreeConfigOutStream
	^self type isNil ifTrue: [ nil] ifFalse: [ self type wholeTreeConfigOutStream]! !

!CODERelationship publicMethodsFor: 'generate-support'!

expand: theKey
	expansionInitialized == true ifFalse: [ self initializeExpansions].

	^self expansions at: theKey ifAbsent: [ self type model expand: theKey]!

initializeExpansions

	| anInverse anUpperInverseRelationshipName |
	self expansion: 'RelationshipName' value: self name.
	self expansion: 'UpperRelationshipName' value: self upperInitialName.
	self expansion: 'RelationshipVariableName' value: self type model relationshipVariablePrefix ,self upperInitialName.
	self expansion: 'MetaRelationshipVariableName' value: self type model metaVariablePrefix ,  'Rel', self upperInitialName.
	self expansion: 'TypeAndRelationshipName' value:  (self type upperInitialName, '_', self name).
	self expansion: 'AllTypePackageNames' value: (self type expand: 'AllTypePackageNames').

	self expansion: 'MenuInliningMode' value:
		( self relatedType withAllNonAbstractSubtypes size > 1 
			ifTrue: [  'MMActionsSetIfc.sMenuInliningModeSubMenu'] 
			ifFalse: ['MMActionsSetIfc.sMenuInliningModeInline']).

	self expansion: 'FullPrefixedBMgrName' value: 
		(self type module fullPackageName , '.custommgrs.', self model typePrefix , self type upperInitialName,
			'_', self name, 'BMgr').

	self expansion: 'SeparateDeleteActionClassName' value: self relatedType module fullPackageName , '.custommgrs.',
		self relatedType model typePrefix , self relatedType upperInitialName , '_delete'.

	self expansion: 'RelatedTypePrefixedClassName' value: self type model typePrefix , self relatedType upperInitialName.
	self expansion: 'FullIfcRelatedTypePrefixedClassName' value: (self relatedType expand: 'FullIfcPrefixedClassName').
	self expansion: 'FullBaseRelatedTypePrefixedClassName' value: (self relatedType expand: 'FullBasePrefixedClassName').
	self expansion: 'FullImplRelatedTypePrefixedClassName' value: (self relatedType expand: 'FullImplPrefixedClassName').
	self expansion: 'FullPrivRelatedTypePrefixedClassName' value: (self relatedType expand: 'FullPrivPrefixedClassName').
	self expansion: 'FullTrxRelatedTypePrefixedClassName' value: (self relatedType expand: 'FullTrxPrefixedClassName').

	self expansion: 'RelatedTypeName' value: (self relatedType expand: 'TypeName').
	self expansion: 'TypeName' value: (self type expand: 'TypeName').
	self expansion: 'PrefixedTypeName' value: (self type expand: 'PrefixedClassName').
	self expansion: 'PrefixedRelatedTypeName' value: (self relatedType expand: 'PrefixedClassName').

	self expansion: 'FullIfcTypePrefixedClassName' value: (self type expand: 'FullIfcPrefixedClassName').
	self expansion: 'FullImplTypePrefixedClassName' value: (self type expand: 'FullImplPrefixedClassName').
	self expansion: 'FullTrxTypePrefixedClassName' value: (self type expand: 'FullTrxPrefixedClassName').
	self expansion: 'FullPackageName' value: (self type expand: 'FullPackageName').
	

	anInverse := self inverse.
	anInverse isNil ifFalse: [ 
		anUpperInverseRelationshipName := self toUpperInitial: anInverse name.
		self expansion: 'UpperInverseRelationshipName' value: anUpperInverseRelationshipName].

	self expansion: 'TypePrefixedClassName' value: 
		(self type isNil ifTrue: [ ''] ifFalse: [ self type expand: 'PrefixedClassName']).
	self expansion: 'FrameworkPackageName' value: 
		(self type isNil ifTrue: [ ''] ifFalse: [ self type expand: 'FrameworkPackageName']).
	self expansion: 'BrowserFrameworkPackageName' value: 
		(self type isNil ifTrue: [ ''] ifFalse: [ self type expand: 'BrowserFrameworkPackageName']).
	self expansion: 'RootTypeName' value: 
		(self model isNil ifTrue: [ ''] ifFalse: [ self model expand: 'RootTypeName']).
	self expansion: 'FullTrxRootTypePrefixedClassName' value: 
		((self model isNil or: [ self model treeRootType isNil]) ifTrue: [ '']
			ifFalse: [ self model treeRootType expand: 'FullTrxPrefixedClassName']).
	self expansion: 'FullIfcRootTypePrefixedClassName' value: 
		((self model isNil or: [ self model treeRootType isNil]) ifTrue: [ '']
			ifFalse: [ self model treeRootType expand: 'FullIfcPrefixedClassName']).
	self expansion: 'FullImplRootTypePrefixedClassName' value: 
		((self model isNil or: [ self model treeRootType isNil]) ifTrue: [ '']
			ifFalse: [ self model treeRootType expand: 'FullImplPrefixedClassName']).

	self expansion: 'FullPrefixedChooserTreeConfigFactory' value: 
		(self type isNil ifTrue: [ ''] ifFalse: [ self type expand: 'FullPrefixedChooserTreeConfigFactory']).

	self expansion: 'TypePrefix' value: self type model typePrefix.
	self expansion: 'M3ModelName' value: self type model typePrefix.

	self expansion: 'FullMetaPrefixedClassName' value: ( self type module fullPackageName), '.meta.', (self type model typePrefix , self type upperInitialName) , 'Meta'.

	self expansion: 'FullMetaRelatedTypePrefixedClassName' value: ( self relatedType module fullPackageName), '.meta.', (self relatedType model typePrefix , self relatedType upperInitialName) , 'Meta'.

	expansionInitialized := true!

metaAttributeFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaAttributeFullIfcPrefixedClassName!

metaModelFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModelFullIfcPrefixedClassName!

metaModuleFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModuleFullIfcPrefixedClassName!

metaRelationshipFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaRelationshipFullIfcPrefixedClassName!

metaRelationshipFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaRelationshipFullImplPrefixedClassName!

metaTypeFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaTypeFullIfcPrefixedClassName!

mustGenerateBMgr
	^(self isAggregation or: [self inverse isAggregation not]) and: [ 
		(self dummy and: [ self isInverseDerived]) not]!

templateFileNameFor: theAspect
	
	| aTemplateDirectory aFileName aRelationshipKindTemplateName |

	aTemplateDirectory := self model templatesDirectory.
	aTemplateDirectory isNil ifTrue: [ ^nil].

	aRelationshipKindTemplateName := self templateNameForRelationshipKind.
	aRelationshipKindTemplateName isNil ifTrue: [ ^nil].

	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'relationships', (String with: Filename separator) ,
		theAspect, (String with: Filename separator) ,
		aRelationshipKindTemplateName ,  (self toUpperInitial: theAspect) , '.java'.
	^aFileName!

templateFileNameForAction: theKind
	
	| aTemplateDirectory aFileName |
	aTemplateDirectory := self model templatesDirectory.

	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'relationships', (String with: Filename separator) ,
		'custommgrs', (String with: Filename separator) ,
		theKind, 'Action.java'.
	^aFileName!

templateFileNameForBMgr
	
	| aTemplateDirectory aFileName aRelationshipKindTemplateName anAggregationPostfix |
	aTemplateDirectory := self model templatesDirectory.
	aRelationshipKindTemplateName := self templateNameForRelationshipKind.
	aRelationshipKindTemplateName isNil ifTrue: [ ^nil].
	
	anAggregationPostfix := self isAggregation ifTrue: [ 'Aggregation'] ifFalse: [
		self isDerivedOrInverseDerived ifTrue: [ 'Derived'] ifFalse: [ '']].

	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'relationships', (String with: Filename separator) ,
		'custommgrs', (String with: Filename separator) ,
		 aRelationshipKindTemplateName, anAggregationPostfix, 'BMgr.java'.
	^aFileName!

templateFileNameForDelete
	
	| aTemplateDirectory aFileName aRelationshipKindTemplateName |

	aTemplateDirectory := self model templatesDirectory.
	aTemplateDirectory isNil ifTrue: [ ^nil].

	aRelationshipKindTemplateName := self templateNameForRelationshipKindDelete.
	aRelationshipKindTemplateName isNil ifTrue: [ ^nil].

	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'relationships', (String with: Filename separator) ,
		'base', (String with: Filename separator) ,
		aRelationshipKindTemplateName ,  'Delete' , '.java'.
	^aFileName!

templateFileNameForDerivedRelationshipFor: theAspect
	
	| aTemplateDirectory aFileName aRelationshipKindTemplateName |

	aTemplateDirectory := self model templatesDirectory.
	aTemplateDirectory isNil ifTrue: [ ^nil].

	aRelationshipKindTemplateName := self templateNameForRelationshipKind.
	aRelationshipKindTemplateName isNil ifTrue: [ ^nil].

	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'derivedrelationships', (String with: Filename separator) ,
		theAspect, (String with: Filename separator) ,
		aRelationshipKindTemplateName ,  (self toUpperInitial: theAspect) , '.java'.
	^aFileName!

templateFileNameForSeparateAction: theKind
	
	| aTemplateDirectory aFileName |
	aTemplateDirectory := self model templatesDirectory.

	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'relationships', (String with: Filename separator) ,
		'custommgrs', (String with: Filename separator) ,
		theKind, 'Action.java'.
	^aFileName!

templateNameForRelationshipKind
	| anInverse aTemplateName |

	anInverse := self inverse.
	
	aTemplateName := anInverse isNil 
		ifFalse: [ 
			self isManyRelationship 
				ifTrue: [
					anInverse isManyRelationship
						ifTrue: [ 'ManyToMany']
						ifFalse: [ 'OneToManyMany' ] 
				]
				ifFalse: [
					anInverse isManyRelationship
						ifTrue: [ 'OneToManyOne' ]
						ifFalse: [ 'OneToOne'] 
				]]
		ifTrue: [
			self isManyRelationship 
				ifTrue: [ nil]
				ifFalse: [ nil]].
"	aTemplateName isNil ifTrue: [ self halt]."
	^aTemplateName!

templateNameForRelationshipKindDelete
	| anInverse aTemplateName |

	anInverse := self inverse.
	
	aTemplateName := anInverse isNil 
		ifFalse: [ 
			self isManyRelationship 
				ifTrue: [
					anInverse isManyRelationship
						ifTrue: [ 'ManyToMany']
						ifFalse: [ 'OneToManyMany' , (self isAggregation ifFalse: [ ''] ifTrue: [ 'Aggregate'])] 
				]
				ifFalse: [
					anInverse isManyRelationship
						ifTrue: [ 'OneToManyOne' ]
						ifFalse: [ 'OneToOne' , (self isAggregation ifFalse: [ ''] ifTrue: [ 'Aggregate'])] 
				]]
		ifTrue: [
			self isManyRelationship 
				ifTrue: [ nil]
				ifFalse: [ nil]].
"	aTemplateName isNil ifTrue: [ self halt]."
	^aTemplateName! !

!CODERelationship publicMethodsFor: 'generate-traversals'!

generateTraversalBranchCfgsStaticDeclarations
	| anStream |

	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; nextPutAll: 'public M3BranchConfigIfc a', (self expand: 'TypeAndRelationshipName'), 'BC;'; cr.
	]

"public static M3BranchConfigIfc aAbstractEnumeratedType_enumeratedValuesBC;"!

generateTraversalBranchCfgsStaticInitializations
	| someTypes anStream |

	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	self relatedType isNil ifFalse: [ 
		someTypes := self relatedType withAllNonAbstractSubtypes.
		someTypes do: [:aType | aType generateTraversalRelatedTypeNodeCfgsStaticInitializationsForRelationship: self].
		someTypes isEmpty ifFalse: [ 		
			anStream := self wholeTraversalConfigOutStream.
			anStream isNil ifFalse: [ anStream cr]
		]
	].!

generateTraversalBranchCfgsStaticInstantiations
	| anStream aPhaseNumber |

	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	aPhaseNumber := self isAggregation ifTrue: [ '0'] ifFalse: [ '1'].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab;  nextPutAll: 'a', (self expand: 'TypeAndRelationshipName'), 'BC  =   (M3BranchConfigIfc) theCtxt.getMMFactory("M3").createMMElementOfType( theCtxt, "BranchConfig", "traversal",',
			'"', (self expand: 'TypeAndRelationshipName'), 'BC");';cr.
		anStream tab; tab;  nextPutAll: 'a', (self expand: 'TypeAndRelationshipName'), 'BC.setMetaRelationship( theCtxt, ((com.yourml.repostory.m3model.core.pub.M3ModelPub) theM3Model).getM3TypeInPackagesNamed( theCtxt, "', self type upperInitialName ,'", "', self type allContainerPackageNames ,'").findRelationshipsNamed( theCtxt, "', self name, '"));'; cr.
		anStream tab; tab;  nextPutAll: 'a', (self expand: 'TypeAndRelationshipName'), 'BC.setPhaseNumber( theCtxt, ',
			aPhaseNumber, ');'; cr.
		anStream tab; tab;  nextPutAll: 'addBranchConfigs( theCtxt, a', (self expand: 'TypeAndRelationshipName'), 'BC);'; cr; cr.


	]

"	  aAbstractEnumeratedType_enumeratedValuesBC = theCtxt.getMMFactory('M3').createMMElementOfType( theCtxt, 'BranchConfig', 'traversal', new EAIMMName('AbstractEnumeratedType_enumeratedValuesBC'));
	aAbstractEnumeratedType_enumeratedValuesBC.setMetaRelationship( theCtxt, theCtxt.getMMFactory('Kit').getM3Type( theCtxt, 'AbstractEnumeratedType', 'core.model.structural').findRelationshipsNamed( theCtxt, new EAIMMName('enumeratedValues')));
	gConfig.addBranchConfigs( theCtxt, aAbstractEnumeratedType_enumeratedValuesBC);
"!

generateTraversalBranchMgrsStaticDeclarations
	| anStream aM3BranchMgrIfcName |

	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	aM3BranchMgrIfcName := self model generatingReplicationTraversalConfig ifTrue: [ 'M3ReplicateBranchMgrIfc'] ifFalse: [ 'M3BranchMgrIfc'].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; nextPutAll: 'public ', aM3BranchMgrIfcName ,' a', (self expand: 'TypeAndRelationshipName'), 'BMgr;'; cr.
	]

"public static M3BranchMgrIfc aAbstractEnumeratedType_enumeratedValuesBMgr;"!

generateTraversalBranchMgrsStaticInstantiations
	| anStream aMgrTypeName aMgrPackageNames aM3BranchMgrIfcName |

	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	aMgrTypeName := self model generatingReplicationTraversalConfig ifTrue: [ 'ReplicateBranchMgr'] ifFalse: [ 'BranchMgr'].
	aMgrPackageNames := self model generatingReplicationTraversalConfig ifTrue: [ 'replication'] ifFalse: [ 'traversal'].
	aM3BranchMgrIfcName := self model generatingReplicationTraversalConfig ifTrue: [ 'M3ReplicateBranchMgrIfc'] ifFalse: [ 'M3BranchMgrIfc'].


	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab;  nextPutAll: 'a', (self expand: 'TypeAndRelationshipName'), 'BMgr  =   (', aM3BranchMgrIfcName, ') theCtxt.getMMFactory("M3").createMMElementOfType( theCtxt, "', aMgrTypeName , '", "', aMgrPackageNames , '",',
			'"', (self expand: 'TypeAndRelationshipName'), 'BMgr");';cr.
		anStream tab; tab;  nextPutAll: 'addBranchMgrs( theCtxt, a', (self expand: 'TypeAndRelationshipName'), 'BMgr);';cr. 
		anStream tab; tab;  nextPutAll: 'a', (self expand: 'TypeAndRelationshipName'), 'BC.setMetaBranchMgr( theCtxt, a', (self expand: 'TypeAndRelationshipName'), 'BMgr);'; cr; cr
	]

"	  aAbstractEnumeratedType_enumeratedValuesBMgr = theCtxt.getMMFactory('M3').createMMElementOfType( theCtxt, 'BranchMgr', 'traversal', 'AbstractEnumeratedType_enumeratedValuesBMgr');
	aAbstractEnumeratedType_enumeratedValuesBC.setMetaBranchMgr( theCtxt,  aAbstractEnumeratedType_enumeratedValuesBMgr);
"!

generateTraversalNodeCfgsStaticInitializationsForType: theType
	| anStream aCommentOutString |

	self skip ifTrue: [ ^self].
	aCommentOutString := self dummy ifTrue: [ '//'] ifFalse: [''].

	self mustGenerateBMgr ifFalse: [ ^self].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream nextPutAll: aCommentOutString;
			tab; tab;  nextPutAll: 'a', (theType upperInitialName), 'NC.addBranchConfigs( theCtxt, a', (self expand: 'TypeAndRelationshipName'), 'BC);'; cr

	]

"	aEnumeratedTypeNC.addBranchConfigs( theCtxt, aAbstractEnumeratedType_enumeratedValuesBC);
"!

generateTraversalRelatedTypeNodeCfgsStaticDeclarations
	| someTypes |

	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	self relatedType isNil ifFalse: [ 
		someTypes := self relatedType withAllNonAbstractSubtypes.
		someTypes do: [:aType | aType generateTraversalRelatedTypeNodeCfgsStaticDeclarationsForRelationship: self]
	].!

generateTraversalRelatedTypeNodeCfgsStaticInstantiations
	| someTypes |

	self skip ifTrue: [ ^self].

	self mustGenerateBMgr ifFalse: [ ^self].

	self relatedType isNil ifFalse: [ 
		someTypes := self relatedType withAllNonAbstractSubtypes.
		someTypes do: [:aType | aType generateTraversalRelatedTypeNodeCfgsStaticInstantiationsForRelationship: self]
	].! !

!CODERelationship publicMethodsFor: 'initialize-release'!

dependenciesRelease
	dependencies isNil ifTrue: [ ^self].
	dependencies do: [:aDependency | aDependency release].
	dependencies := nil!

initCandidatesConstraint
	candidatesConstraint := ''!

initCandidatesPath
	candidatesPath := ''!

initComputationKind
	computationKind := self class computationKindNoComputation!

initDerived
	"Generated by ISF/AD. Do not modify"
	derived := false.!

initDummy
	"Generated by ISF/AD. Do not modify"
	dummy := false.!

initInitializationExpression
	initializationExpression := '' copy!

initIsAbstract
	isAbstract := false!

initIsChangeable
	isChangeable := true!

initIsDuplicatesAllowed
	isDuplicatesAllowed := false!

initIsExclussion
	isExclussion := false!

initIsInitializationPropagationAllowed
	isInitializationPropagationAllowed := true!

initIsInitializationPropagationOnConnectAllowed
	isInitializationPropagationOnConnectAllowed := true!

initIsJustUsed
	isJustUsed := true!

initIsNameRelationship
	isNameRelationship := false!

initIsPropagateUse
	isPropagateUse := false!

initIsRefinementRequired
	isRefinementRequired := false!

initKind
	kind := self class referencesRelationshipKind!

initMaxMult
	maxMult := self class maxMultOne!

initMinMult
	"Generated by ISF/AD. Do not modify"
	minMult := self class minMultOptional!

initOrderConstraint
	orderConstraint := ''!

initTerminalMetaAttributesFrom: theRelationship

	theRelationship isNil ifTrue: [ ^self].
	(theRelationship isKindOf: CODERelationship) ifFalse: [ ^self].

	self relationshipKind: 			theRelationship relationshipKind.
	self minMult: 						theRelationship minMult copy.
	self maxMult: 					theRelationship maxMult copy.
	self isAbstract: 					theRelationship isAbstract == true.
	self isExclussion: 				theRelationship isExclussion == true.
	self isChangeable: 				theRelationship isChangeable == true.
	self isDuplicatesAllowed: 		theRelationship isDuplicatesAllowed == true.
	self reengineredInstVarName: theRelationship reengineredInstVarName.
	self computationKind: 			theRelationship computationKind copy.
	self orderConstraint: 			theRelationship orderConstraint copy.
	self candidatesPath: 			theRelationship candidatesPath copy.
	self candidatesConstraint: 	theRelationship candidatesConstraint copy.
	self initializationExpression: 	theRelationship initializationExpression copy.
	self isInitializationPropagationAllowed: 	theRelationship isInitializationPropagationAllowed == true.
	self isInitializationPropagationOnConnectAllowed: 	theRelationship isInitializationPropagationOnConnectAllowed == true.
	"self isPropagateUse:  			theRelationship isPropagateUse == true.
	self isJustUsed:					theRelationship isJustUsed == true."!

release
	
	| anInverse |

	self changed: #objectDisconnectedOfTree.

	anInverse := self inverse.

	self relatedTypeRelease.

	self reverseRelease.

	self inverseRelease.

	self typeRelease.

	anInverse isNil ifFalse: [ anInverse release].

	self relationshipRefinements do: [:aRelationshipRefinement | aRelationshipRefinement release].

	self relationshipRefinementsRelease.
	
	self dependenciesRelease.

	super release.! !

!CODERelationship publicMethodsFor: 'parse'!

fromLineStream: theLineStream andStream: theStream

	| aKind aMinMult aMaxMult aRelatedTypeName anInverseRelationshipName  aRelationship aRelatedType c aModule aNameIndex |

	theLineStream isNil ifTrue: [ ^nil].
	theLineStream atEnd ifTrue: [ ^nil].
	self type isNil ifTrue: [ ^nil].
	aModule := self type module.
	aModule isNil ifTrue: [ ^nil].

	theLineStream atEnd ifFalse: [ aKind := self nextTokenFrom: theLineStream].
	theLineStream atEnd ifFalse: [ aMinMult := self nextTokenFrom: theLineStream].
	theLineStream atEnd ifFalse: [ self nextTokenFrom: theLineStream].
	"theLineStream atEnd ifFalse: [ b := self nextTokenFrom: theLineStream]."
	theLineStream atEnd ifFalse: [ aMaxMult := self nextTokenFrom: theLineStream].
	theLineStream atEnd ifFalse: [ aRelatedTypeName := self nextTokenFrom: theLineStream].
	theLineStream atEnd ifFalse: [ c := self nextTokenFrom: theLineStream].
	theLineStream atEnd ifFalse: [ c = ';' ifFalse: [ anInverseRelationshipName := self nextTokenFrom: theLineStream]].
	'/' = anInverseRelationshipName ifTrue: [ 	
		theLineStream atEnd ifFalse: [ anInverseRelationshipName := self nextTokenFrom: theLineStream].
	].

	self relationshipKind: aKind asUppercase  asSymbol.
	self minMult: aMinMult asSymbol. 
	self maxMult: aMaxMult asSymbol.
	
	aRelatedType := aModule findTypeNamed: aRelatedTypeName.
	aRelatedType isNil ifFalse: [ self relatedType: aRelatedType]. 	

	aRelationship := nil.
"Transcript show: '>' , anInverseRelationshipName printString, '<'; cr.
"	(anInverseRelationshipName isNil or: [ 
		anInverseRelationshipName isEmpty or: [ 
			anInverseRelationshipName = '?' ]])
		ifFalse: [ 
			aRelationship := aRelatedType relationshipNamed: anInverseRelationshipName
		]
		ifTrue: [ 
			anInverseRelationshipName := 'inverseOF' , self name.
			aNameIndex := 0.
			[aRelatedType hasOrInheritsRelationshipNamed: anInverseRelationshipName ] whileTrue: [ 
				aNameIndex :=  aNameIndex + 1.
				anInverseRelationshipName := 'inverse', aNameIndex printString, 'OF', self name
			].

			aRelationship := CODERelationship new.
			aRelationship name: anInverseRelationshipName.
			aRelationship minMult: '0'.
			aRelationship maxMult: (self relationshipKind = 'Aggregates'  ifTrue: ['1'] ifFalse: ['*']).
			aRelationship dummy: true.
			aRelationship relationshipKind: (self relationshipKind = 'Aggregates '  ifTrue: ['IsPartOf'] ifFalse: ['Many']).
			aRelationship relatedType: self type.
			aRelatedType relationshipsAdd: aRelationship.
		].
	aRelationship isNil ifFalse: [ 	self inverse: aRelationship]! !

!CODERelationship publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aSep aType |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aType := self type.

	aType isNil  ifFalse: [  aType allQualifiedNamesInto: theStream].

	theStream 
		nextPutAll: (self pcForV: self class qualifiedNameRelationshipStepSymbol); nextPutAll: aSep;
		 nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

asReferenceArray

	| aType aTypeReferenceArray |

	aType := self type.
	aTypeReferenceArray := aType isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aType asReferenceArray].

	^Array with: self class refToRelationshipKindSymbol with: self name with: aTypeReferenceArray!

asReferenceAs: theRoleSymbol  codeStringNOCROn: theStream

	| aSep aType |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	aType := self type.

	theStream nextPutAll: '( ';  nextPutAll: (self pcForV: theRoleSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	aType isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [  aType asReferenceAsCodeStringNOCROn: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAs: theRoleSymbol  codeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAs: theRoleSymbol  codeStringNOCROn: theStream. 
	theStream  cr.!

asReferenceAsCodeStringNOCROn: theStream

	^self asReferenceAs: self class refToRelationshipKindSymbol   codeStringNOCROn: theStream!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAs: self class refToRelationshipKindSymbol codeStringNOCROn: theStream. 
	theStream  cr.!

firstPersistenceIndexRelationship
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexRelationship.

	self forzeRelationshipKind:	 		(theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]).
	self forzeReengineredInstVarName:	(theValues size < (aFPI +1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +1)]). 
	self forzeMinMult:	 					(theValues size < (aFPI +2) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +2)]).
	self forzeMaxMult:	 					(theValues size < (aFPI +3) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +3)]).
	self forzeIsAbstract:					(theValues size < (aFPI +4) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +4)]). 
	self forzeIsExclussion:					(theValues size < (aFPI +5) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +5)]). 
	self forzeIsChangeable:				(theValues size < (aFPI +6) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +6)]). 
	self forzeIsDuplicatesAllowed:		(theValues size < (aFPI +7) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +7)]). 
	self forzeIsNameRelationship:			(theValues size < (aFPI +8) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +8)]). 
	self forzeIsInitializationPropagationAllowed:		(theValues size < (aFPI +9) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +9)]). 
	self forzeIsInitializationPropagationOnConnectAllowed:		(theValues size < (aFPI +10) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +10)]). 
	self forzeComputationKind:			(theValues size < (aFPI +11) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +11)]). 
	self forzeOrderConstraint:				(theValues size < (aFPI +12) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +12)]).
	self forzeCandidatesPath:				(theValues size < (aFPI +13) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +13)]).
	self forzeCandidatesConstraint:		(theValues size < (aFPI +14) ifTrue: [nil] ifFalse: [ theValues at: (aFPI +14)]).
	self forzeInitializationExpression:		(theValues size < (aFPI + 15) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 15)]). 

	theValues size < (aFPI +16) ifFalse: [  self initReferencedInverseFromValues:  (theValues at: (aFPI +16)) ].

	self forzeIsPropagateUse:				(theValues size < (aFPI + 17) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 17)]).!

initReferencedInverseFromValues: theValues

	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refToInverseRelationshipKindSymbol ifFalse: [ ^nil].

	inverseRelationshipRefTmpValues := theValues.!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep aInverse |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  relationshipKind );  nextPutAll: aSep;
		nextPutAll: (self pcForV:  self reengineredInstVarName ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  minMult ); 
		nextPutAll: aSep; nextPutAll: (self pcForV:  self  maxMult); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self isAbstract );  nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isExclussion ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isChangeable ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isDuplicatesAllowed ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isNameRelationship ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isInitializationPropagationAllowed ); nextPutAll: aSep;
		nextPutAll: (self pcForV:  self isInitializationPropagationOnConnectAllowed ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self computationKind); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self orderConstraint ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self candidatesPath );cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self candidatesConstraint ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self initializationExpression );  cr.

	aInverse := self inverse.
	aInverse isNil  
		ifTrue: [ theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil); cr] 
		ifFalse: [ aInverse asReferenceAs: self class refToInverseRelationshipKindSymbol codeStringOn:  theStream indent: anIS].

	theStream 
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  isPropagateUse ); cr!

numberPersistenceEntriesRelationship
	^18!

ph2InitFromSolver: theSolver

	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedInverseFromSolver: theSolver.!

ph2InitReferencedInverseFromSolver: theSolver
	
	| aType aRelationship |

	self inverse isNil ifFalse: [ ^self].

	(inverseRelationshipRefTmpValues isNil or: [ inverseRelationshipRefTmpValues isEmpty]) ifTrue: [ ^nil].
	
	aRelationship := CODEElement resolveOrNewReferencedRelationshipFromPersistenceAsCode:  inverseRelationshipRefTmpValues  solver: theSolver forInverseType: self type.

	aRelationship isNil ifFalse: [ 
		self inverse == aRelationship ifFalse: [ 
			aType := aRelationship type.

			self forzeInverse: aRelationship.
			self forzeRelatedType: aType.
			aRelationship isNil ifFalse: [ 
				aRelationship forzeInverse: self.
				aRelationship forzeRelatedType: self type.
				self type relatedWithPrivate add: aRelationship
			].
			aType isNil ifFalse: [  aType relatedWithPrivate add: self]
		].
	] .

	inverseRelationshipRefTmpValues := nil!

referencedInverseRefToTypeValues

	| aRefToTypeValues |
	(inverseRelationshipRefTmpValues isNil or: [ inverseRelationshipRefTmpValues isEmpty]) ifTrue: [ ^nil].

	inverseRelationshipRefTmpValues first = self class refToInverseRelationshipKindSymbol ifFalse: [ ^nil].

	aRefToTypeValues := inverseRelationshipRefTmpValues size < 3  ifTrue: [ nil] ifFalse: [ inverseRelationshipRefTmpValues at: 3].
	^aRefToTypeValues!

xnumberPersistenceEntriesRelationship
	^18! !

!CODERelationship publicMethodsFor: 'semantic checking'!

checkCandidatesConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCandidatesPath: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkComputationKind: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDerived: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDummy: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkInitializationExpression: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkInverse: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsChangeable: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsDuplicatesAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsInitializationPropagationAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsInitializationPropagationOnConnectAllowed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsJustUsed: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsNameRelationship: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsPropagateUse: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsRefinementRequired: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkKind: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMaxMult: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMinMult: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOrderConstraint: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkReengineredInstVarName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRelatedType: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRelationshipRefinementsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRelationshipRefinementsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkReverse: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkType: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODERelationship publicMethodsFor: 'semantic links'!

inverseCandidates
	"Generated by ISF/AD. Do not modify"
	^self inverse isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self inverse]!

inverseCreate
	"Generated by ISF/AD. Do not modify"
	^CODERelationship new!

inverseLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self inverseCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self inverse: anObject]!

inverseLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self inverseCandidates
		initially: self inverse
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self inverse: anObject.!

inverseLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self inverseCandidates
		initially: self inverse
		label: 'Select Or Create ...'
		class: self inverseCreate class
		ifUnchanged: [^self].
	self inverse: anObject!

inverseScope
	"Generated by ISF/AD. Do not modify"
	^nil!

maxMultCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self maxMult!

maxMultCreate
	"Generated by ISF/AD. Do not modify"
	^''!

maxMultLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self maxMult: self maxMultCreate.!

maxMultLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self maxMultCandidates
		initially: self maxMult
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self maxMult: anObject.!

maxMultLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self maxMultCandidates
		initially: self maxMult
		label: 'Select Or Create ...'
		class: self maxMultCreate class
		ifUnchanged: [^self].
	self maxMult: anObject!

maxMultScope
	"Generated by ISF/AD. Do not modify"
	^nil!

minMultCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self minMult!

minMultCreate
	"Generated by ISF/AD. Do not modify"
	^''!

minMultLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self minMult: self minMultCreate.!

minMultLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self minMultCandidates
		initially: self minMult
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self minMult: anObject.!

minMultLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self minMultCandidates
		initially: self minMult
		label: 'Select Or Create ...'
		class: self minMultCreate class
		ifUnchanged: [^self].
	self minMult: anObject!

minMultScope
	"Generated by ISF/AD. Do not modify"
	^nil!

relatedTypeCandidates
	"Generated by ISF/AD. Do not modify"
	^self relatedType isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self relatedType]!

relatedTypeCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

relatedTypeLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self relatedTypeCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self relatedType: anObject]!

relatedTypeLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self relatedTypeCandidates
		initially: self relatedType
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self relatedType: anObject.!

relatedTypeLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self relatedTypeCandidates
		initially: self relatedType
		label: 'Select Or Create ...'
		class: self relatedTypeCreate class
		ifUnchanged: [^self].
	self relatedType: anObject!

relatedTypeScope
	"Generated by ISF/AD. Do not modify"
	^nil!

relationshipKindCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self relationshipKind!

relationshipKindLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self relationshipKindCandidates
		initially: self relationshipKind
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self relationshipKind: anObject.!

relationshipKindLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self relationshipKindCandidates
		initially: self relationshipKind
		label: 'Select Or Create ...'
		class: self relationshipKindCreate class
		ifUnchanged: [^self].
	self relationshipKind: anObject!

relationshipRefinementsCandidates
	"Generated by ISF/AD. Do not modify"
	^self relationshipRefinements asArray!

relationshipRefinementsCreate
	"Generated by ISF/AD. Do not modify"
	^CODERelationship new!

relationshipRefinementsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self relationshipRefinementsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self relationshipRefinementsAdd: anObject]!

relationshipRefinementsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self relationshipRefinementsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self relationshipRefinementsAdd: anObject.!

relationshipRefinementsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self relationshipRefinementsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self relationshipRefinementsCreate class
		ifUnchanged: [^self].
	self relationshipRefinementsAdd: anObject!

relationshipRefinementsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

reverseCandidates
	"Generated by ISF/AD. Do not modify"
	^self reverse isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self reverse]!

reverseCreate
	"Generated by ISF/AD. Do not modify"
	^CODERelationship new!

reverseLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self reverseCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self reverse: anObject]!

reverseLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self reverseCandidates
		initially: self reverse
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self reverse: anObject.!

reverseLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self reverseCandidates
		initially: self reverse
		label: 'Select Or Create ...'
		class: self reverseCreate class
		ifUnchanged: [^self].
	self reverse: anObject!

reverseScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typeCandidates
	"Generated by ISF/AD. Do not modify"
	^self type isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self type]!

typeCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

typeLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typeCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self type: anObject]!

typeLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typeCandidates
		initially: self type
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self type: anObject.!

typeLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typeCandidates
		initially: self type
		label: 'Select Or Create ...'
		class: self typeCreate class
		ifUnchanged: [^self].
	self type: anObject!

typeScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODERelationship publicMethodsFor: 'testing'!

isFeature
	^true!

isRelationship
	^true! !

!CODERelationship publicMethodsFor: 'updating refinements'!

updateRefinements: theMetaAttributeName value: theValue

	| someRefinements |
	someRefinements := self relationshipRefinements.
	(someRefinements isNil not and: [someRefinements  isEmpty not]) ifTrue: [ 
		someRefinements do: [:aRefinement | 
			aRefinement updateFromRefined: theMetaAttributeName value: theValue
		]
	].! !

!CODERelationship publicMethodsFor: 'updating uses'!

updateUses

	| aType |

	aType := self type.
	aType isNil ifTrue:  [ ^self].

	aType updateUses! !

!CODERelationshipRefinement class publicMethodsFor: 'accessing'!

kind
	^#relationshipRefinement! !

!CODERelationshipRefinement class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		 self modelEditorMETAPerspectivesRelationshipRefinement, super modelEditorMETAPerspectives!

modelEditorMETAPerspectivesRelationshipRefinement
 
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RefinedRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'RefinedRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'RelationshipRefinement_Perspectives';
			nlsItem: 'RefinedRelationships';
			nlsTranslation: 'RelacionesOriginales';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsRelationshipRefinement!

modelEditorMETASelectorsRelationshipRefinement

	"METAChildSpecAutoViewEditor openOn: CODERelationship selector: #modelEditorMETASelectorsRelationshipRefinement target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 8)
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RefinedRelationships';
			basicSelector: #refinedRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Select;
			helpString: 'RefinedRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'RelationshipRefinement_Selectors';
			nlsItem: 'RefinedRelationships';
			nlsTranslation: 'RelacionesOriginales';
			yourself);
		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsRelationshipRefinement.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect!

modelEditorPathSelectorsRelationshipRefinement

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('RefinedRelationships' )! !

!CODERelationshipRefinement publicMethodsFor: 'accessing'!

candidatesConstraint: aValue
	
	(self checkCandidatesConstraint: aValue) ifFalse: [^aValue].
	(self candidatesConstraint = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #candidatesConstraint:) = aValue 
		ifTrue: [ self clearAsRefined: #candidatesConstraint:]
		ifFalse: [  self setAsRefined: #candidatesConstraint:].

	candidatesConstraint := aValue.
	self markDirty.

	self updateRefinements: #candidatesConstraint: value: aValue.

	self changed: #candidatesConstraint!

candidatesPath: aValue
	
	(self checkCandidatesPath: aValue) ifFalse: [^aValue].
	(self candidatesPath = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #candidatesPath:) = aValue 
		ifTrue: [ self clearAsRefined: #candidatesPath:]
		ifFalse: [  self setAsRefined: #candidatesPath:].

	candidatesPath := aValue.
	self markDirty.

	self updateRefinements: #candidatesPath: value: aValue.

	self changed: #candidatesPath!

computationKind: aValue
	
	(self checkComputationKind: aValue) ifFalse: [^aValue].
	(self computationKind = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #computationKind:) = aValue 
		ifTrue: [ self clearAsRefined: #computationKind:]
		ifFalse: [  self setAsRefined: #computationKind:].

	computationKind := aValue.
	self markDirty.

	self updateRefinements: #computationKind: value: aValue.

	self changed: #computationKind!

initializationExpression: aValue
	
	(self checkInitializationExpression: aValue) ifFalse: [^aValue].
	(self initializationExpression = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #initializationExpression:) = aValue 
		ifTrue: [ self clearAsRefined: #initializationExpression:]
		ifFalse: [  self setAsRefined: #initializationExpression:].

	initializationExpression := aValue.
	self markDirty.

	self updateRefinements: #initializationExpression: value: aValue.

	self changed: #initializationExpression!

isAbstract: aValue
	
	(self checkIsAbstract: aValue) ifFalse: [^aValue].
	(self isAbstract = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isAbstract:) = aValue 
		ifTrue: [ self clearAsRefined: #isAbstract:]
		ifFalse: [  self setAsRefined: #isAbstract:].

	isAbstract := aValue.
	self markDirty.

	self updateRefinements: #isAbstract: value: aValue.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #isAbstract!

isChangeable: aValue
	
	(self checkIsChangeable: aValue) ifFalse: [^aValue].
	(self isChangeable = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isChangeable:) = aValue 
		ifTrue: [ self clearAsRefined: #isChangeable:]
		ifFalse: [  self setAsRefined: #isChangeable:].

	isChangeable := aValue.
	self markDirty.

	self updateRefinements: #isChangeable: value: aValue.

	self changed: #isChangeable!

isDuplicatesAllowed: aValue
	
	(self checkIsDuplicatesAllowed: aValue) ifFalse: [^aValue].
	(self isDuplicatesAllowed = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isDuplicatesAllowed:) = aValue 
		ifTrue: [ self clearAsRefined: #isDuplicatesAllowed:]
		ifFalse: [  self setAsRefined: #isDuplicatesAllowed:].

	isDuplicatesAllowed := aValue.
	self markDirty.

	self updateRefinements: #isDuplicatesAllowed: value: aValue.

	self changed: #isDuplicatesAllowed!

isExclussion: aValue
	
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	(self isExclussion = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isExclussion:) = aValue 
		ifTrue: [ self clearAsRefined: #isExclussion:]
		ifFalse: [  self setAsRefined: #isExclussion:].

	isExclussion := aValue.
	self markDirty.

	self updateRefinements: #isExclussion: value: aValue.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #isExclussion!

isInitializationPropagationAllowed: aValue
	
	(self checkIsInitializationPropagationAllowed: aValue) ifFalse: [^aValue].
	(self isInitializationPropagationAllowed = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isInitializationPropagationAllowed:) = aValue 
		ifTrue: [ self clearAsRefined: #isInitializationPropagationAllowed:]
		ifFalse: [  self setAsRefined: #isInitializationPropagationAllowed:].

	isInitializationPropagationAllowed := aValue.
	self markDirty.

	self updateRefinements: #isInitializationPropagationAllowed: value: aValue.

	self changed: #isInitializationPropagationAllowed!

isInitializationPropagationOnConnectAllowed: aValue
	
	(self checkIsInitializationPropagationOnConnectAllowed: aValue) ifFalse: [^aValue].
	(self isInitializationPropagationOnConnectAllowed = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isInitializationPropagationOnConnectAllowed:) = aValue 
		ifTrue: [ self clearAsRefined: #isInitializationPropagationOnConnectAllowed:]
		ifFalse: [  self setAsRefined: #isInitializationPropagationOnConnectAllowed:].

	isInitializationPropagationOnConnectAllowed := aValue.
	self markDirty.

	self updateRefinements: #isInitializationPropagationOnConnectAllowed: value: aValue.

	self changed: #isInitializationPropagationOnConnectAllowed!

isNameRelationship: aValue
	
	(self checkIsNameRelationship: aValue) ifFalse: [^aValue].
	(self isNameRelationship = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #isNameRelationship:) = aValue 
		ifTrue: [ self clearAsRefined: #isNameRelationship:]
		ifFalse: [  self setAsRefined: #isNameRelationship:].

	isNameRelationship := aValue.
	self markDirty.

	self updateRefinements: #isNameRelationship: value: aValue.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #isNameRelationship!

maxMult: aValue

	(self checkMaxMult: aValue) ifFalse: [^aValue].
	(self maxMult = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #maxMult:) = aValue 
		ifTrue: [ self clearAsRefined: #maxMult:]
		ifFalse: [  self setAsRefined: #maxMult:].

	maxMult := aValue.
	self markDirty.

	self updateRefinements: #maxMult: value: aValue.

	self changed: #maxMult!

minMult: aValue
	
	(self checkMinMult: aValue) ifFalse: [^aValue].
	(self minMult = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #minMult:) = aValue 
		ifTrue: [ self clearAsRefined: #minMult:]
		ifFalse: [  self setAsRefined: #minMult:].

	minMult := aValue.
	self markDirty.

	self updateRefinements: #minMult: value: aValue.

	self changed: #minMult!

orderConstraint: aValue
	
	(self checkOrderConstraint: aValue) ifFalse: [^aValue].
	(self orderConstraint = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #orderConstraint:) = aValue 
		ifTrue: [ self clearAsRefined: #orderConstraint:]
		ifFalse: [  self setAsRefined: #orderConstraint:].

	orderConstraint := aValue.
	self markDirty.

	self updateRefinements: #orderConstraint: value: aValue.

	self changed: #orderConstraint!

reengineredInstVarName: aValue
	
	(self checkReengineredInstVarName: aValue) ifFalse: [^aValue].
	(self reengineredInstVarName = aValue) ifTrue: [ ^aValue].

	(self valueFromRefined: #reengineredInstVarName:) = aValue 
		ifTrue: [ self clearAsRefined: #reengineredInstVarName:]
		ifFalse: [  self setAsRefined: #reengineredInstVarName:].

	reengineredInstVarName := aValue.
	self markDirty.

	self updateRefinements: #reengineredInstVarName: value: aValue.

	self changed: #reengineredInstVarName! !

!CODERelationshipRefinement publicMethodsFor: 'association initialize-release'!

initRefinedRelationships
	"Generated by ISF/AD. Do not modify"
	refinedRelationships := OrderedCollection new.!

refinedRelationshipsRelease
	"Generated by ISF/AD. Do not modify"
	self refinedRelationships do: [:each | self refinedRelationshipsRemove: each]! !

!CODERelationshipRefinement publicMethodsFor: 'associations accessing'!

refinedRelationships
	"Generated by ISF/AD. Do not modify"
	^self refinedRelationshipsPrivate copy!

refinedRelationshipsAsArray
	"Generated by ISF/AD. Do not modify"
	^self refinedRelationships asArray! !

!CODERelationshipRefinement publicMethodsFor: 'associations modifying'!

refinedRelationshipsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRefinedRelationshipsAdd: aValue) ifFalse: [^aValue].
	(self refinedRelationshipsIncludes: aValue) ifTrue: [^aValue].
	(self refinedRelationshipsPrivateAdd: aValue) relationshipRefinementsPrivateAdd: self.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #refinedRelationships.

	^aValue!

refinedRelationshipsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self refinedRelationshipsIncludes: aValue) ifFalse: [^aValue].
	(self refinedRelationships indexOf: aValue) = self refinedRelationshipsSize ifTrue: [^aValue].
	self refinedRelationshipsPrivate remove: aValue.
	aRes := self refinedRelationshipsPrivateAdd: aValue.
	self invalidateEffectiveRelationshipsCaches.

	^aRes!

refinedRelationshipsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self refinedRelationshipsIncludes: aValue) ifFalse: [^aValue].
	(index := self refinedRelationships indexOf: aValue) = self refinedRelationshipsSize ifTrue: [^aValue].
	index = (self refinedRelationshipsSize -1)
		ifTrue:
			[self refinedRelationshipsPrivate remove: aValue.
			aRes := self refinedRelationshipsPrivateAdd: aValue.
			self notifyChangeAllRefinedRelationshipsChildSpecs.
			^aRes].
	aRes := self refinedRelationshipsPrivateMove: aValue beforeIndex: index + 2.

	self invalidateEffectiveRelationshipsCaches.

	^aRes!

refinedRelationshipsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self refinedRelationshipsIncludes: aValue) ifFalse: [^aValue].
	(self refinedRelationships indexOf: aValue) = 1 ifTrue: [^aValue].
	self refinedRelationshipsPrivateMove: aValue beforeIndex: 1.

	self invalidateEffectiveRelationshipsCaches.!

refinedRelationshipsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self refinedRelationshipsIncludes: aValue) ifFalse: [^aValue].
	(index := self refinedRelationships indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self refinedRelationshipsPrivateMove: aValue beforeIndex: index - 1.
	self invalidateEffectiveRelationshipsCaches.

	^aRes!

refinedRelationshipsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRefinedRelationshipsRemove: aValue) ifFalse: [^aValue].
	(self refinedRelationshipsPrivate remove: aValue ifAbsent: [^aValue]) relationshipRefinementsPrivateRemove: self.

	self invalidateEffectiveRelationshipsCaches.

	self changed: #refinedRelationships.

	^aValue! !

!CODERelationshipRefinement publicMethodsFor: 'associations private'!

refinedRelationshipsPrivate
	"Generated by ISF/AD. Do not modify"
	refinedRelationships isNil
		ifTrue: [self initRefinedRelationships].
	^refinedRelationships!

refinedRelationshipsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self refinedRelationshipsPrivate add: aValue.
	self changed: #refinedRelationships.
	^aValue!

refinedRelationshipsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self refinedRelationships at: anIndex.
	self refinedRelationshipsPrivate remove: aValue.
	self refinedRelationshipsPrivate add: aValue before: obj.
	self changed: #refinedRelationships.
	^aValue!

refinedRelationshipsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self refinedRelationshipsPrivate remove: aValue.
	self changed: #refinedRelationships.
	^aValue! !

!CODERelationshipRefinement publicMethodsFor: 'associations testing'!

refinedRelationshipsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^refinedRelationships isNil
		ifTrue: [false]
		ifFalse: [self refinedRelationships includes: aValue]!

refinedRelationshipsSize
	"Generated by ISF/AD. Do not modify"
	^refinedRelationships isNil
		ifTrue: [0]
		 ifFalse: [refinedRelationships size]! !

!CODERelationshipRefinement publicMethodsFor: 'derived accessing'!

allRefinedFeatures

	^self allRefinedRelationships!

allRefinedRelationships

	| someRelationships |
	someRelationships := IdentitySet new: 13.
	self allRefinedRelationshipsInto: someRelationships.
	^someRelationships!

allRefinedRelationshipsInto: theSet

	(theSet includes: self) ifTrue: [ ^self].

	theSet add: self.

	self refinedRelationships do: [:aRel | aRel allRefinedRelationshipsInto: theSet]!

refinedFeatures

	^self refinedRelationships!

withAllRefinedRelationshipsInto: theRelationships

	theRelationships isNil ifTrue: [ ^self].
	(theRelationships includes: self) ifTrue: [ ^self]. 
	theRelationships add: self.
	self refinedRelationshipsPrivate do: [:aRelationship |
		aRelationship withAlllRefinedRelationshipsInto: theRelationships
	].! !

!CODERelationshipRefinement publicMethodsFor: 'initialize-release'!

release
	
	self changed: #objectDisconnectedOfTree.

	self refinedRelationshipsRelease.

	super release.! !

!CODERelationshipRefinement publicMethodsFor: 'persistence-code'!

firstPersistenceIndexRelationshipRefinement
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		self numberPersistenceEntriesRelationship  +
		1!

initFromValues: theValues
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexRelationshipRefinement.

	theValues size < aFPI ifFalse: [  self initReferencedRefinedRelationshipsFromValues:  (theValues at: aFPI) ].

	theValues size < (aFPI + 1) ifFalse: [  self initRefinedMetaAttributeNamesFromValues:  (theValues at: (aFPI + 1)) ].!

initReferencedRefinedRelationshipsFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class refinedRelationshipsPersistenceSymbol ifFalse: [ ^nil].

	refinedRelationshipsRefTmpValues := theValues.!

initRefinedMetaAttributeNamesFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	refinedMetaAttributeNames := IdentitySet new: (theValues size * 1.5) floor.
	theValues do: [:aValue |  | aValueAsSymbol | 
		aValueAsSymbol := aValue asSymbol.
		refinedMetaAttributeNames add: aValueAsSymbol 
	]!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	self referencedRefinedRelationshipAsCodeStringOn: theStream indent: theIS.

	self refinedMetaAttributeNamesPersistenceAsCodeStringOn: theStream indent: theIS!

numberPersistenceEntriesRelationshipRefinement
	^1!

ph2InitFromSolver: theSolver

	super ph2InitFromSolver: theSolver.
	self ph2InitReferencedRefinedRelationshipsValuesFromSolver: theSolver.!

ph2InitReferencedRefinedRelationshipsValuesFromSolver: theSolver
	
	| someRelationships |

	(refinedRelationshipsRefTmpValues isNil or: [ refinedRelationshipsRefTmpValues isEmpty]) ifTrue: [ ^self].

	someRelationships := 
		CODEElement resolveOrNewReferencedRelationshipsCollectionFromPersistenceAsCode: refinedRelationshipsRefTmpValues  solver: theSolver.
	self refinedRelationshipsPrivate  addAll: someRelationships.
	someRelationships do: [:aC | aC relationshipRefinementsPrivate add: self].

	refinedRelationshipsRefTmpValues := nil!

referencedRefinedRelationshipAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	theStream isNil ifTrue: [ ^self]. 


	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self refinedRelationshipsPrivate isNil not and: [ self refinedRelationshipsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class refinedRelationshipsPersistenceSymbol); cr
			].
			self refinedRelationshipsPrivate do:  [:aRel |
				aRel asReferenceAs: self class refToRefinedRelationshipKindSymbol codeStringOn: theStream 
					indent: anIS , self indentStringForPersistenceAsCode
			].

			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

refinedMetaAttributeNamesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep someRefinedMetaAttributeNames |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.

	(someRefinedMetaAttributeNames isNil not and: [ someRefinedMetaAttributeNames isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream  nextPutAll: anIS;  nextPutAll: '('; nextPutAll: aSep.
				someRefinedMetaAttributeNames do: [:aMetaAttributeName | 
					theStream nextPutAll: (self pcForV: aMetaAttributeName) ; nextPutAll: aSep
				].
			 	theStream nextPutAll: ' )' ; cr
			].
		].! !

!CODERelationshipRefinement publicMethodsFor: 'semantic checking'!

checkRefinedRelationshipsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRefinedRelationshipsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODERelationshipRefinement publicMethodsFor: 'semantic links'!

refinedRelationshipsCandidates
	"Generated by ISF/AD. Do not modify"
	^self refinedRelationships asArray!

refinedRelationshipScope
	"Generated by ISF/AD. Do not modify"
	^nil!

refinedRelationshipsCreate
	"Generated by ISF/AD. Do not modify"
	^CODERelationship new!

refinedRelationshipsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self refinedRelationshipsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self refinedRelationshipsAdd: anObject.!

refinedRelationshipsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self refinedRelationshipsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self refinedRelationshipsCreate class
		ifUnchanged: [^self].
	self refinedRelationshipsAdd: anObject!

refinedRelationshipsScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODERelationshipRefinement publicMethodsFor: 'semantic links-custom'!

refinedRelationshipsLinkCreate

	| someTypes aSelectedType |

	someTypes := self refinedRelationshipCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as RefinedRelationship of Type\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a name < b name].

	aSelectedType := Dialog 
		choose: ('					Please, select a Type as RefinedRelationship of Type					\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | (anException returnWith: aType name) , ' ' ,   aType allContainerNamespaceNames ]
				do: [ aType displayName ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	self refinedRelationshipsAdd: aSelectedType.

	^aSelectedType! !

!CODERelationshipRefinement publicMethodsFor: 'testing'!

isRefinement
	^true! !

!CODERelationshipRefinement publicMethodsFor: 'updating refinements'!

clearAsRefined: theMetaAttributeName 
	
	| someRefinableMetaAttributeNames someRefinedMetaAttributeNames |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^self].

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.
	someRefinedMetaAttributeNames isNil  ifTrue: [ ^self].

	someRefinedMetaAttributeNames remove: theMetaAttributeName ifAbsent: [ nil].!

determineIfRefiningMetaAttributeNamed: theMetaAttributeName
	| anOwnValue aValueFromRefined |

	anOwnValue := self ownValue: theMetaAttributeName.
	aValueFromRefined := self valueFromRefined: theMetaAttributeName.

	(((anOwnValue isNil or: [ (anOwnValue isKindOf: Collection) and: [ anOwnValue isEmpty]]) and: [ 
		aValueFromRefined isNil or: [ (aValueFromRefined isKindOf: Collection) and: [ aValueFromRefined isEmpty]]]) or: [ anOwnValue = aValueFromRefined]) 
		ifTrue: [ self clearAsRefined: theMetaAttributeName]
		ifFalse: [  self setAsRefined: theMetaAttributeName].!

determineIfRefiningMetaAttributes

	| someRefinableMetaAttributeNames |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	someRefinableMetaAttributeNames do: [:aRefinableMetaAttributeName |
		self determineIfRefiningMetaAttributeNamed: aRefinableMetaAttributeName
	]!

ownValue: theMetaAttributeName 
	
	| someRefinableMetaAttributeNames aMetaAttributeName aValue |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [ ^nil].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^nil].

	aMetaAttributeName := (theMetaAttributeName copyWithout: $:) asSymbol.

	aValue := self perform: aMetaAttributeName.
	 ^aValue!

refinedMetaAttributeNames
	refinedMetaAttributeNames isNil ifTrue: [ refinedMetaAttributeNames := IdentitySet new: 29].
	^refinedMetaAttributeNames!

resetRefinedValueToInheritedValue: theMetaAttributeName 
	
	| someRefinableMetaAttributeNames someRefinedMetaAttributeNames anInheritedValue |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^self].

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.
	someRefinedMetaAttributeNames isNil  ifTrue: [ ^self].

	self clearAsRefined: theMetaAttributeName.

	anInheritedValue := self valueFromRefined: theMetaAttributeName.
	self perform: theMetaAttributeName with: anInheritedValue!

setAsRefined: theMetaAttributeName
	
	| someRefinableMetaAttributeNames someRefinedMetaAttributeNames |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^self].

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.
	someRefinedMetaAttributeNames isNil  ifTrue: [ ^self].

	someRefinedMetaAttributeNames add: theMetaAttributeName.!

updateFromRefined: theMetaAttributeName value: theValue
	
	| someRefinableMetaAttributeNames someRefinedMetaAttributeNames |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [  ^self].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^self].

	someRefinedMetaAttributeNames := self refinedMetaAttributeNames.
	someRefinedMetaAttributeNames isNil ifTrue: [ ^self].

	(someRefinedMetaAttributeNames includes: theMetaAttributeName) ifTrue: [ ^self].

	self perform: theMetaAttributeName asSymbol with: theValue!

valueFromRefined: theMetaAttributeName 
	
	| someRefinableMetaAttributeNames someRefinedAttributes aMetaAttributeName |

	someRefinableMetaAttributeNames := self class refinableMetaAttributeNames.
	someRefinableMetaAttributeNames isNil ifTrue: [ ^nil].

	(someRefinableMetaAttributeNames includes: theMetaAttributeName) ifFalse: [ ^nil].

	aMetaAttributeName := (theMetaAttributeName copyWithout: $:) asSymbol.

	someRefinedAttributes := self refinedRelationships.
	someRefinedAttributes isNil  ifTrue: [ ^nil].

	someRefinedAttributes do: [:anAttribute | | aValue |
		aValue := anAttribute perform: aMetaAttributeName .
		aValue isNil ifFalse: [ ^aValue]
	].
	^nil! !

!CODERelationshipRefinement publicMethodsFor: 'utilities'!

becomeNotARefinement
	| aNewRelationship anInverse aNewInverseRelationship |
	aNewRelationship := self preferredRelationshipClass new name: self name copy.
	aNewRelationship initTerminalMetaAttributesFrom: self.
	aNewRelationship typePrivate: self type.
	aNewRelationship relatedTypePrivate: self relatedType.
	self relationshipRefinements do: [:anRelationshipRefinement |
		aNewRelationship relationshipRefinementsPrivateAdd: anRelationshipRefinement
	].

	anInverse := self inverse.
	(anInverse isNil not and: [ anInverse isRefinement]) ifTrue: [ 
		aNewInverseRelationship := self preferredRelationshipClass new name: self name copy.
		aNewInverseRelationship initTerminalMetaAttributesFrom: anInverse.
		aNewInverseRelationship typePrivate: anInverse type.
		aNewInverseRelationship relatedTypePrivate: anInverse relatedType.
		anInverse relationshipRefinements do: [:anRelationshipRefinement |
			aNewInverseRelationship relationshipRefinementsPrivateAdd: anRelationshipRefinement
		].
	].
	aNewRelationship become: self.
	aNewInverseRelationship become: anInverse! !

!CODEStructuralFeature publicMethodsFor: 'testing'!

isStructuralFeature
	^true! !

!CODEType class publicMethodsFor: 'accessing'!

kind
	^#type! !

!CODEType class publicMethodsFor: 'instance creation'!

new
	"Generated by ISF/AD. Do not modify"
	^self basicNew initialize! !

!CODEType class publicMethodsFor: 'navigation'!

modelEditorMETAPerspectives

	^self modelEditorMETAPerspectivesGeneral, 
		self modelEditorMETAPerspectivesType, super modelEditorMETAPerspectives, 
		self modelEditorMETAPerspectivesTranslation!

modelEditorMETAPerspectivesGeneral
	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'General'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #('Name' 'Kind' 'NLSName' 'NLSKind' 'AllContainerNamespaceNames' 'IsDirty' 'IsUse' 'IsAbstract' 'IsEnumeration' 'IsPrimitive' 'IsExclussion' 'IsVirtual'  'IsHomeRooted' 'IsHomeIDProvider' 'PrimitiveInitializationString' 'ReengineredClassName' 'StoreClassName' 'StoreMethodSelector')))
			nlsApp: 'CODE';
			nlsGroup: 'General_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		yourself!

modelEditorMETAPerspectivesType
 	^OrderedCollection new
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Relationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Relationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Attributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Attributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Operations'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'Operations' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'SuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllSuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllSuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllNonAbstractSuperTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllNonAbstractSuperTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTiposNoAbstractos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'SubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'SubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllSubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllSubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'WithAllNonAbstractSubTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'WithAllNonAbstractSubTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'WithAllNonAbstractSubTypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);

		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAggregatedRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAggregatedRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAggregatedRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAggregatedRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAggregatedRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllAttributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllAttributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfAttributes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfAttributes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfAttributes';
			nlsTranslation: 'TipoDeAtributos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfArguments'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfArguments' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfArguments';
			nlsTranslation: 'TipoDeArgumentosDeOperacion';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'TypeOfReturns'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'TypeOfReturns' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'TypeOfReturns';
			nlsTranslation: 'TipoDeResultadosDeOperacion';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllRelationships';
			nlsTranslation: 'TodasLasRelaciones';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonRefinedRelationships'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonRefinedRelationships' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonRefinedRelationships';
			nlsTranslation: 'TodasLasRelacionesNoRefinadas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionados';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllPolymorphicallyRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllPolymorphicallyRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'General';
			nlsTranslation: 'General';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllPolymorphicallyRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionadosPolimorficamente';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors;
				metaSelectorsToSelect: #( 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllEffectiveFeatures'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllEffectiveFeatures' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'AllEffectiveFeatures';
			nlsTranslation: 'TodasLasCaracteristicasEfectivas';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Module'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Module' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Module';
			nlsTranslation: 'Modulo';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Observers'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('Observers' )))
			nlsApp: 'CODE';
			nlsGroup: 'Type_Perspectives';
			nlsItem: 'Observers';
			nlsTranslation: 'Observadores';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'Types'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #( 'Types' )))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'Types';
			nlsTranslation: 'Tipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'RootTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('RootTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'RootTypes';
			nlsTranslation: 'TodosLosTiposSinSuperTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'AllTypes';
			nlsTranslation: 'TodosLosTipos';
			yourself);
		addLast:  (((Smalltalk at: #METAPerspectiveSpec)  
			name: 'AllNonAbstractTypes'
			view: ((Smalltalk at: #METACachedView) new
				metaSelectorsSource:  self; 
				metaSelectorsSelector: #modelEditorMETASelectors;
				pathSelectorsSelector: #modelEditorPathSelectors; 
				metaSelectorsToSelect: #('AllNonAbstractTypes')))
			nlsApp: 'CODE';
			nlsGroup: 'Module_Perspectives';
			nlsItem: 'AllNonAbstractTypes';
			nlsTranslation: 'TodosLosTiposNoAbstractos';
			yourself);
		yourself!

modelEditorMETASelectors

	^super modelEditorMETASelectors , self modelEditorMETASelectorsType,
		self modelEditorMETASelectorsTranslation!

modelEditorMETASelectorsType

	"METAChildSpecAutoViewEditor openOn: CODEType selector: #modelEditorMETASelectorsType target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsUse';
			basicSelector: #isUse;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsUse';
			displaySelector: nil;
			canShowInTree: false;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsUse';
			nlsTranslation: 'EsUso';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsEnumeration';
			nlsTranslation: 'EsEnumeracion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsPrimitive';
			nlsTranslation: 'EsPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsVirtual';
			basicSelector: #isVirtual;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsVirtual';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsVirtual';
			nlsTranslation: 'EsVirtual';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeRooted';
			basicSelector: #isHomeRooted;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeRooted';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeRooted';
			nlsTranslation: 'EsArraigadoEnOrigen';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeIDProvider';
			basicSelector: #isHomeIDProvider;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeIDProvider';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeIDProvider';
			nlsTranslation: 'OrigenProveeIDs';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrimitiveInitializationString';
			basicSelector: #primitiveInitializationString;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrimitiveInitializationString';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'PrimitiveInitializationString';
			nlsTranslation: 'InicializacionValorPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReengineredClassName';
			basicSelector: #reengineredClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ReengineredClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'ReengineredClassName';
			nlsTranslation: 'NombreDeClasePrograma';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreClassName';
			basicSelector: #storeClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreClassName';
			nlsTranslation: 'ClaseDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreMethodSelector';
			basicSelector: #storeMethodSelector;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreMethodSelector';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreMethodSelector';
			nlsTranslation: 'SelectorDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Operations';
			basicSelector: #operations;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Operations';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSuperTypes';
			basicSelector: #withAllSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSuperTypes';
			basicSelector: #withAllNonAbstractSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'COnTodosLosSuperTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSubTypes';
			basicSelector: #withAllSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSubTypes';
			basicSelector: #withAllNonAbstractSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSubtypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSubtypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregationRelationships';
			basicSelector: #allAggregationRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregationRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregationRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);

		addAll: self modelEditorMETASelectorsType2;
		addAll: self modelEditorMETASelectorsType3;

		yourself!

modelEditorMETASelectorsType2

	"METAChildSpecAutoViewEditor openOn: CODEType selector: #modelEditorMETASelectorsType2 target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelationships';
			basicSelector: #allNonDummyRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonDummyRelationships';
			nlsTranslation: 'AllNonDummyRelationships';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelationships';
			basicSelector: #allRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllRelationships';
			nlsTranslation: 'TodasLasRelaciones';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonRefinedRelationships';
			basicSelector: #allNonRefinedRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonRefinedRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonRefinedRelationships';
			nlsTranslation: 'TodasLasRelacionesNoRefinadas';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelatedTypes';
			basicSelector: #allNonDummyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelatedTypes';
			basicSelector: #allRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllRelatedTypes';
			nlsTranslation: 'TodosLosTiposRelacionados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllPolymorphicallyRelatedTypes';
			basicSelector: #allPolymorphicallyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllPolymorphicallyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllPolymorphicallyRelatedTypes';
			nlsTranslation: 'TodosLosTiposPolimorficamenteRelacionados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			basicSelector: #allNonAbstractPolymorphicallyAggregationRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			nlsTranslation: 'AllNonAbstractPolymorphicallyAggregationRelatedTypes';
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Module';
			basicSelector: #module;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Module';
			displaySelector: #name;
			canShowInTree: true;
			objectClassName: #CODEModule;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Module';
			nlsTranslation: 'Modulo';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfAttributes';
			basicSelector: #typeOfValues;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfAttributes';
			nlsTranslation: 'TipoDeAtributos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfArguments';
			basicSelector: #typeOfArguments;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfArguments';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEArgument;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfArguments';
			nlsTranslation: 'TipoDeArgumentosDeOperacion';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TypeOfOperationReturns';
			basicSelector: #typeOfReturns;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TypeOfOperationReturns';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'TypeOfOperationReturns';
			nlsTranslation: 'TipoDeResultadosDeOperacion';
			yourself);

		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllEffectiveFeatures';
			basicSelector: #allEffectiveFeatures;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllEffectiveFeatures';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEElement;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllEffectiveFeatures';
			nlsTranslation: 'TodasLasCaracteristicasEfectivas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Observers';
			basicSelector: #observers;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Observers';
			displaySelector: #displayName;
			canShowInTree: true;
			componentsClassName: #CMTypeObserver;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Observers';
			nlsTranslation: 'Observadores';
			yourself);
		yourself!

modelEditorMETASelectorsType3

	"METAChildSpecAutoViewEditor openOn: CODEType selector: #modelEditorMETASelectorsType3 target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METACollectionDBCChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Types';
			basicSelector: #types;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #nlsName;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Types';
			nlsTranslation: 'Tipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RootTypes';
			basicSelector: #rootTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Types without Supertypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'RootTypes';
			nlsTranslation: 'TiposRaiz';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllTypes';
			basicSelector: #allTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'All the Types in the Module and subModules';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllTypes';
			nlsTranslation: 'TodosLosTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonAbstractTypes';
			basicSelector: #allNonAbstractTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonAbstractTypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllNonAbstractTypes';
			nlsTranslation: 'TodosLosTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllContainerNamespaceNames';
			basicSelector: #allContainerNamespaceNames;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllContainerNamespaceNames';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllContainerNamespaceNames';
			nlsTranslation: 'Namespace contenedor completamente cualificado';
			yourself);

		yourself!

modelEditorPathSelectors

	| aLocalView |
	aLocalView := self modelEditorPathSelectorsType.

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: aLocalView metaSelectorsSelector;
		pathSelectorsSelector: aLocalView pathSelectorsSelector;
		metaSelectorsToSelect: aLocalView metaSelectorsToSelect, super modelEditorPathSelectors metaSelectorsToSelect,
			self modelEditorPathSelectorsTranslation metaSelectorsToSelect!

modelEditorPathSelectorsType

	^METACachedView new
		metaSelectorsSource:  self;
		metaSelectorsSelector: #modelEditorMETASelectors;
		pathSelectorsSelector: #modelEditorPathSelectors;
		metaSelectorsToSelect: #('Relationships' 'Attributes' 'Operations' 'SuperTypes' 'SubTypes'  'TypeOfAttributes' 'TypeOfArguments' 'TypeOfReturns' 'AllEffectiveFeatures' 'WithAllSuperTypes'  'WithAllNonAbstractSuperTypes'  'WithAllSubTypes'  'WithAllNonAbstractSubTypes' 
			'AllAggregatedRelatedTypes' 'AllAggregatedRelationships' 'AllAttributes' 'AllRelationships' 'AllNonRefinedRelationships' 'AllRelatedTypes' 
			'AllPolymorphicallyRelatedTypes'  'AllNonAbstractPolymorphicallyRelatedTypes' 'AllNonAbstractPolymorphicallyAggregatedRelatedTypes' 'AllNonAbstractPolymorphicallyAggregatedIntoRelatedTypes' 'Observers'  'Types'  'RootTypes' 'AllTypes' 'AllNonAbstractTypes')!

xmetaSelectors

	"METAChildSpecAutoViewEditor openOn: CODEType selector: #metaSelectors target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 27)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Name';
			basicSelector: #name;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Name';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelationships';
			basicSelector: #allAggregatedRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelationships';
			basicSelector: #allNonDummyRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelationships';
			basicSelector: #allRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllNonDummyRelatedTypes';
			basicSelector: #allNonDummyRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllNonDummyRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllRelatedTypes';
			basicSelector: #allRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllRelatedTypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: #superType;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelationshipsToGenerate';
			basicSelector: #relationshipsToGenerate;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelationshipsToGenerate';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: #superType;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AttributesToGenerate';
			basicSelector: #attributesToGenerate;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AttributesToGenerate';
			displaySelector: #name;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			componentsClassName: #CODEType;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'RelatedWith';
			basicSelector: #relatedWith;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'RelatedWith';
			displaySelector: #name;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Module';
			basicSelector: #module;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Module';
			displaySelector: #name;
			objectClassName: #CODEModule;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			yourself);
		add: ((Smalltalk at: #METAClassChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Model';
			basicSelector: #model;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Model';
			displaySelector: #name;
			objectClassName: #CODEModel;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			showInEditor: true;
			menuSelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'BaseOutFileName';
			basicSelector: #baseOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'BaseOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ImplOutFileName';
			basicSelector: #implOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ImplOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IfcOutFileName';
			basicSelector: #ifcOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IfcOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'TrxOutFileName';
			basicSelector: #trxOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'TrxOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrivOutFileName';
			basicSelector: #privOutFileName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrivOutFileName';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Skip';
			basicSelector: #skip;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Skip';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsRootType';
			basicSelector: #isRootType;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsRootType';
			displaySelector: nil;
			yourself);
		yourself!

xmodelEditorMETASelectorsType

	"METAChildSpecAutoViewEditor openOn: CODEType selector: #modelEditorMETASelectorsType target: nil selector: nil."

	self ojoMETASelectors.

	^(OrderedCollection new: 26)
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsUse';
			basicSelector: #isUse;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsUse';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsUse';
			nlsTranslation: 'EsUso';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsAbstract';
			basicSelector: #isAbstract;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsAbstract';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsAbstract';
			nlsTranslation: 'EsAbstracto';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsEnumeration';
			basicSelector: #isEnumeration;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsEnumeration';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsEnumeration';
			nlsTranslation: 'EsEnumeracion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsPrimitive';
			basicSelector: #isPrimitive;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsPrimitive';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsPrimitive';
			nlsTranslation: 'EsPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsExclussion';
			basicSelector: #isExclussion;
			type: #Boolean;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsExclussion';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsExclussion';
			nlsTranslation: 'EsExclusion';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsVirtual';
			basicSelector: #isVirtual;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsVirtual';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsVirtual';
			nlsTranslation: 'EsVirtual';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeRooted';
			basicSelector: #isHomeRooted;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeRooted';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeRooted';
			nlsTranslation: 'EsArraigadoEnOrigen';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'IsHomeIDProvider';
			basicSelector: #isHomeIDProvider;
			type: #Boolean;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'IsHomeIDProvider';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'IsHomeIDProvider';
			nlsTranslation: 'OrigenProveeIDs';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'PrimitiveInitializationString';
			basicSelector: #primitiveInitializationString;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'PrimitiveInitializationString';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'PrimitiveInitializationString';
			nlsTranslation: 'InicializacionValorPrimitivo';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'ReengineredClassName';
			basicSelector: #reengineredClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'ReengineredClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'ReengineredClassName';
			nlsTranslation: 'NombreDeClasePrograma';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreClassName';
			basicSelector: #storeClassName;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreClassName';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreClassName';
			nlsTranslation: 'ClaseDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METATerminalChildSpec ifAbsent: [ ^#() copy])  new
			name: 'StoreMethodSelector';
			basicSelector: #storeMethodSelector;
			type: #String;
			displayValue: true;
			isChildren: false;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'StoreMethodSelector';
			displaySelector: nil;
			canShowInTree: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'StoreMethodSelector';
			nlsTranslation: 'SelectorDondeSeGraba';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Attributes';
			basicSelector: #attributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Attributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Attributes';
			nlsTranslation: 'Atributos';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Relationships';
			basicSelector: #relationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Relationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Relationships';
			nlsTranslation: 'Relaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'Operations';
			basicSelector: #operations;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'Operations';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEOperation;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'Operations';
			nlsTranslation: 'Operaciones';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SuperTypes';
			basicSelector: #superTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: false;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SuperTypes';
			nlsTranslation: 'SuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSuperTypes';
			basicSelector: #withAllSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSuperTypes';
			nlsTranslation: 'ConTodosLosSuperTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSuperTypes';
			basicSelector: #withAllNonAbstractSuperTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSuperTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSuperTypes';
			nlsTranslation: 'COnTodosLosSuperTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'SubTypes';
			basicSelector: #subTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'SubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'SubTypes';
			nlsTranslation: 'SubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllSubTypes';
			basicSelector: #withAllSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllSubTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllSubTypes';
			nlsTranslation: 'ConTodosLosSubTipos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'WithAllNonAbstractSubTypes';
			basicSelector: #withAllNonAbstractSubtypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'WithAllNonAbstractSubtypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEType;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'WithAllNonAbstractSubtypes';
			nlsTranslation: 'ConTodosLosSubTiposNoAbstractos';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregatedRelatedTypes';
			basicSelector: #allAggregatedIntoRelatedTypes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregatedRelatedTypes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregatedRelatedTypes';
			nlsTranslation: 'TodosLosTiposAgregados';
			yourself);
		add: ((Smalltalk at: #METACollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAggregationRelationships';
			basicSelector: #allAggregationRelationships;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAggregationRelationships';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODERelationship;
			sortSelector: #name;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAggregationRelationships';
			nlsTranslation: 'TodasLasRelacionesAgregadas';
			yourself);
		add: ((Smalltalk at: #METAOrderedCollectionChildSpec ifAbsent: [ ^#() copy])  new
			name: 'AllAttributes';
			basicSelector: #allAttributes;
			type: #Object;
			displayValue: true;
			isChildren: true;
			isStatic: true;
			creationPolicy: #Default;
			creationMode: #Create;
			helpString: 'AllAttributes';
			displaySelector: #name;
			canShowInTree: true;
			componentsClassName: #CODEAttribute;
			sortSelector: nil;
			deletionPolicy: #Default;
			deletionMode: #Default;
			showChildren: true;
			inheritanceLinkSelector: nil;
			menuSelector: nil;
			autoFilter: true;
			nlsApp: 'CODE';
			nlsGroup: 'Type_Selectors';
			nlsItem: 'AllAttributes';
			nlsTranslation: 'TodosLosAtributos';
			yourself);

		addAll: self modelEditorMETASelectorsType2;
		addAll: self modelEditorMETASelectorsType3;

		yourself! !

!CODEType class publicMethodsFor: 'persistence-code'!

attributesPersistenceSymbol	
	^#attributes!

refToSuperTypeKindSymbol
	^self refToTypeKindSymbol!

relationshipsPersistenceSymbol	
	^#relationships!

superTypesPersistenceSymbol	
	^#supertypes! !

!CODEType publicMethodsFor: 'accessing'!

baseOutFileName
	"Generated by ISF/AD. Do not modify"
	baseOutFileName isNil
		ifTrue: [self initBaseOutFileName].
	^baseOutFileName!

baseOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkBaseOutFileName: aValue) ifFalse: [^aValue].
	baseOutFileName := aValue.
	self changed: #baseOutFileName!

baseOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	baseOutPrjNdx isNil
		ifTrue: [self initBaseOutPrjNdx].
	^baseOutPrjNdx!

baseOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkBaseOutPrjNdx: aValue) ifFalse: [^aValue].
	baseOutPrjNdx := aValue.
	self changed: #baseOutPrjNdx!

chooserOutFileName
	"Generated by ISF/AD. Do not modify"
	chooserOutFileName isNil
		ifTrue: [self initChooserOutFileName].
	^chooserOutFileName!

custOutFileName
	"Generated by ISF/AD. Do not modify"
	custOutFileName isNil
		ifTrue: [self initCustOutFileName].
	^custOutFileName!

custOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkCustOutFileName: aValue) ifFalse: [^aValue].
	custOutFileName := aValue.
	self changed: #custOutFileName!

deleteActionOutFileName
	"Generated by ISF/AD. Do not modify"
	deleteActionOutFileName isNil
		ifTrue: [self initDeleteActionOutFileName].
	^deleteActionOutFileName!

deleteActionOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkDeleteActionOutFileName: aValue) ifFalse: [^aValue].
	deleteActionOutFileName := aValue.
	self changed: #deleteActionOutFileName!

ifcOutFileName
	"Generated by ISF/AD. Do not modify"
	ifcOutFileName isNil
		ifTrue: [self initIfcOutFileName].
	^ifcOutFileName!

ifcOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIfcOutFileName: aValue) ifFalse: [^aValue].
	ifcOutFileName := aValue.
	self changed: #ifcOutFileName!

ifcOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	ifcOutPrjNdx isNil
		ifTrue: [self initIfcOutPrjNdx].
	^ifcOutPrjNdx!

ifcOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIfcOutPrjNdx: aValue) ifFalse: [^aValue].
	ifcOutPrjNdx := aValue.
	self changed: #ifcOutPrjNdx!

implOutFileName
	"Generated by ISF/AD. Do not modify"
	implOutFileName isNil
		ifTrue: [self initImplOutFileName].
	^implOutFileName!

implOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkImplOutFileName: aValue) ifFalse: [^aValue].
	implOutFileName := aValue.
	self changed: #implOutFileName!

implOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	implOutPrjNdx isNil
		ifTrue: [self initImplOutPrjNdx].
	^implOutPrjNdx!

implOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkImplOutPrjNdx: aValue) ifFalse: [^aValue].
	implOutPrjNdx := aValue.
	self changed: #implOutPrjNdx!

isAbstract
	"Generated by ISF/AD. Do not modify"
	isAbstract isNil
		ifTrue: [self initIsAbstract].
	^isAbstract!

isAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsAbstract: aValue  == true) ifFalse: [^aValue].
	isAbstract := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isAbstract.
	self allPolymorphicallyRelatedTypes do: [:aT | 
		aT changed: #allNonAbstractPolymorphicallyRelatedTypes].!

isEnumeration
	"Generated by ISF/AD. Do not modify"
	isEnumeration isNil
		ifTrue: [self initIsEnumeration].
	^isEnumeration!

isEnumeration: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsEnumeration: aValue  == true) ifFalse: [^aValue].
	isEnumeration := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isEnumeration!

isExclussion
	"Generated by ISF/AD. Do not modify"
	isExclussion isNil
		ifTrue: [self initIsExclussion].
	^isExclussion!

isExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsExclussion: aValue) ifFalse: [^aValue].
	isExclussion := aValue.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self changed: #isExclussion!

isHomeIDProvider
	isHomeIDProvider isNil
		ifTrue: [self initIsHomeIDProvider].
	^isHomeIDProvider!

isHomeIDProvider: aValue
	(self checkIsHomeIDProvider: aValue  == true) ifFalse: [^aValue].
	isHomeIDProvider := aValue == true.
	self markDirty.
	self changed: #isHomeIDProvider!

isHomeRooted
	isHomeRooted isNil
		ifTrue: [self initIsHomeRooted].
	^isHomeRooted!

isHomeRooted: aValue
	(self checkIsHomeRooted: aValue  == true) ifFalse: [^aValue].
	isHomeRooted := aValue == true.
	self markDirty.
	self changed: #isHomeRooted!

isJustUsed
	"Generated by ISF/AD. Do not modify"
	isJustUsed isNil
		ifTrue: [self initIsJustUsed].
	^isJustUsed!

isJustUsed: aValue
	self isJustUsed = aValue ifTrue: [ ^aValue].
	isJustUsed := aValue == true.

	self changed: #isJustUsed.!

isPrimitive
	"Generated by ISF/AD. Do not modify"
	isPrimitive isNil
		ifTrue: [self initIsPrimitive].
	^isPrimitive!

isPrimitive: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsPrimitive: aValue  == true) ifFalse: [^aValue].
	isPrimitive := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.
	self changed: #isPrimitive!

isRequiredFeaturesType
	^isRequiredFeaturesType == true!

isRequiredFeaturesType: theValue
	isRequiredFeaturesType := theValue == true!

isUse
	"Generated by ISF/AD. Do not modify"
	isUse isNil
		ifTrue: [self initIsUse].
	^isUse!

isUse: aValue
	(self checkIsUse: aValue  == true) ifFalse: [^aValue].
	self isUse = aValue ifTrue: [ ^aValue].
	isUse := aValue == true.
	self markDirty.
	self invalidateMemberInstanceTypesCache.

	self updateUses.

	self changed: #isUse.!

isVirtual
	"Generated by ISF/AD. Do not modify"
	isVirtual isNil
		ifTrue: [self initIsVirtual].
	^isVirtual!

isVirtual: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkIsVirtual: aValue) ifFalse: [^aValue].
	isVirtual := aValue.
	self markDirty.
	self invalidateMemberInstanceTypesCache.
	self changed: #isVirtual!

metaOutFileName
	"Generated by ISF/AD. Do not modify"
	metaOutFileName isNil
		ifTrue: [self initMetaOutFileName].
	^metaOutFileName!

metaOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkMetaOutFileName: aValue) ifFalse: [^aValue].
	metaOutFileName := aValue.
	self changed: #metaOutFileName!

name: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkName: aValue) ifFalse: [^aValue].
	name := aValue.
	self markDirty.
	self changed: #name.

	self notifyFullyQualifiedNameChanged!

nmgrOutFileName
	"Generated by ISF/AD. Do not modify"
	nmgrOutFileName isNil
		ifTrue: [self initNmgrOutFileName].
	^nmgrOutFileName!

observers
	^observers!

primitiveInitializationString
	^primitiveInitializationString!

primitiveInitializationString: aValue
	primitiveInitializationString := aValue.
	self changed: #primitiveInitializationString!

privOutFileName
	"Generated by ISF/AD. Do not modify"
	privOutFileName isNil
		ifTrue: [self initPrivOutFileName].
	^privOutFileName!

privOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkPrivOutFileName: aValue) ifFalse: [^aValue].
	privOutFileName := aValue.
	self changed: #privOutFileName!

privOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	privOutPrjNdx isNil
		ifTrue: [self initPrivOutPrjNdx].
	^privOutPrjNdx!

privOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkPrivOutPrjNdx: aValue) ifFalse: [^aValue].
	privOutPrjNdx := aValue.
	self changed: #privOutPrjNdx!

pubOutFileName
	"Generated by ISF/AD. Do not modify"
	pubOutFileName isNil
		ifTrue: [self initPubOutFileName].
	^pubOutFileName!

pubOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkPubOutFileName: aValue) ifFalse: [^aValue].
	pubOutFileName := aValue.
	self changed: #pubOutFileName!

reengineredClassName
	^reengineredClassName!

reengineredClassName: aValue
	reengineredClassName := aValue.
	self changed: #reengineredClassName!

skip
	"Generated by ISF/AD. Do not modify"
	skip isNil
		ifTrue: [self initSkip].
	^skip!

skip: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSkip: aValue) ifFalse: [^aValue].
	skip := aValue.
	self changed: #skip!

storeClassName
	^storeClassName!

storeClassName: elValor
	| unValor unosStrings |
	unValor := (elValor isNil or: [ elValor isEmpty])
		ifTrue: [ nil] 
		ifFalse: [ 	
			unosStrings := elValor  asArrayOfSubstrings.
			unosStrings isEmpty
				ifTrue: [ nil]
				ifFalse: [ 
					unosStrings size > 1
						ifTrue: [ unosStrings first asSymbol]
						ifFalse: [ elValor asSymbol]
				]
		].
	
	unValor = storeClassName  ifTrue: [ ^self].

	storeClassName := unValor.
	self markDirty.

	self changed: #storeClassName!

storeMethodSelector
	^storeMethodSelector!

storeMethodSelector: elValor
	| unValor unosStrings |
	unValor := (elValor isNil or: [ elValor isEmpty])
		ifTrue: [ nil] 
		ifFalse: [ 	
			unosStrings := elValor  asArrayOfSubstrings.
			unosStrings isEmpty
				ifTrue: [ nil]
				ifFalse: [ 
					unosStrings size > 1
						ifTrue: [ unosStrings first asSymbol]
						ifFalse: [ elValor asSymbol]
				]
		].
	
	unValor = storeMethodSelector  ifTrue: [ ^self].

	storeMethodSelector := unValor.
	self markDirty.

	self changed: #storeMethodSelector!

trxOutFileName
	"Generated by ISF/AD. Do not modify"
	trxOutFileName isNil
		ifTrue: [self initTrxOutFileName].
	^trxOutFileName!

trxOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTrxOutFileName: aValue) ifFalse: [^aValue].
	trxOutFileName := aValue.
	self changed: #trxOutFileName!

trxOutPrjNdx
	"Generated by ISF/AD. Do not modify"
	trxOutPrjNdx isNil
		ifTrue: [self initTrxOutPrjNdx].
	^trxOutPrjNdx!

trxOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTrxOutPrjNdx: aValue) ifFalse: [^aValue].
	trxOutPrjNdx := aValue.
	self changed: #trxOutPrjNdx! !

!CODEType publicMethodsFor: 'accessing-find'!

hasTypeNamed: theTypeName
	
	^(self typeNamed: theTypeName) isNil not!

typeNamed: theTypeName
	
	| anExistingType |
	theTypeName isNil ifTrue: [ ^self].
	(theTypeName findString: '::' startingAt: 1 ) > 0 ifTrue: [  ^self findTypeNamed: theTypeName].

	anExistingType := self typesPrivate detect: [:aType | aType name = theTypeName] ifNone: [ nil].
	^anExistingType! !

!CODEType publicMethodsFor: 'accessing-private'!

forzeIsAbstract: aValue
	isAbstract := aValue == true.!

forzeIsEnumeration: aValue
	isEnumeration := aValue == true.!

forzeIsExclussion: aValue
	isExclussion := aValue == true.!

forzeIsHomeIDProvider: aValue
	isHomeIDProvider := aValue == true.!

forzeIsHomeRooted: aValue
	isHomeRooted := aValue == true.!

forzeIsJustUsed: aValue
	isJustUsed := aValue == true.!

forzeIsPrimitive: aValue
	isPrimitive := aValue == true.!

forzeIsUse: aValue
	isUse := aValue == true.!

forzeIsVirtual: aValue
	isVirtual := aValue == true.!

forzePrimitiveInitializationString: aValue
	primitiveInitializationString := aValue!

forzeReengineredClassName: aValue
	reengineredClassName := aValue!

forzeStoreClassName: aValue
	storeClassName := aValue!

forzeStoreMethodSelector: aValue
	storeMethodSelector := aValue! !

!CODEType publicMethodsFor: 'association initialize-release'!

attributesRelease
	"Generated by ISF/AD. Do not modify"
	self attributes do: [:each | self attributesRemove: each]!

initAttributes
	"Generated by ISF/AD. Do not modify"
	attributes :=OrderedCollection new.!

initOperations
	"Generated by ISF/AD. Do not modify"
	operations :=OrderedCollection new.!

initRelatedWith
	"Generated by ISF/AD. Do not modify"
	relatedWith := IdentitySet new.!

initRelationships
	"Generated by ISF/AD. Do not modify"
	relationships := OrderedCollection new.!

initSubTypes
	"Generated by ISF/AD. Do not modify"
	subTypes := IdentitySet new.!

initSuperTypes
	"Generated by ISF/AD. Do not modify"
	superTypes := OrderedCollection new.!

initTypeOfArguments
	"Generated by ISF/AD. Do not modify"
	typeOfArguments := IdentitySet new.!

initTypeOfReturns
	"Generated by ISF/AD. Do not modify"
	typeOfReturns := IdentitySet new.!

initTypeOfValues
	"Generated by ISF/AD. Do not modify"
	typeOfValues := IdentitySet new.!

initTypes
	"Generated by ISF/AD. Do not modify"
	types := OrderedCollection new.!

moduleRelease
	"Generated by ISF/AD. Do not modify"
	module == nil
		ifFalse:
			[module typesPrivateRemove: self.
				module := nil.
				self changed: #module]!

operationsRelease
	"Generated by ISF/AD. Do not modify"
	self operations do: [:each | self operationsRemove: each]!

relatedWithRelease
	"Generated by ISF/AD. Do not modify"
	self relatedWith do: [:each | self relatedWithRemove: each]!

relationshipsRelease
	"Generated by ISF/AD. Do not modify"
	self relationships do: [:each | self relationshipsRemove: each]!

subTypesRelease
	"Generated by ISF/AD. Do not modify"
	self subTypes do: [:each | self subTypesRemove: each]!

superTypesRelease
	"Generated by ISF/AD. Do not modify"
	self superTypes do: [:each | self superTypesRemove: each]!

typeOfArgumentsRelease
	"Generated by ISF/AD. Do not modify"
	self typeOfArguments do: [:each | self typeOfArgumentsRemove: each]!

typeOfReturnsRelease
	"Generated by ISF/AD. Do not modify"
	self typeOfReturns do: [:each | self typeOfReturnsRemove: each]!

typeOfValuesRelease
	"Generated by ISF/AD. Do not modify"
	self typeOfValues do: [:each | self typeOfValuesRemove: each]!

typesRelease
	"Generated by ISF/AD. Do not modify"
	self types do: [:each | self typesRemove: each]! !

!CODEType publicMethodsFor: 'associations accessing'!

attributes
	"Generated by ISF/AD. Do not modify"
	^self attributesPrivate copy!

attributesAsArray
	"Generated by ISF/AD. Do not modify"
	^self attributes asArray!

module
	"Generated by ISF/AD. Do not modify"
	^module!

module: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkModule: aValue) ifFalse: [^aValue].
	module == aValue ifTrue: [ ^self].
	self moduleRelease.
	module := aValue.
	aValue == nil ifFalse: [aValue typesPrivateAdd: self].
	self changed: #module!

operations
	"Generated by ISF/AD. Do not modify"
	^self operationsPrivate copy!

operationsAsArray
	"Generated by ISF/AD. Do not modify"
	^self operations asArray!

relatedWith
	"Generated by ISF/AD. Do not modify"
	^self relatedWithPrivate copy!

relatedWithAsArray
	"Generated by ISF/AD. Do not modify"
	^self relatedWith asArray!

relationships
	"Generated by ISF/AD. Do not modify"
	^self relationshipsPrivate copy!

relationshipsAsArray
	"Generated by ISF/AD. Do not modify"
	^self relationships asArray!

subTypes
	"Generated by ISF/AD. Do not modify"
	^self subTypesPrivate copy!

subTypesAsArray
	"Generated by ISF/AD. Do not modify"
	^self subTypes asArray!

superTypes
	"Generated by ISF/AD. Do not modify"
	^self superTypesPrivate copy!

superTypesAsArray
	"Generated by ISF/AD. Do not modify"
	^self superTypes asArray!

typeOfArguments
	"Generated by ISF/AD. Do not modify"
	^self typeOfArgumentsPrivate copy!

typeOfArgumentsAsArray
	"Generated by ISF/AD. Do not modify"
	^self typeOfArguments asArray!

typeOfReturns
	"Generated by ISF/AD. Do not modify"
	^self typeOfReturnsPrivate copy!

typeOfReturnsAsArray
	"Generated by ISF/AD. Do not modify"
	^self typeOfReturns asArray!

typeOfValues
	"Generated by ISF/AD. Do not modify"
	^self typeOfValuesPrivate copy!

typeOfValuesAsArray
	"Generated by ISF/AD. Do not modify"
	^self typeOfValues asArray!

types
	"Generated by ISF/AD. Do not modify"
	^self typesPrivate copy!

typesAsArray
	"Generated by ISF/AD. Do not modify"
	^self types asArray! !

!CODEType publicMethodsFor: 'associations modifying'!

attributesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAttributesAdd: aValue) ifFalse: [^aValue].
	(self attributesIncludes: aValue) ifTrue: [^self attributesMoveBottom: aValue].
	(self attributesPrivateAdd: aValue) typePrivate: self.
	
	self invalidateEffectiveAttributesCaches.

	self notifyChangeAllAttributesChildSpecs.
	^aValue!

attributesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self attributesIncludes: aValue) ifFalse: [^aValue].
	(self attributes indexOf: aValue) = self attributesSize ifTrue: [^aValue].
	self attributesPrivate remove: aValue.
	aRes := self attributesPrivateAdd: aValue.

	self invalidateEffectiveAttributesCaches.

	self notifyChangeAllAttributesChildSpecs.

	^aRes!

attributesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self attributesIncludes: aValue) ifFalse: [^aValue].
	(index := self attributes indexOf: aValue) = self attributesSize ifTrue: [^aValue].
	index = (self attributesSize -1)
		ifTrue:
			[self attributesPrivate remove: aValue.
			^self attributesPrivateAdd: aValue].
	aRes := self attributesPrivateMove: aValue beforeIndex: index + 2.

	self invalidateEffectiveAttributesCaches.

	^aRes!

attributesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self attributesIncludes: aValue) ifFalse: [^aValue].
	(self attributes indexOf: aValue) = 1 ifTrue: [^aValue].
	self attributesPrivateMove: aValue beforeIndex: 1.


	self invalidateEffectiveAttributesCaches.


	self notifyChangeAllAttributesChildSpecs.!

attributesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self attributesIncludes: aValue) ifFalse: [^aValue].
	(index := self attributes indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self attributesPrivateMove: aValue beforeIndex: index - 1.

	self invalidateEffectiveAttributesCaches.


	self notifyChangeAllAttributesChildSpecs.
	^aRes!

attributesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkAttributesRemove: aValue) ifFalse: [^aValue].
	(self attributesPrivate remove: aValue ifAbsent: [^aValue]) typePrivate: nil.


	self invalidateEffectiveAttributesCaches.


	self notifyChangeAllAttributesChildSpecs.

	^aValue!

operationsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOperationsAdd: aValue) ifFalse: [^aValue].
	(self operationsIncludes: aValue) ifTrue: [^self operationsMoveBottom: aValue].
	(self operationsPrivateAdd: aValue) typePrivate: self.
	self notifyChangeAllOperationsChildSpecs.
	^aValue!

operationsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self operationsIncludes: aValue) ifFalse: [^aValue].
	(self operations indexOf: aValue) = self operationsSize ifTrue: [^aValue].
	self operationsPrivate remove: aValue.
	aRes := self operationsPrivateAdd: aValue.
	self notifyChangeAllOperationsChildSpecs.
	^aRes!

operationsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self operationsIncludes: aValue) ifFalse: [^aValue].
	(index := self operations indexOf: aValue) = self operationsSize ifTrue: [^aValue].
	index = (self operationsSize -1)
		ifTrue:
			[self operationsPrivate remove: aValue.
			^self operationsPrivateAdd: aValue].
	^self operationsPrivateMove: aValue beforeIndex: index + 2!

operationsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self operationsIncludes: aValue) ifFalse: [^aValue].
	(self operations indexOf: aValue) = 1 ifTrue: [^aValue].
	self operationsPrivateMove: aValue beforeIndex: 1
	self notifyChangeAllOperationsChildSpecs.!

operationsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self operationsIncludes: aValue) ifFalse: [^aValue].
	(index := self operations indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self operationsPrivateMove: aValue beforeIndex: index - 1.
	self notifyChangeAllOperationsChildSpecs.
	^aRes!

operationsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkOperationsRemove: aValue) ifFalse: [^aValue].
	(self operationsPrivate remove: aValue ifAbsent: [^aValue]) typePrivate: nil.
	self notifyChangeAllOperationsChildSpecs.

	^aValue!

relatedWithAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRelatedWithAdd: aValue) ifFalse: [^aValue].
	(self relatedWithIncludes: aValue) ifTrue: [^aValue].
	(self relatedWithPrivateAdd: aValue) relatedTypePrivate: self.
	self changed: #relatedWith.
	^aValue!

relatedWithRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRelatedWithRemove: aValue) ifFalse: [^aValue].
	(self relatedWithPrivate remove: aValue ifAbsent: [^aValue]) relatedTypePrivate: nil.
	self changed: #relatedWith.
	^aValue!

relationshipsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRelationshipsAdd: aValue) ifFalse: [^aValue].
	(self relationshipsIncludes: aValue) ifTrue: [^self relationshipsMoveBottom: aValue].
	(self relationshipsPrivateAdd: aValue) typePrivate: self.

	self invalidateEffectiveRelationshipsCaches.

	self notifyChangeAllRelationshipsChildSpecs.
	^aValue!

relationshipsMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self relationshipsIncludes: aValue) ifFalse: [^aValue].
	(self relationships indexOf: aValue) = self relationshipsSize ifTrue: [^aValue].
	self relationshipsPrivate remove: aValue.
	aRes := self relationshipsPrivateAdd: aValue.

	self invalidateEffectiveRelationshipsCaches.

	self notifyChangeAllRelationshipsChildSpecs.
	^aRes!

relationshipsMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self relationshipsIncludes: aValue) ifFalse: [^aValue].
	(index := self relationships indexOf: aValue) = self relationshipsSize ifTrue: [^aValue].
	index = (self relationshipsSize -1)
		ifTrue:
			[self relationshipsPrivate remove: aValue.
			aRes := self relationshipsPrivateAdd: aValue.
			self notifyChangeAllRelationshipsChildSpecs.
			^aRes].
	aRes := self relationshipsPrivateMove: aValue beforeIndex: index + 2.

	self invalidateEffectiveRelationshipsCaches.

	self notifyChangeAllRelationshipsChildSpecs.
	^aRes!

relationshipsMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self relationshipsIncludes: aValue) ifFalse: [^aValue].
	(self relationships indexOf: aValue) = 1 ifTrue: [^aValue].
	self relationshipsPrivateMove: aValue beforeIndex: 1.

	self invalidateEffectiveRelationshipsCaches.

	self notifyChangeAllRelationshipsChildSpecs.!

relationshipsMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self relationshipsIncludes: aValue) ifFalse: [^aValue].
	(index := self relationships indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self relationshipsPrivateMove: aValue beforeIndex: index - 1.

	self invalidateEffectiveRelationshipsCaches.

	self notifyChangeAllRelationshipsChildSpecs.
	^aRes!

relationshipsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkRelationshipsRemove: aValue) ifFalse: [^aValue].
	(self relationshipsPrivate remove: aValue ifAbsent: [^aValue]) typePrivate: nil.

	self invalidateEffectiveRelationshipsCaches.

	self notifyChangeAllRelationshipsChildSpecs.
	^aValue!

subTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSubTypesAdd: aValue) ifFalse: [^aValue].
	(self subTypesIncludes: aValue) ifTrue: [^aValue].
	(self subTypesPrivateAdd: aValue) superTypesPrivateAdd: self.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ 
		aValue invalidateMemberInstanceTypesCache.
		aValue invalidateEffectiveFeaturesCaches
	].
	self changed: #subTypes.
	^aValue!

subTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSubTypesRemove: aValue) ifFalse: [^aValue].
	(self subTypesPrivate remove: aValue ifAbsent: [^aValue]) superTypesPrivateRemove: self.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ 
		aValue invalidateMemberInstanceTypesCache.
		aValue invalidateEffectiveFeaturesCaches
	].
	self changed: #subTypes.
	^aValue!

superTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSuperTypesAdd: aValue) ifFalse: [^aValue].
	(self superTypesIncludes: aValue) ifTrue: [^aValue].
	(self superTypesPrivateAdd: aValue) subTypesPrivateAdd: self.

	self invalidateEffectiveFeaturesCaches.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ aValue invalidateMemberInstanceTypesCache].

	self isUse ifTrue: [ self updateUses].
	self updateRefinedFeatures.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].

	^aValue!

superTypesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	| aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(self superTypes indexOf: aValue) = self superTypesSize ifTrue: [^aValue].
	self superTypesPrivate remove: aValue.
	aRes := self superTypesPrivateAdd: aValue.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(index := self superTypes indexOf: aValue) = self superTypesSize ifTrue: [^aValue].
	index = (self superTypesSize -1)
		ifTrue:
			[self superTypesPrivate remove: aValue.
			aRes := self superTypesPrivateAdd: aValue.
			self notifyChangeAllRelationshipsChildSpecs.
			^aRes].
	aRes := self superTypesPrivateMove: aValue beforeIndex: index + 2.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(self superTypes indexOf: aValue) = 1 ifTrue: [^aValue].
	self superTypesPrivateMove: aValue beforeIndex: 1.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].!

superTypesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index aRes |
	(self superTypesIncludes: aValue) ifFalse: [^aValue].
	(index := self superTypes indexOf: aValue) = 1 ifTrue: [^aValue].
	aRes := self superTypesPrivateMove: aValue beforeIndex: index - 1.

	self invalidateEffectiveFeaturesCaches.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].
	^aRes!

superTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkSuperTypesRemove: aValue) ifFalse: [^aValue].
	(self superTypesPrivate remove: aValue ifAbsent: [^aValue]) subTypesPrivateRemove: self.

	self removeRefinementFeaturesFromMissingSuperTypes.

	self invalidateEffectiveFeaturesCaches.
	self invalidateMemberInstanceTypesCache.
	aValue isNil ifFalse: [ aValue invalidateMemberInstanceTypesCache].

	self isUse ifTrue: [ self updateUses].
	self updateRefinedFeatures.

	self changed: #superTypes.
	self notifyChangeAllRelationshipsChildSpecs.
	self notifyChangeAllAttributesChildSpecs.
	self subTypes do: [:aType | aType notifyChangeAllDerivedRelationshipsChildSpecs].

	^aValue!

typeOfArgumentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypeOfArgumentsAdd: aValue) ifFalse: [^aValue].
	(self typeOfArgumentsIncludes: aValue) ifTrue: [^aValue].
	(self typeOfArgumentsPrivateAdd: aValue) valueTypePrivate: self.
	self changed: #typeOfArguments.
	^aValue!

typeOfArgumentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypeOfArgumentsRemove: aValue) ifFalse: [^aValue].
	(self typeOfArgumentsPrivate remove: aValue ifAbsent: [^aValue]) argumentTypePrivate: nil.
	self changed: #typeOfArguments.
	^aValue!

typeOfReturnsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypeOfReturnsAdd: aValue) ifFalse: [^aValue].
	(self typeOfReturnsIncludes: aValue) ifTrue: [^aValue].
	(self typeOfReturnsPrivateAdd: aValue) valueTypePrivate: self.
	self changed: #typeOfReturns.
	^aValue!

typeOfReturnsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypeOfReturnsRemove: aValue) ifFalse: [^aValue].
	(self typeOfReturnsPrivate remove: aValue ifAbsent: [^aValue]) returnTypePrivate: nil.
	self changed: #typeOfReturns.
	^aValue!

typeOfValuesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypeOfValuesAdd: aValue) ifFalse: [^aValue].
	(self typeOfValuesIncludes: aValue) ifTrue: [^aValue].
	(self typeOfValuesPrivateAdd: aValue) argumentTypePrivate: self.
	self changed: #typeOfValues.
	^aValue!

typeOfValuesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypeOfValuesRemove: aValue) ifFalse: [^aValue].
	(self typeOfValuesPrivate remove: aValue ifAbsent: [^aValue]) valueTypePrivate: nil.
	self changed: #typeOfValues.
	^aValue!

typesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesAdd: aValue) ifFalse: [^aValue].
	(self typesIncludes: aValue) ifTrue: [^self typesMoveBottom: aValue].
	(self typesPrivateAdd: aValue) modulePrivate: self.
	self changed: #types.
	^aValue!

typesMoveBottom: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	self typesPrivate remove: aValue.
	^self typesPrivateAdd: aValue!

typesMoveDown: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = self typesSize ifTrue: [^aValue].
	index = (self typesSize -1)
		ifTrue:
			[self typesPrivate remove: aValue.
			^self typesPrivateAdd: aValue].
	^self typesPrivateMove: aValue beforeIndex: index + 2!

typesMoveTop: aValue
	"Generated by ISF/AD. Do not modify"
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(self types indexOf: aValue) = 1 ifTrue: [^aValue].
	self typesPrivateMove: aValue beforeIndex: 1!

typesMoveUp: aValue
	"Generated by ISF/AD. Do not modify"
	| index |
	(self typesIncludes: aValue) ifFalse: [^aValue].
	(index := self types indexOf: aValue) = 1 ifTrue: [^aValue].
	^self typesPrivateMove: aValue beforeIndex: index - 1!

typesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	(self checkTypesRemove: aValue) ifFalse: [^aValue].
	(self typesPrivate remove: aValue ifAbsent: [^aValue]) modulePrivate: nil.
	self changed: #types.
	^aValue! !

!CODEType publicMethodsFor: 'associations private'!

attributesPrivate
	"Generated by ISF/AD. Do not modify"
	attributes isNil
		ifTrue: [self initAttributes].
	^attributes!

attributesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self attributesPrivate add: aValue.
	self changed: #attributes.
	^aValue!

attributesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self attributes at: anIndex.
	self attributesPrivate remove: aValue.
	self attributesPrivate add: aValue before: obj.
	self changed: #attributes.
	^aValue!

attributesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self attributesPrivate remove: aValue.
	self changed: #attributes.
	^aValue!

modulePrivate: aValue
	| aPrevValue |
	aPrevValue := module.
	module := aValue.
	self changed: #module.
	(module isNil and: [aPrevValue isNil not]) ifTrue: [ self release].!

operationsPrivate
	"Generated by ISF/AD. Do not modify"
	operations isNil
		ifTrue: [self initOperations].
	^operations!

operationsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self operationsPrivate add: aValue.
	self changed: #operations.
	^aValue!

operationsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self operations at: anIndex.
	self operationsPrivate remove: aValue.
	self operationsPrivate add: aValue before: obj.
	self changed: #operations.
	^aValue!

operationsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self operationsPrivate remove: aValue.
	self changed: #operations.
	^aValue!

relatedWithPrivate
	"Generated by ISF/AD. Do not modify"
	relatedWith isNil
		ifTrue: [self initRelatedWith].
	^relatedWith!

relatedWithPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self relatedWithPrivate add: aValue.
	self changed: #relatedWith.
	^aValue!

relatedWithPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self relatedWithPrivate remove: aValue.
	self changed: #relatedWith.
	^aValue!

relationshipsPrivate
	"Generated by ISF/AD. Do not modify"
	relationships isNil
		ifTrue: [self initRelationships].
	^relationships!

relationshipsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self relationshipsPrivate add: aValue.
	self changed: #relationships.
	^aValue!

relationshipsPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self relationships at: anIndex.
	self relationshipsPrivate remove: aValue.
	self relationshipsPrivate add: aValue before: obj.
	self changed: #relationships.
	^aValue!

relationshipsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self relationshipsPrivate remove: aValue.
	self changed: #relationships.
	^aValue!

subTypesPrivate
	"Generated by ISF/AD. Do not modify"
	subTypes isNil
		ifTrue: [self initSubTypes].
	^subTypes!

subTypesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self subTypesPrivate add: aValue.
	self changed: #subTypes.
	^aValue!

subTypesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self subTypesPrivate remove: aValue.
	self changed: #subTypes.
	^aValue!

superTypesPrivate
	"Generated by ISF/AD. Do not modify"
	superTypes isNil
		ifTrue: [self initSuperTypes].
	^superTypes!

superTypesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self superTypesPrivate add: aValue.
	self changed: #superTypes.
	^aValue!

superTypesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self superTypes at: anIndex.
	self superTypesPrivate remove: aValue.
	self superTypesPrivate add: aValue before: obj.
	self changed: #superTypes.
	^aValue!

superTypesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self superTypesPrivate remove: aValue.
	self changed: #superTypes.
	^aValue!

typeOfArgumentsPrivate
	"Generated by ISF/AD. Do not modify"
	typeOfArguments isNil
		ifTrue: [self initTypeOfArguments].
	^typeOfArguments!

typeOfArgumentsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self typeOfArgumentsPrivate add: aValue.
	self changed: #typeOfArguments.
	^aValue!

typeOfArgumentsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self typeOfArgumentsPrivate remove: aValue.
	self changed: #typeOfArguments.
	^aValue!

typeOfReturnsPrivate
	"Generated by ISF/AD. Do not modify"
	typeOfReturns isNil
		ifTrue: [self initTypeOfReturns].
	^typeOfReturns!

typeOfReturnsPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self typeOfReturnsPrivate add: aValue.
	self changed: #typeOfReturns.
	^aValue!

typeOfReturnsPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self typeOfReturnsPrivate remove: aValue.
	self changed: #typeOfReturns.
	^aValue!

typeOfValuesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^typeOfValues isNil
		ifTrue: [false]
		ifFalse: [self typeOfValues includes: aValue]!

typeOfValuesPrivate
	"Generated by ISF/AD. Do not modify"
	typeOfValues isNil
		ifTrue: [self initTypeOfValues].
	^typeOfValues!

typeOfValuesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self typeOfValuesPrivate add: aValue.
	self changed: #typeOfValues.
	^aValue!

typeOfValuesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self typeOfValuesPrivate remove: aValue.
	self changed: #typeOfValues.
	^aValue!

typeOfValuesSize
	"Generated by ISF/AD. Do not modify"
	^typeOfValues isNil
		ifTrue: [0]
		 ifFalse: [typeOfValues size]!

typesPrivate
	"Generated by ISF/AD. Do not modify"
	types isNil
		ifTrue: [self initTypes].
	^types!

typesPrivateAdd: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate add: aValue.
	self markDirty.

	self changed: #types.
	^aValue!

typesPrivateMove: aValue beforeIndex: anIndex
	"Generated by ISF/AD. Do not modify"
	| obj |
	obj := self types at: anIndex.
	self typesPrivate remove: aValue.
	self typesPrivate add: aValue before: obj.
	self markDirty.

	self changed: #types.
	^aValue!

typesPrivateRemove: aValue
	"Generated by ISF/AD. Do not modify"
	self typesPrivate remove: aValue.
	self markDirty.

	self changed: #types.
	^aValue! !

!CODEType publicMethodsFor: 'associations testing'!

attributesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^attributes isNil
		ifTrue: [false]
		ifFalse: [self attributes includes: aValue]!

attributesSize
	"Generated by ISF/AD. Do not modify"
	^attributes isNil
		ifTrue: [0]
		 ifFalse: [attributes size]!

operationsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^operations isNil
		ifTrue: [false]
		ifFalse: [self operations includes: aValue]!

operationsSize
	"Generated by ISF/AD. Do not modify"
	^operations isNil
		ifTrue: [0]
		 ifFalse: [operations size]!

relatedWithIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^relatedWith isNil
		ifTrue: [false]
		ifFalse: [self relatedWith includes: aValue]!

relatedWithSize
	"Generated by ISF/AD. Do not modify"
	^relatedWith isNil
		ifTrue: [0]
		 ifFalse: [relatedWith size]!

relationshipsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^relationships isNil
		ifTrue: [false]
		ifFalse: [self relationships includes: aValue]!

relationshipsSize
	"Generated by ISF/AD. Do not modify"
	^relationships isNil
		ifTrue: [0]
		 ifFalse: [relationships size]!

subTypesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^subTypes isNil
		ifTrue: [false]
		ifFalse: [self subTypes includes: aValue]!

subTypesSize
	"Generated by ISF/AD. Do not modify"
	^subTypes isNil
		ifTrue: [0]
		 ifFalse: [subTypes size]!

superTypesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^superTypes isNil
		ifTrue: [false]
		ifFalse: [self superTypes includes: aValue]!

superTypesSize
	"Generated by ISF/AD. Do not modify"
	^superTypes isNil
		ifTrue: [0]
		 ifFalse: [superTypes size]!

typeOfArgumentsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^typeOfArguments isNil
		ifTrue: [false]
		ifFalse: [self typeOfArguments includes: aValue]!

typeOfArgumentsSize
	"Generated by ISF/AD. Do not modify"
	^typeOfArguments isNil
		ifTrue: [0]
		 ifFalse: [typeOfArguments size]!

typeOfReturnsIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^typeOfReturns isNil
		ifTrue: [false]
		ifFalse: [self typeOfReturns includes: aValue]!

typeOfReturnsSize
	"Generated by ISF/AD. Do not modify"
	^typeOfReturns isNil
		ifTrue: [0]
		 ifFalse: [typeOfReturns size]!

typesIncludes: aValue
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [false]
		ifFalse: [self types includes: aValue]!

typesSize
	"Generated by ISF/AD. Do not modify"
	^types isNil
		ifTrue: [0]
		 ifFalse: [types size]! !

!CODEType publicMethodsFor: 'changing'!

notifyChangeAllAttributesChildSpecs

	self changed: #allEffectiveFeatures.
	self subTypesPrivate do: [:aType | aType changed: #allEffectiveFeatures; changed: #allAttributes].
	self changed: #attributes.
	self changed: #allAttributes.!

notifyChangeAllDerivedRelationshipsChildSpecs

	self changed: #allEffectiveFeatures.
	self subTypesPrivate do: [:aType | aType changed: #allEffectiveFeatures; changed: #allAttributes].
	self changed: #allAggregatedRelatedTypes.
	self changed: #allAggregatedRelationships.
	self changed: #allAggregationRelatedTypes.
	self changed: #allAggregationRelationships.
	self changed: #allAttributes.
	self changed: #allRelationships.
	self changed: #allRelatedTypes.
	self changed: #allPolymorphicallyRelatedTypes.
	self changed: #allNonAbstractPolymorphicallyRelatedTypes.
	self changed: #allNonAbstractPolymorphicallyAggregationRelatedTypes.
	self changed: #allNonAbstractPolymorphicallyAggregatedIntoRelatedTypes.!

notifyChangeAllOperationsChildSpecs

	self changed: #operations.
	self changed: #allOperations.!

notifyChangeAllRelationshipsChildSpecs

	self changed: #relationships.
	self notifyChangeAllDerivedRelationshipsChildSpecs!

notifyFullyQualifiedNameChanged
	
	self changed: #allContainerNamespaceNames.

	self types do: [:aType | aType notifyFullyQualifiedNameChanged]! !

!CODEType publicMethodsFor: 'derivation expressions'!

cloneEnumerationObject: theObject

	| aNewObject anEnumValue someEnumAttributes anOwnEnumValue aNonVirtualType |

	theObject isNil ifTrue: [ ^nil].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue:  [ ^nil].

	aNonVirtualType isEnumeration ifFalse: [ ^nil].

	anEnumValue := theObject  enumValue.
	anEnumValue isNil ifTrue: [ ^nil].
	anEnumValue isAttribute ifFalse: [ ^nil].
	anEnumValue isEnumerationValue ifFalse: [ ^nil].

	someEnumAttributes := self allEnumerationAttributes.
	(someEnumAttributes isNil or: [ someEnumAttributes isEmpty]) ifTrue: [ ^nil].
	
	anOwnEnumValue := someEnumAttributes detect: [:anEnumAttr | anEnumAttr name = anEnumValue name]
		ifNone: [ nil].
	anOwnEnumValue isNil ifTrue: [ ^nil].
	

	aNewObject := nil.

	^(CMTransaction  newTransactionDo: [  
		aNewObject := self preferredCMGenericObjectClass newWithMetaInfo: self enumValue: anOwnEnumValue.
	]) 
		ifTrue: [aNewObject]
		ifFalse: [ nil].!

cloneObject: theObject
	| aNewObject someEffectiveFeatures aNonVirtualType |
	theObject isNil ifTrue: [ ^nil].

	(self isTypeOfObjectInstance: theObject) ifFalse: [ ^nil].
	
	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^nil].
	
	aNonVirtualType isPrimitive ifTrue: [ ^self clonePrimitiveObject: theObject].
	aNonVirtualType isEnumeration ifTrue: [ ^self cloneEnumerationObject: theObject].

	aNewObject := self createObject.

	someEffectiveFeatures := self allEffectiveStructuralFeatures.
	(someEffectiveFeatures isNil or: [ someEffectiveFeatures isEmpty]) ifTrue: [ ^aNewObject].

	someEffectiveFeatures do: [:aFeature |
		(aFeature isAttribute or: [ aFeature isAggregation]) ifTrue: [ 
			aFeature cloneObject: theObject into: aNewObject
		]
	].
	^aNewObject!

clonePrimitiveObject: theObject

	| aNonVirtualType aClone |

	(theObject isKindOf: CMGenericObject) ifTrue: [ ^nil].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^nil].

	(self isPrimitive or: [ aNonVirtualType isPrimitive]) ifFalse: [  ^nil].
	
	aClone := self primitiveBroker clone: theObject.
	^aClone! !

!CODEType publicMethodsFor: 'derivations cache'!

initEffectiveFeaturesCaches
	| someFeatures someAttributes someRelationships someOperations |

	effectiveAttributesCache := nil.
	effectiveRelationshipsCache := nil.
	effectiveStructuralFeaturesCache := nil.
	effectiveOperationsCache := nil.
	effectiveFeaturesCache := nil.
	effectiveIDAttributeCache := nil.
	effectiveNameAttributeCache := nil.

	someFeatures := self allEffectiveFeaturesNoCache.
	someFeatures isNil ifTrue: [ ^self].

	someAttributes := OrderedCollection new: someFeatures size.
	someRelationships := OrderedCollection new: someFeatures size.
	someOperations := OrderedCollection new: someFeatures size.

	someFeatures do: [:aFeature |
		aFeature isAttribute ifTrue: [ 
			someAttributes add: aFeature.
			effectiveIDAttributeCache isNil ifTrue: [ aFeature isIDAttribute ifTrue: [ effectiveIDAttributeCache := aFeature]].
			effectiveNameAttributeCache isNil ifTrue: [ aFeature isNameAttribute ifTrue: [ effectiveNameAttributeCache := aFeature]].
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [ someRelationships add: aFeature] ifFalse: [ 
		aFeature isOperation ifTrue: [ someOperations add: aFeature] ifFalse: [ 
		
		]]]
	].

	effectiveFeaturesCache := someFeatures.
	effectiveAttributesCache := someAttributes asArray.
	effectiveRelationshipsCache := someRelationships asArray.
	effectiveStructuralFeaturesCache := effectiveAttributesCache , effectiveRelationshipsCache.
	effectiveOperationsCache := someOperations asArray.
	effectiveFeaturesCache := effectiveStructuralFeaturesCache , effectiveOperationsCache.

	effectiveIDAttributeCache isNil ifTrue: [ effectiveIDAttributeCache := self class alreadyDerivedAttribute].
	effectiveNameAttributeCache isNil ifTrue: [ effectiveNameAttributeCache := self class alreadyDerivedAttribute].!

invalidateEffectiveAttributesCaches

	self invalidateEffectiveFeaturesCaches!

invalidateEffectiveFeaturesCaches
	| someSubTypes |

	effectiveAttributesCache := nil.
	effectiveRelationshipsCache := nil.
	effectiveStructuralFeaturesCache := nil.
	effectiveOperationsCache := nil.
	effectiveFeaturesCache := nil.
	effectiveIDAttributeCache  := nil.
	effectiveNameAttributeCache := nil.

	someSubTypes := self subTypes.
	someSubTypes isNil ifTrue: [ ^self].

	someSubTypes do: [:aSubType | aSubType  invalidateEffectiveFeaturesCaches]!

invalidateEffectiveOperationsCaches

	self invalidateEffectiveFeaturesCaches!

invalidateEffectiveRelationshipsCaches

	self invalidateEffectiveFeaturesCaches!

invalidateMemberInstanceTypesCache

	memberInstanceTypesCache := nil.

	self invalidateMemberInstanceTypesCacheUpwards.
	self invalidateMemberInstanceTypesCacheDownwards!

invalidateMemberInstanceTypesCacheDownwards

	| someSubTypes |

	memberInstanceTypesCache := nil.

	someSubTypes := self subTypes.
	someSubTypes isNil ifTrue: [ ^self].

	someSubTypes do: [:aSubType | aSubType invalidateMemberInstanceTypesCacheDownwards].!

invalidateMemberInstanceTypesCacheUpwards

	| someSuperTypes |

	memberInstanceTypesCache := nil.

	someSuperTypes := self superTypes.
	someSuperTypes isNil ifTrue: [ ^self].

	someSuperTypes do: [:aSuperType | aSuperType invalidateMemberInstanceTypesCacheUpwards].! !

!CODEType publicMethodsFor: 'derived accessing'!

allAttributes

	| someAttributes someSortedAttributes |
	
	someAttributes := IdentitySet new: 37.
	someAttributes addAll: self attributes.
	self superTypes do: [:aType | 
		aType allAttributesInto: someAttributes	
	].
		
	someSortedAttributes := someAttributes asSortedCollection: [:anAttr :otherAttr |
		anAttr name < otherAttr name].

	^someSortedAttributes!

allAttributesInto: theSet

	| aSuperType |
	theSet isNil ifTrue: [ ^nil].
	
	self attributes do: [:anAttribute | 
		(theSet includes: anAttribute) ifFalse: [  theSet add: anAttribute]
	].

	self superTypesSize < 1 ifTrue: [ ^theSet].

	aSuperType := self superTypes first.
	aSuperType allAttributesInto: theSet.
	
	self superTypesSize < 2 ifTrue: [ ^theSet].

	(self superTypes copyFrom: 2 to: self superTypesSize) do: [:aType | 
		aType allAttributesInto: theSet	
	].
		
	^theSet!

allContainerModuleNamesInto: theStream

	| aModule |
	theStream isNil ifTrue: [ ^self].

	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].!

allContainerNamespaceNames

	self module isNil ifTrue: [ ^'' copy].
	^self module allNamespaceNames!

allContainerPackageNames

	self module isNil ifTrue: [ ^'' copy].
	^self module allPackageNames!

allDefinedAspectsInto: theSet
	theSet isNil ifTrue: [ ^self].

	super allDefinedAspectsInto: theSet.
	self attributes do: [:anAttribute | anAttribute allDefinedAspectsInto: theSet].
	self relationships do: [:aRelationship | aRelationship allDefinedAspectsInto: theSet].!

allEnumerationAttributes

	| someAttributes someEnumerationAttributes |
	self isEnumeration ifFalse: [ ^nil].

	someAttributes := self allAttributes.
	someAttributes isNil ifTrue: [ ^nil].

	someEnumerationAttributes  := someAttributes select: [:anAttribute | 
		anAttribute isEnumerationValue
	].
		
	^someEnumerationAttributes!

allFeatures

	| someFeatures someSortedFeatures |

	someFeatures := IdentitySet new: 37.

	self allFeaturesInto: someFeatures.
		
	someSortedFeatures := someFeatures asSortedCollection: [:aFeature :otherFeature |
		aFeature name < otherFeature name].

	^someSortedFeatures!

allFeaturesInto: theSet

	theSet isNil ifTrue: [ ^nil].

	theSet addAll: self attributes.
	theSet addAll: self relationships.

	self superTypes do: [:aType | 
		aType allFeaturesInto: theSet	
	].
		
	^theSet!

 allLocalEffectiveFeatures

	| someAttributes someRelationships someFeatures |

	someAttributes := self attributes.
	someRelationships := self relationships.
	someFeatures := OrderedCollection new: someAttributes size + someRelationships size.
	someAttributes do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			someFeatures add: aFeature
		]
	].
	someRelationships do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			someFeatures add: aFeature
		]
	].
	^someFeatures!

allModuleNamesInto: theStream

	| aModule aSep |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].

	theStream nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

allModules

	| aModule someModules |
	aModule := self module.
	aModule isNil ifTrue: [ ^Array new].

	someModules := IdentitySet new: 13.
	aModule allModulesInto: someModules.
	^someModules!

allNamespaceNames
	| aPackages |
	self module isNil ifTrue: [ ^self name copy].
	aPackages := self module allNamespaceNames.
	^(aPackages isEmpty ifTrue: [''] ifFalse: [ aPackages , '::']) , self name!

allNonAbstractTypes
	| someTypes someNonAbstractTypes |
	someTypes := self allTypes.
	someNonAbstractTypes := someTypes reject: [:aType | aType isAbstract].
	^someNonAbstractTypes!

allNonRefinedAttributes

	| someAttributes someRefinedAttributes someSortedAttributes |

	someAttributes := IdentitySet new.
	someRefinedAttributes := IdentitySet new: 13.

	self allNonRefinedAttributesInto: someAttributes refined: someRefinedAttributes.

	someSortedAttributes := someAttributes asSortedCollection: [:aRel :otherRel |
		aRel name < otherRel name].

	^someSortedAttributes!

allNonRefinedAttributesInto: theAttributes refined: theRefinedAttributes

	self attributes do: [:aRel | 
		(theRefinedAttributes includes: aRel) ifFalse: [ 
			theAttributes add: aRel.
			aRel isRefinement  ifTrue: [ 
				aRel allRefinedAttributesInto: theRefinedAttributes]]].

	self superTypes do: [:aSuperType |
		aSuperType allNonRefinedAttributesInto: theAttributes refined: theRefinedAttributes].!

allNonRefinedRelationships

	| someRelationships someRefinedRelationships someSortedRelationships |

	someRelationships := IdentitySet new.
	someRefinedRelationships := IdentitySet new: 13.

	self allNonRefinedRelationshipsInto: someRelationships refined: someRefinedRelationships.

	someSortedRelationships := someRelationships asSortedCollection: [:aRel :otherRel |
		aRel name < otherRel name].

	^someSortedRelationships!

allNonRefinedRelationshipsInto: theRelationships refined: theRefinedRelationships

	self relationships do: [:aRel | 
		(theRefinedRelationships includes: aRel) ifFalse: [ 
			theRelationships add: aRel.
			aRel isRefinement  ifTrue: [ 
				aRel allRefinedRelationshipsInto: theRefinedRelationships]]].

	self superTypes do: [:aSuperType |
		aSuperType allNonRefinedRelationshipsInto: theRelationships refined: theRefinedRelationships].!

allOperations

	| someOperations someSortedOperations |
	
	someOperations := IdentitySet new: 37.
	someOperations addAll: self attributes.
	self superTypes do: [:anOperation | 
		anOperation allOperationsInto: someOperations	
	].
		
	someSortedOperations := someOperations asSortedCollection: [:anOp :otherOp |
		anOp name < otherOp name].

	^someSortedOperations!

allOperationsInto: theSet

	| aSuperType |
	theSet isNil ifTrue: [ ^nil].
	
	self operations do: [:anOperation | 
		(theSet includes: anOperation) ifFalse: [  theSet add: anOperation]
	].

	self superTypesSize < 1 ifTrue: [ ^theSet].

	aSuperType := self superTypes first.
	aSuperType allOperationsInto: theSet.
	
	self superTypesSize < 2 ifTrue: [ ^theSet].

	(self superTypes copyFrom: 2 to: self superTypesSize) do: [:aType | 
		aType allOperationsInto: theSet	
	].
		
	^theSet!

allPackageNames
	| aPackages |
	self module isNil ifTrue: [ ^self name copy].
	aPackages := self module allPackageNames.
	^(aPackages isEmpty ifTrue: [''] ifFalse: [ aPackages , '.']) , self name!

allRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	aSet addAll: someTypes.
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allRelationships

	| someRelationships someSortedRelationships |

	someRelationships := IdentitySet new: 37.
	someRelationships addAll: self relationships.
	self superTypes do: [:aType | 
		aType allRelationshipsInto: someRelationships	
	].
		
	someSortedRelationships := someRelationships asSortedCollection: [:aRel :otherRel |
		aRel name < otherRel name].

	^someSortedRelationships!

allRelationshipsInto: theSet

	| |
	theSet isNil ifTrue: [ ^nil].
	
	self relationships do: [:aRelationship |
		(theSet includes: aRelationship) ifFalse: [ theSet add: aRelationship]].

	self superTypes do: [:aType | 
		aType allRelationshipsInto: theSet	
	].
		
	^theSet!

allSubTypes
	^self allSubtypes!

allSubtypes
	| someSubTypes |
	someSubTypes := IdentitySet new: 13.
	self subTypesPrivate do: [:aSubType |	
		aSubType allSubTypesInto: someSubTypes
	].
	^someSubTypes!

allSubtypes: theSubTypes includes: theType

	theSubTypes isNil ifFalse: [ 
		(theSubTypes includes: self) 
			ifTrue: [ ^false]
			ifFalse: [  theSubTypes add: self]
	].

	(self subTypesIncludes: theType) ifTrue: [ ^true].

	^(self subTypes detect: [:aSubtype | aSubtype allSubtypes: theSubTypes includes: theType] ifNone: [ nil]) notNil!

allSubtypesIncludes: theType
	| someSubTypes |
	someSubTypes := IdentitySet new.
	^self allSubtypes: someSubTypes includes: theType!

allSubTypesInto: theSubTypes
	
	^self allSubtypesInto: theSubTypes!

allSubtypesInto: theSubTypes
	
	(theSubTypes includes: self) ifTrue: [ ^self].
	theSubTypes add: self.
	self subTypesPrivate do: [:aSubype |	
		aSubype allSubtypesInto: theSubTypes
	]!

allSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesInto: someSuperTypes
	].
	^someSuperTypes!

allSuperTypesInto: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesInto: theSuperTypes
	].!

allSuperTypesWithFeature: theFeature
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesWithFeature: theFeature into: someSuperTypes
	].
	^someSuperTypes!

allSuperTypesWithFeature: theFeature into: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].
	
	(self hasEffectiveFeature: theFeature) ifFalse: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allSuperTypesWithFeature: theFeature into: theSuperTypes
	].!

allTypes
	| someTypes |
	someTypes := IdentitySet new: 111.
	self allTypesInto: someTypes.
	^someTypes!

allTypesInto: theSet
	| someTypes |
	theSet isNil ifTrue: [ ^self].

	someTypes := self typesPrivate.
	theSet addAll: someTypes.
	someTypes do: [:aType | aType allTypesInto: theSet].!

allVirtualAndFirstNonVirtualSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allVirtualAndFirstNonVirtualSuperTypesInto: someSuperTypes
	].
	^someSuperTypes!

allVirtualAndFirstNonVirtualSuperTypesInto: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].

	theSuperTypes add: self.
	self isVirtual ifFalse: [ ^self].

	self superTypesPrivate do: [:aSuperType |	
		aSuperType allVirtualAndFirstNonVirtualSuperTypesInto: theSuperTypes
	].!

applicationConfiguration
	^self module isNil ifTrue: [ nil] ifFalse: [ self module applicationConfiguration]!

enumerationAttributes

	| someAttributes someEnumerationAttributes |
	self isEnumeration ifFalse: [ ^nil].

	someAttributes := self attributes.
	someAttributes isNil ifTrue: [ ^nil].

	someEnumerationAttributes  := someAttributes select: [:anAttribute | 
		anAttribute isEnumerationValue
	].
		
	^someEnumerationAttributes!

features
	^self attributesPrivate asArray , self relationshipsPrivate asArray!

fullyQualifiedName

	| aModuleFullyQualifiedName aFullyQualifiedName |
	self module isNil ifTrue: [ ^self name].
	
	aModuleFullyQualifiedName := self module fullyQualifiedName.
	(aModuleFullyQualifiedName isNil or: [ aModuleFullyQualifiedName isEmpty]) ifTrue: [ 
		^self name
	].

	aFullyQualifiedName := aModuleFullyQualifiedName, self class fullyQualifiedNameSeparator, self name.
	^aFullyQualifiedName!

fullyQualifiedNameArray

	| aModuleFullyQualifiedName aFullyQualifiedNameArray |
	self module isNil ifTrue: [ ^Array with: self name].
	
	aModuleFullyQualifiedName := self module fullyQualifiedNameArray.
	(aModuleFullyQualifiedName isNil or: [ aModuleFullyQualifiedName isEmpty]) ifTrue: [ 
		^Array with: self name
	].

	aFullyQualifiedNameArray := aModuleFullyQualifiedName, (Array with: self name).
	^aFullyQualifiedNameArray!

hasEffectiveFeature: theFeature

	| aResult |

	theFeature isNil  ifTrue: [ ^false].

	aResult := self allEffectiveFeatures includes: theFeature.
	^aResult!

hasEffectiveFeatureNamed: theName

	^(self effectiveFeatureNamed: theName) isNil not!

hasEffectiveStructuralFeature: theFeature

	| aResult |

	theFeature isNil  ifTrue: [ ^false].

	aResult := self allEffectiveStructuralFeatures includes: theFeature.
	^aResult!

hasIdCounter
	
	| someEffectiveAttributes aNonVirtualType |

	self isPrimitive ifTrue: [ ^false].
	self isEnumeration ifTrue: [ ^false].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^false].
	
	aNonVirtualType isPrimitive ifTrue: [ ^false].
	aNonVirtualType isEnumeration ifTrue: [ ^false].

	someEffectiveAttributes := self allEffectiveAttributes.
	(someEffectiveAttributes isNil or: [ someEffectiveAttributes isEmpty]) ifTrue: [ ^false].

	 ^(someEffectiveAttributes detect: [:anAttribute | anAttribute hasIdCounter] ifNone: [ nil]) isNil not!

hasSuperType: theSuperType

	theSuperType isNil ifTrue: [ ^false].

	^(self superTypesPrivate detect: [:aSuperType |
		aSuperType == theSuperType or: [
			aSuperType hasSuperType: theSuperType 
		]
	] ifNone: [ nil]) isNil not!

idAttribute

	| aIDAttribute |
	aIDAttribute := self allEffectiveAttributes detect: [:anAttribute | anAttribute isIDAttribute] ifNone: [ nil].
	^aIDAttribute!

isAggregated

	^(self allRelationships detect: [:aRelationship | aRelationship  isAggregated] ifNone: [ nil]) isNil not!

isVisibleInModules: 		theModules
	andAspects: 			theAspects
	definitionsHolder: 	theDefinitionsHolder

	((theModules isNil or: [ theModules isEmpty]) and: [  
		theAspects isNil or: [ theAspects isEmpty]]) ifTrue: [ 
		^true
	].

	^(  self isVisibleInModules: 	theModules definitionsHolder: 	theDefinitionsHolder) and: [ 
		self isVisibleInAspects: 	theAspects definitionsHolder: 	theDefinitionsHolder
	]!

isVisibleInModules: 		theModules
	definitionsHolder: 	theDefinitionsHolder


	| aThisModule |

	(theModules isNil or: [ theModules isEmpty]) ifTrue: [ ^true ].

	(theModules isNil not and: [ theModules isEmpty not]) ifTrue: [ 
		aThisModule := self module.
		aThisModule isNil ifTrue: [ ^false].
		(theModules includes: aThisModule) ifFalse: [ 
			(theModules detect: [:aModule | aModule includesModule: aModule] ifNone: [ nil]) isNil ifTrue: [ ^false]
		]
	].!

model
	^self module isNil ifTrue: [ nil] ifFalse: [ self module model]!

nameAttribute

	| aNameAttribute |
	aNameAttribute := self allEffectiveAttributes detect: [:anAttribute | anAttribute isNameAttribute] ifNone: [ nil].
	^aNameAttribute!

nameRelationship

	| aNameRelationship |
	aNameRelationship := self allEffectiveRelationships detect: [:anRelationship | anRelationship isNameRelationship] ifNone: [ nil].
	^aNameRelationship!

nonVirtualType
	| someSuperTypes aNonVirtualSuperType |


	self isVirtual ifFalse: [ self isAbstract ifFalse: [ ^self]].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ self isAbstract ifFalse: [ ^self]].

	aNonVirtualSuperType := nil.
	someSuperTypes detect: [:aSuperType |
		aNonVirtualSuperType := aSuperType nonVirtualTypeNoDefault.
		aNonVirtualSuperType isNil not
	] ifNone: [ nil].

	aNonVirtualSuperType isNil ifFalse: [ ^aNonVirtualSuperType].

	^self!

nonVirtualTypeNoDefault
	| someSuperTypes aNonVirtualSuperType |


	self isVirtual ifFalse: [ self isAbstract ifFalse: [ ^self]].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ self isAbstract ifFalse: [ ^self]].

	aNonVirtualSuperType := nil.
	someSuperTypes detect: [:aSuperType |
		aNonVirtualSuperType := aSuperType nonVirtualTypeNoDefault.
		aNonVirtualSuperType isNil not
	] ifNone: [ nil].

	^aNonVirtualSuperType!

ownEffectiveAttributes

	| someAttributes someEffectiveAttributes |
	
	someAttributes := self attributes.
	(someAttributes isNil or: [ someAttributes isEmpty]) ifTrue: [ ^Array new].

	someEffectiveAttributes := OrderedCollection new: someAttributes size.

	someAttributes do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			someEffectiveAttributes add: aFeature.
		]
	].

	^someEffectiveAttributes!

ownEffectiveOperations

	| someOperations someEffectiveOperations |
	
	someOperations := self attributes.
	(someOperations isNil or: [ someOperations isEmpty]) ifTrue: [ ^Array new].

	someEffectiveOperations := OrderedCollection new: someOperations size.

	someOperations do: [:aFeature | 
		aFeature isExclussion not ifTrue: [ 
			someEffectiveOperations add: aFeature.
		]
	].

	^someEffectiveOperations!

requiresIdCounter
	
	| someEffectiveAttributes aNonVirtualType aResult someSubTypes |

	self isPrimitive ifTrue: [ ^false].
	self isEnumeration ifTrue: [ ^false].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^false].
	
	aNonVirtualType isPrimitive ifTrue: [ ^false].
	aNonVirtualType isEnumeration ifTrue: [ ^false].

	someEffectiveAttributes := self allEffectiveAttributes.
	(someEffectiveAttributes isNil or: [ someEffectiveAttributes isEmpty]) ifTrue: [ ^false].

	aResult := (someEffectiveAttributes detect: [:anAttribute | anAttribute requiresIdCounter] ifNone: [ nil]) isNil not.
	aResult ifTrue: [ ^true].

	someSubTypes := self subTypes.
	(someSubTypes isNil or: [ someSubTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSubTypes detect: [:aSubType | aSubType requiresIdCounterForOwnAttributes] ifNone: [ nil]) isNil not.
	^aResult!

requiresIdCounterForOwnAttributes
	
	| someEffectiveAttributes aNonVirtualType aResult someSubTypes |

	self isPrimitive ifTrue: [ ^false].
	self isEnumeration ifTrue: [ ^false].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^false].
	
	aNonVirtualType isPrimitive ifTrue: [ ^false].
	aNonVirtualType isEnumeration ifTrue: [ ^false].

	someEffectiveAttributes := self ownEffectiveAttributes.
	(someEffectiveAttributes isNil or: [ someEffectiveAttributes isEmpty]) ifTrue: [ ^false].

	aResult := (someEffectiveAttributes detect: [:anAttribute | anAttribute requiresIdCounter] ifNone: [ nil]) isNil not.
	aResult ifTrue: [ ^true].

	someSubTypes := self subTypes.
	(someSubTypes isNil or: [ someSubTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSubTypes detect: [:aSubType | aSubType requiresIdCounterForOwnAttributes] ifNone: [ nil]) isNil not.
	^aResult!

rootTypes
	| someTypes |
	someTypes := IdentitySet new: 37.
	self rootTypesInto: someTypes.
	^someTypes!

rootTypesInto: theSet
	| someTypes |
	theSet isNil ifTrue: [ ^self].

	someTypes := self types.
	someTypes do: [:aType | aType isRootType ifTrue: [ theSet add: aType]].
	someTypes do: [:aType | aType rootTypesInto: theSet].!

superType
	self superTypesSize < 1 ifTrue: [ ^nil].
	^self superTypes first!

typePrefix
	^self model isNil ifTrue: [ nil] ifFalse: [ self model typePrefix]!

withAllNonAbstractSubtypes
	^self withAllSubtypes reject: [:aT | aT isAbstract]!

withAllNonAbstractSubtypes: theSubTypes
	theSubTypes isNil ifTrue: [ ^theSubTypes].
	self isAbstract ifFalse: [ 
		(theSubTypes includes: self) ifFalse: [ 
			theSubTypes add: self]].

	self subTypes do: [:aSubtype | aSubtype withAllNonAbstractSubtypes: theSubTypes].
	^theSubTypes!

withAllNonAbstractSuperTypes
	^self withAllSuperTypes reject: [:aT | aT isAbstract]!

withAllSubtypes
	| someSubTypes |
	someSubTypes := OrderedCollection new.
	self withAllSubtypes: someSubTypes.
	^someSubTypes!

withAllSubtypes: theSubTypes
	theSubTypes isNil ifTrue: [ ^theSubTypes].
	(theSubTypes includes: self) ifTrue: [ ^theSubTypes].
	theSubTypes add: self.
	self subTypesPrivate do: [:aSubtype | aSubtype withAllSubtypes: theSubTypes].
	^theSubTypes!

withAllSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new.
	self withAllSuperTypes: someSuperTypes.
	^someSuperTypes!

withAllSuperTypes: theSuperTypes
	theSuperTypes isNil ifTrue: [ ^theSuperTypes].
	(theSuperTypes includes: self) ifTrue: [ ^theSuperTypes].
	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType | aSuperType withAllSuperTypes: theSuperTypes].
	^theSuperTypes! !

!CODEType publicMethodsFor: 'derived col accessing'!

allAbstractSuperTypes
	| someSuperTypes |
	someSuperTypes := IdentitySet new: 13.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allAbstractSuperTypesInto: someSuperTypes
	].
	^someSuperTypes!

allAbstractSuperTypesInto: theSuperTypes
	
	(theSuperTypes includes: self) ifTrue: [ ^self].

	self isAbstract ifFalse: [ ^self].

	theSuperTypes add: self.
	self superTypesPrivate do: [:aSuperType |	
		aSuperType allAbstractSuperTypesInto: theSuperTypes
	].!

allAggregatedIntoRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allAggregatedIntoRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	aSet addAll: someTypes.
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allAggregatedIntoRelationships

	| someRelationships someAggregatedRelationships |
	
	someRelationships := self allRelationships.
	someAggregatedRelationships := someRelationships select: [:aRel | aRel isAggregated].

	^someAggregatedRelationships!

allAggregatedRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allAggregatedRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	aSet addAll: someTypes.
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allAggregatedRelationships

	| someRelationships someAggregatedRelationships |
	
	someRelationships := self allRelationships.
	someAggregatedRelationships := someRelationships select: [:aRel | aRel isAggregation].

	^someAggregatedRelationships!

allAggregationRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allAggregationRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	aSet addAll: someTypes.
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allAggregationRelationships

	| someRelationships someAggregatedRelationships |
	
	someRelationships := self allRelationships.
	someAggregatedRelationships := someRelationships select: [:aRel | aRel isAggregation].

	^someAggregatedRelationships!

allEffectiveAggregatedIntoRelationships

	| someRelationships someRelationshipsNotToInclude someRelationshipNamessNotToInclude |

	someRelationships := OrderedCollection new.
	someRelationshipsNotToInclude := IdentitySet new: 13.
	someRelationshipNamessNotToInclude := IdentitySet new: 13.

	self allEffectiveAggregatedIntoRelationshipsInto: someRelationships notInclude: someRelationshipsNotToInclude notIncludeNamed: someRelationshipNamessNotToInclude.

	^someRelationships asArray!

 allEffectiveAggregatedIntoRelationshipsInto: theRelationships notInclude: theRelationshipsNotToInclude notIncludeNamed: theRelationshipNamesNotToInclude

	| someRelationshipsNotToInclude someRelationshipNamesNotToInclude |
	
	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someRelationshipsNotToInclude := theRelationshipsNotToInclude copy.
		someRelationshipNamesNotToInclude := theRelationshipNamesNotToInclude copy.
		self relationships do: [:aFeature | 
			aFeature isRefinement  ifTrue: [ 
				aFeature allRefinedRelationshipsInto: someRelationshipsNotToInclude
			].
			someRelationshipNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveAggregatedIntoRelationshipsInto: theRelationships notInclude: someRelationshipsNotToInclude 
				notIncludeNamed: someRelationshipNamesNotToInclude
		].
	].


	self relationships do: [:aFeature | 
		aFeature isAggregated ifTrue: [ 
			((theRelationshipsNotToInclude includes: aFeature) or: [ 
				theRelationshipNamesNotToInclude includes: aFeature name]) ifFalse: [ 
				(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
					theRelationships add: aFeature.
				]
			]
		]
	].!

allEffectiveAggregationRelationships

	| someRelationships someRelationshipsNotToInclude someRelationshipNamessNotToInclude |

	someRelationships := OrderedCollection new.
	someRelationshipsNotToInclude := IdentitySet new: 13.
	someRelationshipNamessNotToInclude := IdentitySet new: 13.

	self allEffectiveAggregationRelationshipsInto: someRelationships notInclude: someRelationshipsNotToInclude notIncludeNamed: someRelationshipNamessNotToInclude.

	^someRelationships asArray!

 allEffectiveAggregationRelationshipsInto: theRelationships notInclude: theRelationshipsNotToInclude notIncludeNamed: theRelationshipNamesNotToInclude

	| someRelationshipsNotToInclude someRelationshipNamesNotToInclude |
	
	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someRelationshipsNotToInclude := theRelationshipsNotToInclude copy.
		someRelationshipNamesNotToInclude := theRelationshipNamesNotToInclude copy.
		self relationships do: [:aFeature | 
			aFeature isRefinement  ifTrue: [ 
				aFeature allRefinedRelationshipsInto: someRelationshipsNotToInclude
			].
			someRelationshipNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveAggregationRelationshipsInto: theRelationships notInclude: someRelationshipsNotToInclude 
				notIncludeNamed: someRelationshipNamesNotToInclude
		].
	].


	self relationships do: [:aFeature | 
		aFeature isAggregation ifTrue: [ 
			((theRelationshipsNotToInclude includes: aFeature) or: [ 
				theRelationshipNamesNotToInclude includes: aFeature name]) ifFalse: [ 
				(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
					theRelationships add: aFeature.
				]
			]
		]
	].!

allNonAbstractPolymorphicallyAggregatedIntoRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allAggregatedIntoRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	someTypes do: [:aType | aSet addAll: (aType withAllSubtypes reject: [:aTy | aTy isAbstract])].
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allNonAbstractPolymorphicallyAggregatedRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allAggregatedRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	someTypes do: [:aType | aSet addAll: (aType withAllSubtypes reject: [:aTy | aTy isAbstract])].
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allNonAbstractPolymorphicallyAggregationRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allAggregationRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	someTypes do: [:aType | aSet addAll: (aType withAllSubtypes reject: [:aTy | aTy isAbstract])].
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allNonAbstractPolymorphicallyRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	someTypes do: [:aType | aSet addAll: (aType withAllSubtypes reject: [:aTy | aTy isAbstract])].
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allNonDummyRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |
	
	someRelationships := self allNonDummyRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	aSet addAll: someTypes.
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allNonDummyRelationships

	| someRelationships someNonDummyRelationships |
	
	someRelationships := self allRelationships.
	someNonDummyRelationships := someRelationships select: [:aRel | (aRel dummy == true) not].

	^someNonDummyRelationships!

allPolimorphicallyAggregatedIntoRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |

	someRelationships := self allAggregatedIntoRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	someTypes do: [:aType | aSet addAll: aType withAllSubtypes].
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allPolymorphicallyAggregatedRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |

	someRelationships := self allAggregatedRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	someTypes do: [:aType | aSet addAll: aType withAllSubtypes].
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allPolymorphicallyAggregationRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |

	someRelationships := self allAggregationRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	someTypes do: [:aType | aSet addAll: aType withAllSubtypes].
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes!

allPolymorphicallyRelatedTypes

	| someRelationships someTypes aSet someSortedTypes |

	someRelationships := self allRelationships.
	someTypes := someRelationships collect: [ :aRel | aRel relatedType].
	
	aSet := Set new: someRelationships size * 2 + 1.
	someTypes do: [:aType | aSet addAll: aType withAllSubtypes].
		
	someSortedTypes := aSet asSortedCollection: [:aType :otherType |
		aType name < otherType name].

	^someSortedTypes! !

!CODEType publicMethodsFor: 'derived effective features'!

allEffectiveAttributes

	^self allEffectiveAttributesFromCache!

allEffectiveAttributesFromCache

	effectiveAttributesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	^effectiveAttributesCache!

allEffectiveFeatures

	^self allEffectiveFeaturesFromCache!

allEffectiveFeaturesFromCache

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	^effectiveFeaturesCache!

allEffectiveFeaturesNoCache

	| someFeatures someFeaturesNotToInclude someFeatureNamesNotToInclude |
"Transcript show: 'EF ' , self name; cr."

	someFeatures := OrderedCollection new: 32.

	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someFeaturesNotToInclude := IdentitySet new: 13.
		someFeatureNamesNotToInclude := Set new: 13.
		self attributes do: [:aFeature | 
			aFeature allRefinedAttributesInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self relationships do: [:aFeature | 
			aFeature allRefinedRelationshipsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self operations do: [:aFeature | 
			aFeature allRefinedOperationsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveFeatures do: [:aFeature |
				((someFeaturesNotToInclude includes: aFeature) or: [ 
					someFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
					(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
				]
			]
		].
	].

	self attributes do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	self relationships do: [:aFeature | 
		(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	self operations do: [:aFeature | 
		aFeature isExclussion not ifTrue: [ 
			(someFeatures includes: aFeature) ifFalse: [ someFeatures add: aFeature]
		]
	].

	^someFeatures!

allEffectiveOperations

	^self allEffectiveOperationsFromCache!

allEffectiveOperationsFromCache

	effectiveOperationsCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	^effectiveOperationsCache!

allEffectiveRelationships

	^self allEffectiveRelationshipsFromCache!

allEffectiveRelationshipsFromCache

	effectiveRelationshipsCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	^effectiveRelationshipsCache!

allEffectiveStructuralFeatures

	^self allEffectiveStructuralFeaturesFromCache!

allEffectiveStructuralFeaturesFromCache

	effectiveStructuralFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	^effectiveStructuralFeaturesCache!

effectiveAttributeNamed: theName

	^self effectiveAttributeNamedFromCache: theName!

effectiveAttributeNamedFromCache: theName

	| aFoundAttribute |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveAttributesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveAttributesCache isNil ifTrue: [ ^nil].

	aFoundAttribute := nil.
	effectiveAttributesCache detect: [:aAttribute | 
		aAttribute isExclussion ifFalse: [ 
			aAttribute isAttribute ifTrue: [ 
				(aAttribute maxMult = aAttribute class  maxMultNone) ifFalse: [ 
					aAttribute name = theName ifTrue: [ aFoundAttribute := aAttribute].
				]
			]
		].
		aFoundAttribute isNil not
	] ifNone: [ nil].

	^aFoundAttribute!

effectiveFeatureNamed: theName

	^self effectiveFeatureNamedFromCache: theName!

effectiveFeatureNamedFromCache: theName

	| aFoundFeature |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveFeaturesCache isNil ifTrue: [ ^nil].

	aFoundFeature := nil.
	effectiveFeaturesCache detect: [:aFeature | 
		aFeature isExclussion ifFalse: [ 
			(aFeature isAttribute or: [ aFeature isRelationship]) 
				ifTrue: [ 
					(aFeature maxMult = aFeature class  maxMultNone) ifFalse: [ 
						aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
					]
				]
				ifFalse: [ 
					aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
				]								
		].
		aFoundFeature isNil not
	] ifNone: [ nil].

	^aFoundFeature!

effectiveFeatureTypedNamed: theName

	^self effectiveFeatureTypedNamedFromCache: theName!

effectiveFeatureTypedNamedFromCache: theName

	| aFoundFeature |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveFeaturesCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveFeaturesCache isNil ifTrue: [ ^nil].

	aFoundFeature := nil.
	effectiveFeaturesCache detect: [:aFeature |  | aFeatureReferencedType |
		aFeature isExclussion ifFalse: [ 
			(aFeature isAttribute or: [ aFeature isRelationship]) 
				ifTrue: [ 
					(aFeature maxMult = aFeature class  maxMultNone) ifFalse: [ 
						aFeatureReferencedType := aFeature referencedType.
						(aFeatureReferencedType isNil not and: [ aFeatureReferencedType name = theName])  ifTrue: [ aFoundFeature := aFeature].
					]
				]
				ifFalse: [ 
					aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
				]								
		].
		aFoundFeature isNil not
	] ifNone: [ nil].

	^aFoundFeature!

effectiveIDAttribute

	^self effectiveIDAttributeFromCache!

effectiveIDAttributeFromCache

	effectiveIDAttributeCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveIDAttributeCache isNil ifTrue: [ ^nil].

	effectiveIDAttributeCache == self class alreadyDerivedAttribute ifTrue: [ ^nil].

	^effectiveIDAttributeCache!

effectiveNameAttribute

	^self effectiveNameAttributeFromCache!

effectiveNameAttributeFromCache

	effectiveNameAttributeCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveNameAttributeCache isNil ifTrue: [ ^nil].

	effectiveNameAttributeCache == self class alreadyDerivedAttribute ifTrue: [ ^nil].

	^effectiveNameAttributeCache!

effectiveNameAttributeNoCache

	| someAttributesNotToInclude someAttributeNamesNotToInclude aNameAttribute |

	someAttributesNotToInclude := IdentitySet new: 13.
	someAttributeNamesNotToInclude := IdentitySet new: 13.

	aNameAttribute := self effectiveNameAttributeNotInclude: someAttributesNotToInclude notIncludeNamed: someAttributeNamesNotToInclude.
	^aNameAttribute!

effectiveOperationNamed: theName

	^self effectiveOperationNamedFromCache: theName!

effectiveOperationNamedFromCache: theName

	| aFoundOperation |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveOperationsCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveOperationsCache isNil ifTrue: [ ^nil].

	aFoundOperation := nil.
	effectiveOperationsCache detect: [:aOperation | 
		aOperation isExclussion ifFalse: [ 
			aOperation isOperation ifTrue: [ 
				aOperation name = theName ifTrue: [ aFoundOperation := aOperation].
			]
		].
		aFoundOperation isNil not
	] ifNone: [ nil].

	^aFoundOperation!

effectiveRelationshipNamed: theName

	^self effectiveRelationshipNamedFromCache: theName!

effectiveRelationshipNamedFromCache: theName

	| aFoundRelationship |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	effectiveRelationshipsCache isNil ifTrue: [ self initEffectiveFeaturesCaches].
	effectiveRelationshipsCache isNil ifTrue: [ ^nil].

	aFoundRelationship := nil.
	effectiveRelationshipsCache detect: [:aRelationship | 
		aRelationship isExclussion ifFalse: [ 
			aRelationship isRelationship ifTrue: [ 
				(aRelationship maxMult = aRelationship class  maxMultNone) ifFalse: [ 
					aRelationship name = theName ifTrue: [ aFoundRelationship := aRelationship].
				]
			]
		].
		aFoundRelationship isNil not
	] ifNone: [ nil].

	^aFoundRelationship! !

!CODEType publicMethodsFor: 'derived effective features obsolete'!

 allEffectiveAttributesInto: theAttributes notInclude: theAttributesNotToInclude notIncludeNamed: theAttributeNamesNotToInclude

	| someAttributesNotToInclude someAttributeNamesNotToInclude |
	
	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someAttributesNotToInclude := theAttributesNotToInclude copy.
		someAttributeNamesNotToInclude := theAttributeNamesNotToInclude copy.
		self attributes do: [:aFeature | 
			aFeature allRefinedAttributesInto: someAttributesNotToInclude.
			someAttributeNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveAttributesInto: theAttributes notInclude: someAttributesNotToInclude 
				notIncludeNamed: someAttributeNamesNotToInclude
		].
	].


	self attributes do: [:aFeature | 
		((theAttributesNotToInclude includes: aFeature) or: [ 
			theAttributeNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				theAttributes add: aFeature.
			]
		]
	].!

allEffectiveAttributesNoCache

	| someAttributes someAttributesNotToInclude someAttributeNamessNotToInclude |

	someAttributes := OrderedCollection new.
	someAttributesNotToInclude := IdentitySet new: 13.
	someAttributeNamessNotToInclude := IdentitySet new: 13.

	self allEffectiveAttributesInto: someAttributes notInclude: someAttributesNotToInclude notIncludeNamed: someAttributeNamessNotToInclude.

	^someAttributes asArray!

 allEffectiveFeaturesFromCacheInto: theFeatures notInclude: theFeaturesNotToInclude notIncludeNamed: theFeatureNamesNotToInclude

	
	effectiveFeaturesCache isNil ifTrue: [ ^self].

	effectiveFeaturesCache do: [:aFeature |
		((theFeaturesNotToInclude includes: aFeature) or: [ 
			theFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			aFeature isExclussion ifFalse: [ 
				(theFeatures includes: aFeature) ifFalse: [ 
					(aFeature isAttribute or: [ aFeature isRelationship]) 
						ifTrue: [ 
							(aFeature maxMult = aFeature class  maxMultNone) ifFalse: [ 
								theFeatures add: aFeature
							]
						]
						ifFalse: [ 
							theFeatures add: aFeature
						]								
				]
			]
		]
	].!

 allEffectiveFeaturesInto: theFeatures notInclude: theFeaturesNotToInclude notIncludeNamed: theFeatureNamesNotToInclude

	^effectiveFeaturesCache isNil
		ifTrue: [ self  allEffectiveFeaturesNoCacheInto: theFeatures notInclude: theFeaturesNotToInclude notIncludeNamed: theFeatureNamesNotToInclude]
		ifFalse: [ self  allEffectiveFeaturesFromCacheInto: theFeatures notInclude: theFeaturesNotToInclude notIncludeNamed: theFeatureNamesNotToInclude]!

 allEffectiveFeaturesNoCacheInto: theFeatures notInclude: theFeaturesNotToInclude notIncludeNamed: theFeatureNamesNotToInclude

	| someFeaturesNotToInclude someFeatureNamesNotToInclude |
	
	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someFeaturesNotToInclude := theFeaturesNotToInclude copy.
		someFeatureNamesNotToInclude := theFeatureNamesNotToInclude copy.
		self attributes do: [:aFeature | 
			aFeature allRefinedAttributesInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self relationships do: [:aFeature | 
			aFeature allRefinedRelationshipsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self operations do: [:aFeature | 
			aFeature allRefinedOperationsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveFeaturesInto: theFeatures notInclude: someFeaturesNotToInclude 
				notIncludeNamed: someFeatureNamesNotToInclude
		].
	].

	self attributes do: [:aFeature | 
		((theFeaturesNotToInclude includes: aFeature) or: [ 
			theFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				(theFeatures includes: aFeature) ifFalse: [ theFeatures add: aFeature]
			]
		]
	].

	self relationships do: [:aFeature | 
		((theFeaturesNotToInclude includes: aFeature) or: [ 
			theFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				(theFeatures includes: aFeature) ifFalse: [ theFeatures add: aFeature]
			]
		]
	].

	self operations do: [:aFeature | 
		((theFeaturesNotToInclude includes: aFeature) or: [ 
			theFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			aFeature isExclussion not ifTrue: [ 
				(theFeatures includes: aFeature) ifFalse: [ theFeatures add: aFeature]
			]
		]
	].!

 allEffectiveOperationsInto: theOperations notInclude: theOperationsNotToInclude notIncludeNamed: theAttributeNamesNotToInclude

	| someOperationsNotToInclude someAttributeNamesNotToInclude |
	
	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someOperationsNotToInclude := theOperationsNotToInclude copy.
		someAttributeNamesNotToInclude := theAttributeNamesNotToInclude copy.
		self operations do: [:aFeature | 
			aFeature allRefinedOperationsInto: someOperationsNotToInclude.
			someAttributeNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveOperationsInto: theOperations notInclude: someOperationsNotToInclude 
				notIncludeNamed: someAttributeNamesNotToInclude
		].
	].


	self operations do: [:aFeature | 
		((theOperationsNotToInclude includes: aFeature) or: [ 
			theAttributeNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			aFeature isExclussion not ifTrue: [ 
				(theOperations includes: aFeature) ifFalse: [ theOperations add: aFeature]
			]
		]
	].!

allEffectiveOperationsNoCache

	| someOperations someOperationsNotToInclude someOperationNamessNotToInclude |

	someOperations := OrderedCollection new.
	someOperationsNotToInclude := IdentitySet new: 13.
	someOperationNamessNotToInclude := IdentitySet new: 13.

	self allEffectiveOperationsInto: someOperations notInclude: someOperationsNotToInclude notIncludeNamed: someOperationNamessNotToInclude.

	^someOperations asArray!

 allEffectiveRelationshipsInto: theRelationships notInclude: theRelationshipsNotToInclude notIncludeNamed: theRelationshipNamesNotToInclude

	| someRelationshipsNotToInclude someRelationshipNamesNotToInclude |
	
	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someRelationshipsNotToInclude := theRelationshipsNotToInclude copy.
		someRelationshipNamesNotToInclude := theRelationshipNamesNotToInclude copy.
		self relationships do: [:aFeature | 
			aFeature allRefinedRelationshipsInto: someRelationshipsNotToInclude.
			someRelationshipNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveRelationshipsInto: theRelationships notInclude: someRelationshipsNotToInclude 
				notIncludeNamed: someRelationshipNamesNotToInclude
		].
	].


	self relationships do: [:aFeature | 
		((theRelationshipsNotToInclude includes: aFeature) or: [ 
			theRelationshipNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				theRelationships add: aFeature.
			]
		]
	].!

allEffectiveRelationshipsNoCache

	| someRelationships someRelationshipsNotToInclude someRelationshipNamessNotToInclude |

	someRelationships := OrderedCollection new.
	someRelationshipsNotToInclude := IdentitySet new: 13.
	someRelationshipNamessNotToInclude := IdentitySet new: 13.

	self allEffectiveRelationshipsInto: someRelationships notInclude: someRelationshipsNotToInclude notIncludeNamed: someRelationshipNamessNotToInclude.

	^someRelationships asArray!

 allEffectiveStructuralFeaturesInto: theFeatures notInclude: theFeaturesNotToInclude notIncludeNamed: theFeatureNamesNotToInclude

	| someFeaturesNotToInclude someFeatureNamesNotToInclude |
	
	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someFeaturesNotToInclude := theFeaturesNotToInclude copy.
		someFeatureNamesNotToInclude := theFeatureNamesNotToInclude copy.
		self attributes do: [:aFeature | 
			aFeature allRefinedAttributesInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self relationships do: [:aFeature | 
			aFeature allRefinedRelationshipsInto: someFeaturesNotToInclude.
			someFeatureNamesNotToInclude add: aFeature name
		].
		self superTypes do: [:aSuperType |
			aSuperType allEffectiveStructuralFeaturesInto: theFeatures notInclude: someFeaturesNotToInclude 
				notIncludeNamed: someFeatureNamesNotToInclude
		].
	].


	self attributes do: [:aFeature | 
		((theFeaturesNotToInclude includes: aFeature) or: [ 
			theFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				(theFeatures includes: aFeature) ifFalse: [ theFeatures add: aFeature]
			]
		]
	].
	self relationships do: [:aFeature | 
		((theFeaturesNotToInclude includes: aFeature) or: [ 
			theFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				(theFeatures includes: aFeature) ifFalse: [ theFeatures add: aFeature]
			]
		]
	].!

allEffectiveStructuralFeaturesNoCache

	| someFeatures someFeaturesNotToInclude someFeatureNamessNotToInclude |

	someFeatures := OrderedCollection new.
	someFeaturesNotToInclude := IdentitySet new: 13.
	someFeatureNamessNotToInclude := IdentitySet new: 13.

	self allEffectiveStructuralFeaturesInto: someFeatures notInclude: someFeaturesNotToInclude notIncludeNamed: someFeatureNamessNotToInclude.

	^someFeatures asArray!

effectiveAttributeNamed: theName notInclude: theAttributesNotToInclude notIncludeNamed: theAttributeNamesNotToInclude

	| aFoundAttribute someAttributesNotToInclude someAttributeNamesNotToInclude |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	aFoundAttribute := nil.
	self attributes detect: [:aAttribute | 
		((theAttributesNotToInclude includes: aAttribute) or: [ 
			theAttributeNamesNotToInclude includes: aAttribute name]) ifFalse: [ 
			(aAttribute isExclussion not and: [ (aAttribute maxMult = aAttribute class  maxMultNone) not]) ifTrue: [ 
				aAttribute name = theName ifTrue: [ aFoundAttribute := aAttribute].
			]
		].
		aFoundAttribute isNil not
	] ifNone: [ nil].

	aFoundAttribute isNil ifFalse: [ ^aFoundAttribute].

	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someAttributesNotToInclude := theAttributesNotToInclude copy.
		someAttributeNamesNotToInclude := theAttributeNamesNotToInclude copy.
		self attributes do: [:aAttribute | 
			aAttribute isRefinement  ifTrue: [ 
				aAttribute allRefinedAttributesInto: someAttributesNotToInclude
			].
			someAttributeNamesNotToInclude add: aAttribute name
		].
		aFoundAttribute := nil.
		self superTypes detect: [:aSuperType |
			aFoundAttribute := aSuperType effectiveAttributeNamed: theName notInclude: someAttributesNotToInclude 
				notIncludeNamed: someAttributeNamesNotToInclude.
			aFoundAttribute isNil not
		] ifNone: [ nil]
	].
	
	^aFoundAttribute!

effectiveAttributeNamedNoCache: theName

	| someAttributesNotToInclude someAttributeNamesNotToInclude aAttribute |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	someAttributesNotToInclude := IdentitySet new: 13.
	someAttributeNamesNotToInclude := IdentitySet new: 13.

	aAttribute := self effectiveAttributeNamed: theName 
		notInclude: someAttributesNotToInclude notIncludeNamed: someAttributeNamesNotToInclude.
	^aAttribute!

effectiveFeatureNamed: theName notInclude: theFeaturesNotToInclude notIncludeNamed: theFeatureNamesNotToInclude

	| aFoundFeature someFeaturesNotToInclude someFeatureNamesNotToInclude |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	aFoundFeature := nil.
	self attributes detect: [:aFeature | 
		((theFeaturesNotToInclude includes: aFeature) or: [ 
			theFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
			]
		].
		aFoundFeature isNil not
	] ifNone: [ nil].

	aFoundFeature isNil ifFalse: [ ^aFoundFeature].

	self relationships detect: [:aFeature | 
		((theFeaturesNotToInclude includes: aFeature) or: [ 
			theFeatureNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				aFeature name = theName ifTrue: [ aFoundFeature := aFeature].
			]
		].
		aFoundFeature isNil not
	] ifNone: [ nil].

	aFoundFeature isNil ifFalse: [ ^aFoundFeature].


	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someFeaturesNotToInclude := theFeaturesNotToInclude copy.
		someFeatureNamesNotToInclude := theFeatureNamesNotToInclude copy.
		self attributes do: [:aFeature | 
			aFeature isRefinement  ifTrue: [ 
				aFeature allRefinedAttributesInto: someFeaturesNotToInclude
			].
			someFeatureNamesNotToInclude add: aFeature name
		].
		self relationships do: [:aFeature | 
			aFeature isRefinement  ifTrue: [ 
				aFeature allRefinedRelationshipsInto: someFeaturesNotToInclude
			].
			someFeatureNamesNotToInclude add: aFeature name
		].
		aFoundFeature := nil.
		self superTypes detect: [:aSuperType |
			aFoundFeature := aSuperType effectiveFeatureNamed: theName notInclude: someFeaturesNotToInclude 
				notIncludeNamed: someFeatureNamesNotToInclude.
			aFoundFeature isNil not
		] ifNone: [ nil]
	].
	
	^aFoundFeature!

effectiveFeatureNamedNoCache: theName

	| someFeaturesNotToInclude someFeatureNamesNotToInclude aFeature |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	someFeaturesNotToInclude := IdentitySet new: 13.
	someFeatureNamesNotToInclude := IdentitySet new: 13.

	aFeature := self effectiveFeatureNamed: theName 
		notInclude: someFeaturesNotToInclude notIncludeNamed: someFeatureNamesNotToInclude.
	^aFeature!

effectiveIDAttributeNoCache

	| someAttributesNotToInclude someAttributeNamesNotToInclude aNameAttribute |

	someAttributesNotToInclude := IdentitySet new: 13.
	someAttributeNamesNotToInclude := IdentitySet new: 13.

	aNameAttribute := self effectiveIDAttributeNotInclude: someAttributesNotToInclude notIncludeNamed: someAttributeNamesNotToInclude.
	^aNameAttribute!

effectiveIDAttributeNotInclude: theAttributesNotToInclude notIncludeNamed: theAttributeNamesNotToInclude

	| someAttributesNotToInclude someAttributeNamesNotToInclude aIDAttribute |

	aIDAttribute := nil.
	self attributes detect: [:aFeature | 
		((theAttributesNotToInclude includes: aFeature) or: [ 
			theAttributeNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				aFeature isIDAttribute ifTrue: [ aIDAttribute := aFeature].
			]
		].
		aIDAttribute isNil not
	] ifNone: [ nil].

	aIDAttribute isNil ifFalse: [ ^aIDAttribute].

	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someAttributesNotToInclude := theAttributesNotToInclude copy.
		someAttributeNamesNotToInclude := theAttributeNamesNotToInclude copy.
		self attributes do: [:aFeature | 
			aFeature isRefinement  ifTrue: [ 
				aFeature allRefinedAttributesInto: someAttributesNotToInclude
			].
			someAttributeNamesNotToInclude add: aFeature name
		].
		aIDAttribute := nil.
		self superTypes detect: [:aSuperType |
			aIDAttribute := aSuperType effectiveIDAttributeNotInclude: someAttributesNotToInclude 
				notIncludeNamed: someAttributeNamesNotToInclude.
			aIDAttribute isNil not
		] ifNone: [ nil]
	].
	
	^aIDAttribute!

effectiveNameAttributeNotInclude: theAttributesNotToInclude notIncludeNamed: theAttributeNamesNotToInclude

	| someAttributesNotToInclude someAttributeNamesNotToInclude aNameAttribute |

	aNameAttribute := nil.
	self attributes detect: [:aFeature | 
		((theAttributesNotToInclude includes: aFeature) or: [ 
			theAttributeNamesNotToInclude includes: aFeature name]) ifFalse: [ 
			(aFeature isExclussion not and: [ (aFeature maxMult = aFeature class  maxMultNone) not]) ifTrue: [ 
				aFeature isNameAttribute ifTrue: [ aNameAttribute := aFeature].
			]
		].
		aNameAttribute isNil not
	] ifNone: [ nil].

	aNameAttribute isNil ifFalse: [ ^aNameAttribute].

	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someAttributesNotToInclude := theAttributesNotToInclude copy.
		someAttributeNamesNotToInclude := theAttributeNamesNotToInclude copy.
		self attributes do: [:aFeature | 
			aFeature isRefinement  ifTrue: [ 
				aFeature allRefinedAttributesInto: someAttributesNotToInclude
			].
			someAttributeNamesNotToInclude add: aFeature name
		].
		aNameAttribute := nil.
		self superTypes detect: [:aSuperType |
			aNameAttribute := aSuperType effectiveNameAttributeNotInclude: someAttributesNotToInclude 
				notIncludeNamed: someAttributeNamesNotToInclude.
			aNameAttribute isNil not
		] ifNone: [ nil]
	].
	
	^aNameAttribute!

effectiveOperationNamed: theName notInclude: theOperationsNotToInclude notIncludeNamed: theOperationNamesNotToInclude

	| aFoundOperation someOperationsNotToInclude someOperationNamesNotToInclude |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	aFoundOperation := nil.
	self operations detect: [:aOperation | 
		((theOperationsNotToInclude includes: aOperation) or: [ 
			theOperationNamesNotToInclude includes: aOperation name]) ifFalse: [ 
			(aOperation isExclussion not and: [ (aOperation maxMult = aOperation class  maxMultNone) not]) ifTrue: [ 
				aOperation name = theName ifTrue: [ aFoundOperation := aOperation].
			]
		].
		aFoundOperation isNil not
	] ifNone: [ nil].

	aFoundOperation isNil ifFalse: [ ^aFoundOperation].

	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someOperationsNotToInclude := theOperationsNotToInclude copy.
		someOperationNamesNotToInclude := theOperationNamesNotToInclude copy.
		self operations do: [:aOperation | 
			aOperation isRefinement  ifTrue: [ 
				aOperation allRefinedOperationsInto: someOperationsNotToInclude
			].
			someOperationNamesNotToInclude add: aOperation name
		].
		aFoundOperation := nil.
		self superTypes detect: [:aSuperType |
			aFoundOperation := aSuperType effectiveOperationNamed: theName notInclude: someOperationsNotToInclude 
				notIncludeNamed: someOperationNamesNotToInclude.
			aFoundOperation isNil not
		] ifNone: [ nil]
	].
	
	^aFoundOperation!

effectiveOperationNamedNoCache: theName

	| someOperationsNotToInclude someOperationNamesNotToInclude aOperation |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	someOperationsNotToInclude := IdentitySet new: 13.
	someOperationNamesNotToInclude := IdentitySet new: 13.

	aOperation := self effectiveOperationNamed: theName 
		notInclude: someOperationsNotToInclude notIncludeNamed: someOperationNamesNotToInclude.
	^aOperation!

effectiveRelationshipNamed: theName notInclude: theRelationshipsNotToInclude notIncludeNamed: theRelationshipNamesNotToInclude

	| aFoundRelationship someRelationshipsNotToInclude someRelationshipNamesNotToInclude |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	aFoundRelationship := nil.
	self relationships detect: [:aRelationship | 
		((theRelationshipsNotToInclude includes: aRelationship) or: [ 
			theRelationshipNamesNotToInclude includes: aRelationship name]) ifFalse: [ 
			(aRelationship isExclussion not and: [ (aRelationship maxMult = aRelationship class  maxMultNone) not]) ifTrue: [ 
				aRelationship name = theName ifTrue: [ aFoundRelationship := aRelationship].
			]
		].
		aFoundRelationship isNil not
	] ifNone: [ nil].

	aFoundRelationship isNil ifFalse: [ ^aFoundRelationship].


	(self superTypes isNil not and: [ self superTypes isEmpty not]) ifTrue: [ 
		someRelationshipsNotToInclude := theRelationshipsNotToInclude copy.
		someRelationshipNamesNotToInclude := theRelationshipNamesNotToInclude copy.
		self relationships do: [:aRelationship | 
			aRelationship isRefinement  ifTrue: [ 
				aRelationship allRefinedRelationshipsInto: someRelationshipsNotToInclude
			].
			someRelationshipNamesNotToInclude add: aRelationship name
		].
		aFoundRelationship := nil.
		self superTypes detect: [:aSuperType |
			aFoundRelationship := aSuperType effectiveRelationshipNamed: theName notInclude: someRelationshipsNotToInclude 
				notIncludeNamed: someRelationshipNamesNotToInclude.
			aFoundRelationship isNil not
		] ifNone: [ nil]
	].
	
	^aFoundRelationship!

effectiveRelationshipNamedNoCache: theName

	| someRelationshipsNotToInclude someRelationshipNamesNotToInclude aRelationship |

	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^nil].

	someRelationshipsNotToInclude := IdentitySet new: 13.
	someRelationshipNamesNotToInclude := IdentitySet new: 13.

	aRelationship := self effectiveRelationshipNamed: theName 
		notInclude: someRelationshipsNotToInclude notIncludeNamed: someRelationshipNamesNotToInclude.
	^aRelationship! !

!CODEType publicMethodsFor: 'derived for generation'!

aspectToGenerate
	self model isNil ifTrue: [ ^''].
	^self model aspectToGenerate!

attributesM3MultiInherited

	| aSuperType someAttributes someOtherAttributes someSortedAttributes |

	self superTypesSize < 2 ifTrue: [ ^OrderedCollection new: 0].

	aSuperType := self superTypes first.
	someAttributes := IdentitySet new: 37.
	someAttributes addAll: self attributes.
	aSuperType allAttributesInto: someAttributes.
	
	someOtherAttributes := IdentitySet new: 37.
	(self superTypes copyFrom: 2 to: self superTypesSize) do: [:aType | 
		aType allAttributesInto: someOtherAttributes	
	].
		
	someAttributes do: [:anAttribute | someOtherAttributes remove: anAttribute ifAbsent: [ nil]].
	someSortedAttributes := someOtherAttributes asSortedCollection: [:anAttr :otherAttr |
		anAttr name < otherAttr name].
	
	^someSortedAttributes!

attributesToGenerate

	| aSuperType someAttributes someOtherAttributes someSortedAttributes |

	attributesToGenerate isNil ifFalse: [ ^attributesToGenerate].

	self superTypesSize < 2 ifTrue: [ ^self attributes].

	aSuperType := self superTypes first.
	someAttributes := IdentitySet new: 37.
	someAttributes addAll: self attributes.
	aSuperType allAttributesInto: someAttributes.
	
	someOtherAttributes := IdentitySet new: 37.
	(self superTypes copyFrom: 2 to: self superTypesSize) do: [:aType | 
		aType allAttributesInto: someOtherAttributes	
	].
		
	someAttributes do: [:anAttribute | someOtherAttributes remove: anAttribute ifAbsent: [ nil]].
	someSortedAttributes := someOtherAttributes asSortedCollection: [:anAttr :otherAttr |
		anAttr name < otherAttr name].
	
	attributesToGenerate := self attributes , someSortedAttributes.
	^attributesToGenerate!

attributesWithLocalM3Storage

	^self attributes!

derivedRelationshipsToGenerate

	| someRelationships someDerivedRelationships |

	derivedRelationshipsToGenerate isNil ifFalse: [ ^derivedRelationshipsToGenerate].

	someRelationships := self relationshipsToGenerate.
	someRelationships isNil ifTrue: [ ^someRelationships].

	someDerivedRelationships := someRelationships select: [:aRelationship | aRelationship derived].

	derivedRelationshipsToGenerate := someDerivedRelationships.
	^derivedRelationshipsToGenerate!

isRootType
	^self superTypesSize < 1 and: [ self isPrimitive not and: [ self isEnumeration not]]!

isTreeRootType
	| aModel |

	aModel := self model.
	aModel isNil ifTrue: [ ^false].

	^aModel rootTypeName = self name!

relationshipsM3MultiInherited

	| aSuperType someRelationships someOtherRelationships someSortedRelationships |

	self superTypesSize < 2 ifTrue: [ ^OrderedCollection new: 0].

	aSuperType := self superTypes first.
	someRelationships := IdentitySet new: 37.
	someRelationships addAll: self relationships.
	aSuperType allRelationshipsInto: someRelationships.
	
	someOtherRelationships := IdentitySet new: 37.
	(self superTypes copyFrom: 2 to: self superTypesSize) do: [:aType | 
		aType allRelationshipsInto: someOtherRelationships	
	].
		
	someRelationships do: [:aRelationship | someOtherRelationships remove: aRelationship ifAbsent: [ nil]].
	someSortedRelationships := someOtherRelationships asSortedCollection: [:aRel :otherRel |
		aRel name < otherRel name].
	
	^someSortedRelationships!

relationshipsToGenerate

	| aSuperType someRelationships someOtherRelationships someSortedRelationships |

	relationshipsToGenerate isNil ifFalse: [ ^relationshipsToGenerate].

	self superTypesSize < 2 ifTrue: [ ^self relationships].

	aSuperType := self superTypes first.
	someRelationships := IdentitySet new: 37.
	someRelationships addAll: self relationships.
	aSuperType allRelationshipsInto: someRelationships.
	
	someOtherRelationships := IdentitySet new: 37.
	(self superTypes copyFrom: 2 to: self superTypesSize) do: [:aType | 
		aType allRelationshipsInto: someOtherRelationships	
	].
		
	someRelationships do: [:aRelationship | someOtherRelationships remove: aRelationship ifAbsent: [ nil]].
	someSortedRelationships := someOtherRelationships asSortedCollection: [:aRel :otherRel |
		aRel name < otherRel name].
	
	relationshipsToGenerate := self relationships , someSortedRelationships.
	^relationshipsToGenerate!

relationshipsToGenerateBMgrs

	| someRelationships someSelectedRelationships |
	someRelationships := self relationshipsToGenerate.
	someSelectedRelationships := someRelationships select: [:aRelationship | aRelationship mustGenerateBMgr].
	^someSelectedRelationships!

relationshipsWithLocalM3Storage

	^self relationships!

relationshipTraversalsToTreeRoot
	self isTreeRootType ifTrue: [ ^#() copy].! !

!CODEType publicMethodsFor: 'derived use'!

initUseFeatures: theFeatures! !

!CODEType publicMethodsFor: 'dirty'!

cleanDirtyMark
	super cleanDirtyMark.
	self attributes do: [:anAttrib | anAttrib cleanDirtyMark].
	self relationships do: [:aRel | aRel cleanDirtyMark].!

markDirty
	super markDirty.

	dirty == true ifFalse: [ 
		self module isNil ifFalse: [ self module markDirtyOwner]
	].!

markDirtyOwner
	self mustStore 
		ifTrue: [ self markDirty]
		ifFalse: [ self module isNil ifFalse: [ self module markDirty]]!

persistIfDirty
	^self module isNil ifFalse: [ self module persistIfDirty] ifTrue: [ nil]! !

!CODEType publicMethodsFor: 'find'!

attributeNamed: theAttributeName
	
	| anExistingAttribute |
	theAttributeName isNil ifTrue: [ ^self].
	anExistingAttribute := self attributes detect: [:anAttribute | anAttribute name = theAttributeName] ifNone: [ nil].
	^anExistingAttribute!

attributeOrInheritedNamed: theFeatureName
	
	| anExistingFeature someSuperTypes |

	theFeatureName isNil ifTrue: [ ^nil].

	anExistingFeature := self attributes detect: [:anAttribute | anAttribute name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^nil].

	someSuperTypes detect: [:aSuperType |  | aFeature |
		aFeature := aSuperType attributeOrInheritedNamed: theFeatureName.
		aFeature isNil ifFalse: [ ^aFeature] ifTrue: [ false]
	] ifNone: [ nil].

	^nil!

featureNamed: theFeatureName
	
	| anExistingFeature |

	theFeatureName isNil ifTrue: [ ^self].

	anExistingFeature := self attributes detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self relationships detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self operations detect: [:anFeature | anFeature name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	^nil!

featureOrInheritedNamed: theFeatureName
	
	| anExistingFeature someSuperTypes |

	theFeatureName isNil ifTrue: [ ^nil].

	anExistingFeature := self attributes detect: [:anAttribute | anAttribute name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	anExistingFeature := self relationships detect: [:aRelationship | aRelationship name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^nil].

	someSuperTypes detect: [:aSuperType |  | aFeature |
		aFeature := aSuperType featureOrInheritedNamed: theFeatureName.
		aFeature isNil ifFalse: [ ^aFeature] ifTrue: [ false]
	] ifNone: [ nil].

	^nil!

hasOrInheritsFeature: theFeature
	
	| someSuperTypes aResult |

	theFeature isNil ifTrue: [ ^false].

	(self attributesIncludes: theFeature) 			ifTrue: [ ^true].
	(self relationshipsIncludes: theFeature) 		ifTrue: [ ^true].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSuperTypes detect: [:aSuperType | 
		aSuperType hasOrInheritsFeature: theFeature] ifNone: [ nil]) isNil not.

	^aResult!

hasOrInheritsFeatureNamed: theFeatureName
	
	| anExistingFeature someSuperTypes aResult |

	theFeatureName isNil ifTrue: [ ^false].

	anExistingFeature := self attributes detect: [:anAttribute | anAttribute name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^true].

	anExistingFeature := self relationships detect: [:aRelationship | aRelationship name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^true].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSuperTypes detect: [:aSuperType | 
		aSuperType hasOrInheritsFeatureNamed: theFeatureName] ifNone: [ nil]) isNil not.

	^aResult!

hasOrInheritsOperation: theOperation
	
	| someSuperTypes aResult |

	theOperation isNil ifTrue: [ ^false].

	(self operationsIncludes: theOperation) 			ifTrue: [ ^true].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSuperTypes detect: [:aSuperType | 
		aSuperType hasOrInheritsOperation: theOperation] ifNone: [ nil]) isNil not.

	^aResult!

hasOrInheritsOperationNamed: theOperationName
	
	| anExistingOperation someSuperTypes aResult |

	theOperationName isNil ifTrue: [ ^false].

	anExistingOperation := self attributes detect: [:anOperation | anOperation name = theOperationName] ifNone: [ nil].
	anExistingOperation isNil ifFalse: [ ^true].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^false].

	aResult := (someSuperTypes detect: [:aSuperType | 
		aSuperType hasOrInheritsOperationNamed: theOperationName] ifNone: [ nil]) isNil not.

	^aResult!

hasOrInheritsRelationshipNamed: theRelationshipName
	theRelationshipName isNil ifTrue: [ ^false].

	(self relationshipNamed: theRelationshipName) isNil ifFalse: [ ^true].
	self superTypesSize < 1 ifTrue: [ ^false].
	^(self superTypes detect: [:aSuperType | aSuperType hasOrInheritsRelationshipNamed: theRelationshipName]
		ifNone: [ nil]) isNil not!

operationNamed: theOperationName
	
	| anExistingOperation |
	theOperationName isNil ifTrue: [ ^self].
	anExistingOperation := self operations detect: [:anOperation | anOperation name = theOperationName] ifNone: [ nil].
	^anExistingOperation!

operationOrInheritedNamed: theFeatureName
	
	| anExistingFeature someSuperTypes |

	theFeatureName isNil ifTrue: [ ^nil].

	anExistingFeature := self operations detect: [:anOperation | anOperation name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^nil].

	someSuperTypes detect: [:aSuperType |  | aFeature |
		aFeature := aSuperType operationOrInheritedNamed: theFeatureName.
		aFeature isNil ifFalse: [ ^aFeature] ifTrue: [ false]
	] ifNone: [ nil].

	^nil!

relationshipNamed: theRelationshipName
	
	| anExistingRelationship |
	theRelationshipName isNil ifTrue: [ ^self].
	anExistingRelationship := self relationships detect: [:aRelationship | aRelationship name = theRelationshipName] ifNone: [ nil].
	^anExistingRelationship!

relationshipOrInheritedNamed: theFeatureName
	
	| anExistingFeature someSuperTypes |

	theFeatureName isNil ifTrue: [ ^nil].

	anExistingFeature := self relationships detect: [:aRelationship | aRelationship name = theFeatureName] ifNone: [ nil].
	anExistingFeature isNil ifFalse: [ ^anExistingFeature].

	someSuperTypes := self superTypes.
	(someSuperTypes isNil or: [ someSuperTypes isEmpty]) ifTrue: [ ^nil].

	someSuperTypes detect: [:aSuperType |  | aFeature |
		aFeature := aSuperType relationshipOrInheritedNamed: theFeatureName.
		aFeature isNil ifFalse: [ ^aFeature] ifTrue: [ false]
	] ifNone: [ nil].

	^nil! !

!CODEType publicMethodsFor: 'generate'!

generate
	
	self skip ifTrue: [ ^self].
Transcript show: 'T ', self name;cr.

	self aspectToGenerate = CODEModel aspectToGenerateBrowser
		ifTrue: [  	^self generateBrowser]
		ifFalse: [ 	^self generateMetamodelElements].!

generateAttributesDeletes
 
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributesToGenerate do: [:anAttribute | anAttribute generateAttributeDeleteForType: self]!

generateBase
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'base'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self baseOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'AttributesImplementations'
				ifTrue: [ self generateBaseAttributeImplementations] ifFalse: [
			aKey = 'RelationshipsImplementations'
				ifTrue: [ self generateBaseRelationshipImplementations]
				ifFalse: [
			aKey = 'AttributesStorageDefinitions'
				ifTrue: [ self generateBaseAttributeStorageDefinitions]
				ifFalse: [
			aKey = 'RelationshipsStorageDefinitions'
				ifTrue: [ self generateBaseRelationshipStorageDefinitions]
				ifFalse: [ 
			aKey = 'PortsSynchChangeDetection'
				ifTrue: [ self generatePortsSynchChangeDetection]
				ifFalse: [ 
			aKey = 'PortsCreation'
				ifTrue: [ self generatePortsCreation]
				ifFalse: [ 
			aKey = 'PropertiesSynchChangeDetection'
				ifTrue: [ self generatePropertiesSynchChangeDetection]
				ifFalse: [ 
			aKey = 'PropertiesInitialization'
				ifTrue: [ self generatePropertiesInitialization]
				ifFalse: [ 
			
			aKey = 'AttributesDeletes'
				ifTrue: [ self generateAttributesDeletes]
				ifFalse: [ 
			
			aKey = 'RelationshipsDeletes'
				ifTrue: [ self generateRelationshipsDeletes]
				ifFalse: [ 
			
			aKey = 'M3AttributesStorageDefinitions'
				ifTrue: [ self generateM3AttributesStorageDefinitions]
				ifFalse: [ 
			
			aKey = 'M3RelationshipsStorageDefinitions'
				ifTrue: [ self generateM3RelationshipsStorageDefinitions]
				ifFalse: [ 

			aKey = 'M3TypePhase1Initialization'
				ifTrue: [ self generateM3TypePhase1Initialization]
				ifFalse: [ 

			aKey = 'M3AttributesPhase1Initializations'
				ifTrue: [ self generateM3AttributesPhase1Initializations]
				ifFalse: [ 

			aKey = 'M3RelationshipsPhase1Initializations'
				ifTrue: [ self generateM3RelationshipsPhase1Initializations]
				ifFalse: [ 

			aKey = 'M3TypePhase2Initialization'
				ifTrue: [ self generateM3TypePhase2Initialization]
				ifFalse: [ 

			aKey = 'M3AttributesPhase2Initializations'
				ifTrue: [ self generateM3AttributesPhase2Initializations]
				ifFalse: [ 

			aKey = 'M3RelationshipsPhase2Initializations'
				ifTrue: [ self generateM3RelationshipsPhase2Initializations]
				ifFalse: [ 

			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self baseOutStream nextPutAll: anExpansion]]]]]]]]]]]]]]]]]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateBaseAttributeImplementations
	self isEnumeration ifTrue: [ ^self].
	self isPrimitive ifTrue: [ ^self].

	self attributesToGenerate do: [:aAttribute | aAttribute generateBaseImplementationForType: self]!

generateBaseAttributeStorageDefinitions
 
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributesToGenerate do: [:aAttribute | aAttribute generateBaseStorageDefinitionForType: self]!

generateBaseRelationshipImplementations

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generateBaseImplementationForType: self]!

generateBaseRelationshipStorageDefinitions

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generateBaseStorageDefinitionForType: self]!

generateBmgrConfigs

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateBmgrConfig]!

generateBMgrs

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generateBMgrForType: self]!

generateBmgrStaticDeclarations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateBmgrStaticDeclaration]!

generateBrowser
	
	self skip ifTrue: [ ^self].

	[ 
		(self isEnumeration not and: [ self isPrimitive not]) 
			ifTrue: [ 
				self generateNMgr.
				self generateBMgrs.
				self generateChooser.
				self model generateSeparateActions ifTrue: [ 
					self generateDeleteAction.
					self generateRelationshipsSeparateActions
				]
			]
			ifFalse: [ 
				self isPrimitive ifFalse: [ 
				]
			]
	]
		valueNowOrOnUnwindDo:
	[
		nmgrOutStream isNil ifFalse: [ nmgrOutStream close. nmgrOutStream := nil].
		chooserOutStream isNil ifFalse: [ chooserOutStream close. chooserOutStream := nil].
		deleteActionOutStream isNil ifFalse: [ deleteActionOutStream close. deleteActionOutStream := nil].
	]!

generateChooser
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].
	self isAbstract ifTrue: [ ^self ].

	aTemplateFileName := self templateFileNameForChooser.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self chooserOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 

			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self chooserOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateClassNodeConfigOverrideForRelationship: theRelationship

	| anStream |
	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].
	self isAbstract ifTrue: [ ^self ].

	anStream := self wholeTreeConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab; nextPutAll: 'a', (theRelationship expand: 'TypeAndRelationshipName'), 'BCNC.addClassNodeConfigOverride( new MMClassNodeConfigOverride( theCtxt.getMMFactory("',
			self typePrefix, '").getClassForType( theCtxt, "', 
			self upperInitialName, '","', self  allContainerPackageNames, '"), a', self upperInitialName, 'NMgr, null ));'; cr.

"    aPackage_packagesBCNC.addClassNodeConfigOverride(   new MMClassNodeConfigOverride( theCtxt.getMMFactory().getClassForType( theCtxt, 'Package'), aPackageNMgr, null ));
"
	]!

generateCust

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'cust'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self custOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 			
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self custOutStream nextPutAll: anExpansion]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateDeleteAction
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	"(self isAbstract and: [ self isAggregated not]) ifTrue: [ ^self]."



	aTemplateFileName := self templateFileNameForDeleteAction.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self deleteActionOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 

			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self deleteActionOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateEnumerationProjectNodeDeclarations: theStartIndex
	| anStream anStartIndex |

	self skip ifTrue: [ ^self].

	self isEnumeration 	ifFalse: [ ^theStartIndex].

	anStartIndex := theStartIndex.

	self ifcOutPrjNdx: anStartIndex.

	anStartIndex := anStartIndex + 1.

	anStream := self prjOutStream.
	anStream isNil ifTrue: [ ^anStartIndex].

	anStream nextPutAll: '#' , self ifcOutPrjNdx printString, '=',  self projectNodeIfcDeclarationName; cr.

	^anStartIndex!

generateEnumerationProjectNodeParameters

	| anStream |

	self skip ifTrue: [ ^self].

	self isEnumeration 	ifFalse: [ ^self ].


	anStream := self prjOutStream.
	anStream isNil ifFalse: [

		anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].Parent=', 
			(self module isNil ifTrue: [ '0'] ifFalse: [ self module ifcOutPrjNdx printString]); cr.
		anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].RunParameters='; cr.
		anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].JavaVmParameters='; cr.
	]!

generateIfc

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'ifc'.
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self ifcOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'AttributesIfcDeclarations'
				ifTrue: [ self generateIfcAttributeDeclarations] ifFalse: [
			aKey = 'RelationshipsIfcDeclarations'
				ifTrue: [ self generateIfcRelationshipDeclarations]
				ifFalse: [
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self ifcOutStream nextPutAll: anExpansion]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateIfcAttributeDeclarations

	self isPrimitive ifTrue: [ ^self ].

	self attributesToGenerate do: [:aAttribute | aAttribute generateIfcDeclarationForType: self]!

generateIfcRelationshipDeclarations

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generateIfcDeclarationForType: self]!

generateImpl

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'impl'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self implOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 			
			
			aKey = 'RelationshipsImplementations'
				ifTrue: [ self generateImplRelationshipImplementations]
				ifFalse: [

			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self implOutStream nextPutAll: anExpansion]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateImplRelationshipImplementations

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self derivedRelationshipsToGenerate do: [:aRelationship | aRelationship generateImplImplementationForType: self]!

generateM3AttributesPhase1Initializations
 
	self attributesWithLocalM3Storage do: [:aAttribute | aAttribute generateM3Phase1InitializationForType: self]!

generateM3AttributesPhase2Initializations
	self attributesWithLocalM3Storage do: [:aAttribute |  aAttribute generateM3Phase2LocalStorageInitializationForType: self].

	self attributesM3MultiInherited do: [:aAttribute |  aAttribute generateM3Phase2MultiInheritedInitializationForType: self]!

generateM3AttributesStorageDefinitions
 
	self attributesToGenerate do: [:aAttribute | aAttribute generateM3StorageDefinitionForType: self]!

generateM3ModelPhase1Initialization
	|  |
	self skip ifTrue: [ ^self].
	self  model metamodelOutStream 
		tab; tab;
		nextPutAll: self metaHolderClassName;
		nextPutAll: '.initM3TypePhase1( theCtxt);'; 
		cr

"/*
	com.d_a_t.eai.studio.metamodel.impl.EAIProjectImpl.initM3TypePhase1( theCtxt);
*/
"!

generateM3ModelPhase2Initialization
	self skip ifTrue: [ ^self].

	self  model metamodelOutStream 
		tab; tab;
		nextPutAll: self metaHolderClassName;
		nextPutAll: '.initM3TypePhase2( theCtxt);'; 
		cr

"/*
	com.d_a_t.eai.studio.metamodel.impl.EAIProjectImpl.initM3TypePhase2( theCtxt);
*/
"!

generateM3RelationshipsPhase1Initializations
 
	self relationshipsWithLocalM3Storage do: [:aRelationship | aRelationship generateM3Phase1InitializationForType: self]!

generateM3RelationshipsPhase2Initializations
 
	self relationshipsWithLocalM3Storage do: [:aRelationship | aRelationship generateM3Phase2LocalStorageInitializationForType: self]	.

	self relationshipsM3MultiInherited do: [:aRelationship | aRelationship generateM3Phase2MultiInheritedInitializationForType: self].!

generateM3RelationshipsStorageDefinitions
 
	self relationshipsToGenerate do: [:aRelationship | aRelationship generateM3StorageDefinitionForType: self]!

generateM3TypeInModuleInitialization

	self skip ifTrue: [ ^self].

	self  metamodelOutStream 
		tab; tab;
		nextPutAll: (self module expand: 'MetaVariableName');
		nextPutAll: '.addTypes( theCtxt,';
		nextPutAll: self metaHolderClassName;
		nextPutAll: '.vm3Type);';
		cr


"    
	  vm3CoreModule.addTypes( theCtxt, com.d_a_t.cx.core.impl.CxPackageImpl.vm3Type);
"!

generateM3TypePhase1Initialization
	self  metaOutStream 
		tab; tab;
		nextPutAll: ' vm3Type = (',self metaTypeFullIfcPrefixedClassName,') theCtxt.getMMFactory("', self model m3FactoryName, 
			'").createMMElementOfType( theCtxt, "Type", "core",',
			'"', self name, '");';cr.

	self generateM3TypePhase1InitializationSetAttr: 'isEnumeration' value: self isEnumeration.
	self generateM3TypePhase1InitializationSetAttr: 'isPrimitive' value: self isPrimitive.
	self generateM3TypePhase1InitializationSetAttr: 'isAbstract' value: self isAbstract.

	self  metaOutStream  cr.

	

"//    vm3Type = new com.d_a_t.eai.studio.m3.M3TypeImpl( new EAIMMName( 'Project'));"!

generateM3TypePhase1InitializationSetAttr: theAttrName value: theValue
	| aValue |
	theValue isNil ifTrue: [ ^self].

	aValue := self toSetAttributeArgumentValue: theValue.

	self  metaOutStream 
		tab; tab;
		nextPutAll: ' vm3Type.set';
		nextPutAll: (self toUpperInitial: theAttrName);
		nextPutAll: '( theCtxt, ';
		nextPutAll: aValue;
		nextPutAll: ');'; 
		cr!

generateM3TypePhase2Initialization
	| aStream |
	aStream := self  metaOutStream.

	self superTypes do: [:aType |
		aType skip ifFalse: [ 
			aStream
				tab; tab; 
				nextPutAll: 'vm3Type.addSuperTypes( theCtxt, '; nextPutAll: (aType metaHolderClassName) ;
					nextPutAll: '.vm3Type);';  cr
		]
	]

	

"//    vmM3Type.addSupertypes( theCtxt, EAIMMElementBase.vm3Type);
"!

generateMeta
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'meta'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self metaOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			aKey = 'M3AttributesStorageDefinitions'
				ifTrue: [ self generateM3AttributesStorageDefinitions]
				ifFalse: [ 
			
			aKey = 'M3RelationshipsStorageDefinitions'
				ifTrue: [ self generateM3RelationshipsStorageDefinitions]
				ifFalse: [ 

			aKey = 'M3TypePhase1Initialization'
				ifTrue: [ self generateM3TypePhase1Initialization]
				ifFalse: [ 

			aKey = 'M3AttributesPhase1Initializations'
				ifTrue: [ self generateM3AttributesPhase1Initializations]
				ifFalse: [ 

			aKey = 'M3RelationshipsPhase1Initializations'
				ifTrue: [ self generateM3RelationshipsPhase1Initializations]
				ifFalse: [ 

			aKey = 'M3TypePhase2Initialization'
				ifTrue: [ self generateM3TypePhase2Initialization]
				ifFalse: [ 

			aKey = 'M3AttributesPhase2Initializations'
				ifTrue: [ self generateM3AttributesPhase2Initializations]
				ifFalse: [ 

			aKey = 'M3RelationshipsPhase2Initializations'
				ifTrue: [ self generateM3RelationshipsPhase2Initializations]
				ifFalse: [ 

			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self metaOutStream nextPutAll: anExpansion]]]]]]]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateMetamodelElements
	
	self skip ifTrue: [ ^self].

	[ 
		(self isEnumeration not and: [ self isPrimitive not]) 
			ifTrue: [ 
				self isGenerationStyleDynamicReduced ifTrue: [
					self generateMeta.
					self generateBase.
					self generateImpl.
					self generateIfc.
					self generatePub.
				] ifFalse: [ 
				self isGenerationStyleDynamic ifTrue: [
					self generateMeta.
					self generateBase.
					self generateImpl.
					"self generateCust."
					self generateIfc.
					"self generateTrx."
					self generatePriv	.
					self generatePub.
				] ifFalse: [ 
					self generateMeta.
					self generateBase.
					self generateImpl.
					"self generateCust."
					self generateIfc.
					"self generateTrx."
					self generatePriv	.
					self generatePub.
				]]
			]
			ifFalse: [ 
				self isPrimitive ifFalse: [ 
					self isGenerationStyleDynamicReduced ifTrue: [
						self generateMeta
					].
					self generateIfc.
					self generateBase.
				]
			]
	]
		valueNowOrOnUnwindDo:
	[
		metaOutStream isNil ifFalse: [ metaOutStream close. metaOutStream := nil].
		baseOutStream isNil ifFalse: [ baseOutStream close. baseOutStream := nil].
		implOutStream isNil ifFalse: [ implOutStream close. implOutStream := nil].
		custOutStream isNil ifFalse: [ custOutStream close. custOutStream := nil].
		ifcOutStream isNil ifFalse: [ ifcOutStream close. ifcOutStream := nil].
		trxOutStream isNil ifFalse: [ trxOutStream close. ifcOutStream := nil].
		privOutStream isNil ifFalse: [ privOutStream close. privOutStream := nil].
		pubOutStream isNil ifFalse: [ pubOutStream close. pubOutStream := nil].
	]!

generateNMgr
	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	aTemplateFileName := self templateFileNameForNMgr.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self nmgrOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 

			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self nmgrOutStream nextPutAll: anExpansion]]
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateNMgrBMgrConfigs

	self generateNMgrConfig.
	self generateBmgrConfigs!

generateNMgrBmgrStaticDeclarations

	self generateNMgrStaticDeclaration.
	self generateBmgrStaticDeclarations!

generateNMgrConfig
	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	anStream := self wholeTreeConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab; nextPutAll: 'MMNodeBranchesConfigIfc a', 
			self upperInitialName, 'NBC  = new MMNodeBranchesConfig( a', 
				self upperInitialName,  'NMgr);'; cr.

		self allRelationships do: [:aRelationship | aRelationship generateBranchConfigOverrideForType: self].

		anStream tab; tab; nextPutAll: 'gConfig.addNodeBranchesConfig( a', 
			self upperInitialName, 'NBC);';cr ; cr.

	"    MMNodeBranchesConfigIfc      aProjectNBC = new MMNodeBranchesConfig( aProjectNMgr);
	aProjectNBC.addBranchConfigOverride( new MMBranchConfigOverride( aProject_packagesBMgr, null));
	gConfig.addNodeBranchesConfig( aProjectNBC);
"

	]!

generateNMgrStaticDeclaration

	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].



	anStream := self wholeTreeConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; nextPutAll: 'public static ', (self expand: 'FullPrefixedNMgrName'), 
			' a', self upperInitialName, 'NMgr  = new ', (self expand: 'FullPrefixedNMgrName'),  '();'; cr; cr.
	]!

generatePortsCreation

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generatePortCreationForType: self]!

generatePortsSynchChangeDetection

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generatePortSynchChangeDetectionForType: self]!

generatePrimitiveProjectNodeDeclarations: theStartIndex

	self isPrimitive 	ifFalse: [ ^self ].

	^theStartIndex!

generatePrimitiveProjectNodeParameters

	self isPrimitive 	ifFalse: [ ^self ].!

generatePriv


	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'priv'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self privOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'AttributesPrivDeclarations'
				ifTrue: [ self generatePrivAttributeDeclarations] ifFalse: [
			aKey = 'RelationshipsPrivDeclarations'
				ifTrue: [ self generatePrivRelationshipDeclarations]
				ifFalse: [
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self privOutStream nextPutAll: anExpansion]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generatePrivAttributeDeclarations

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributesToGenerate do: [:aAttribute | aAttribute generatePrivDeclarationForType: self]!

generatePrivRelationshipDeclarations

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generatePrivDeclarationForType: self]!

generateProjectNodeDeclarations: theStartIndex
	| anStream anStartIndex |
	
	self skip ifTrue: [ ^theStartIndex].

	self isEnumeration 	ifTrue: [ ^self  generateEnumerationProjectNodeDeclarations: theStartIndex].
	self isPrimitive 		ifTrue: [ ^self  generatePrimitiveProjectNodeDeclarations: theStartIndex].

	anStartIndex := theStartIndex.

	self baseOutPrjNdx: anStartIndex.
	self implOutPrjNdx: anStartIndex + 1.
	self ifcOutPrjNdx: anStartIndex + 2.
	self trxOutPrjNdx: anStartIndex + 3.
	self privOutPrjNdx: anStartIndex + 4.

	anStartIndex := anStartIndex + 5.

	anStream := self prjOutStream.
	anStream isNil ifTrue: [ ^anStartIndex].

	anStream nextPutAll: '#' , self baseOutPrjNdx printString, '=',  self projectNodeBaseDeclarationName; cr.
	anStream nextPutAll: '#' , self implOutPrjNdx printString, '=',  self projectNodeImplDeclarationName; cr.
	anStream nextPutAll: '#' , self ifcOutPrjNdx printString, '=',  self projectNodeIfcDeclarationName; cr.
	anStream nextPutAll: '#' , self trxOutPrjNdx printString, '=',  self projectNodeTrxDeclarationName; cr.
	anStream nextPutAll: '#' , self privOutPrjNdx printString, '=',  self projectNodePrivDeclarationName; cr.

	^anStartIndex!

generateProjectNodeParameters

	| anStream |

	self skip ifTrue: [ ^self].

	self isEnumeration 	ifTrue: [ ^self  generateEnumerationProjectNodeParameters].
	self isPrimitive 		ifTrue: [ ^self  generatePrimitiveProjectNodeParameters].


	anStream := self prjOutStream.
	anStream isNil ifFalse: [

		anStream nextPutAll: 'sys[' , self baseOutPrjNdx printString, '].Parent=', 
			(self module isNil ifTrue: [ '0'] ifFalse: [ self module baseOutPrjNdx printString]); cr.
		anStream nextPutAll: 'sys[' , self baseOutPrjNdx printString, '].RunParameters='; cr.
		anStream nextPutAll: 'sys[' , self baseOutPrjNdx printString, '].JavaVmParameters='; cr.

		anStream nextPutAll: 'sys[' , self implOutPrjNdx printString, '].Parent=', 
			(self module isNil ifTrue: [ '0'] ifFalse: [ self module implOutPrjNdx printString]); cr.
		anStream nextPutAll: 'sys[' , self implOutPrjNdx printString, '].RunParameters='; cr.
		anStream nextPutAll: 'sys[' , self implOutPrjNdx printString, '].JavaVmParameters='; cr.

		anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].Parent=', 
			(self module isNil ifTrue: [ '0'] ifFalse: [ self module ifcOutPrjNdx printString]); cr.
		anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].RunParameters='; cr.
		anStream nextPutAll: 'sys[' , self ifcOutPrjNdx printString, '].JavaVmParameters='; cr.

		anStream nextPutAll: 'sys[' , self trxOutPrjNdx printString, '].Parent=', 
			(self module isNil ifTrue: [ '0'] ifFalse: [ self module trxOutPrjNdx printString]); cr.
		anStream nextPutAll: 'sys[' , self trxOutPrjNdx printString, '].RunParameters='; cr.
		anStream nextPutAll: 'sys[' , self trxOutPrjNdx printString, '].JavaVmParameters='; cr.

		anStream nextPutAll: 'sys[' , self privOutPrjNdx printString, '].Parent=', 
			(self module isNil ifTrue: [ '0'] ifFalse: [ self module privOutPrjNdx printString]); cr.
		anStream nextPutAll: 'sys[' , self privOutPrjNdx printString, '].RunParameters='; cr.	
		anStream nextPutAll: 'sys[' , self privOutPrjNdx printString, '].JavaVmParameters='; cr.	
	]!

generatePropertiesInitialization

	self isPrimitive ifTrue: [ ^self ].

	self attributesToGenerate do: [:anAttribute | anAttribute generatePropertyInitializationForType: self]!

generatePropertiesSynchChangeDetection

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributesToGenerate do: [:anAttribute | anAttribute generatePropertySynchChangeDetectionForType: self]!

generatePub


	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'pub'.
	aTemplateFileName isNil ifTrue: [ ^self].
[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self pubOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self pubOutStream nextPutAll: anExpansion]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateRelationshipsDeletes

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generateRelationshipDeleteForType: self]!

generateRelationshipsSeparateActions

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateSeparateActionsForType: self]!

generateRootNodeConfig
	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self ].
	self isPrimitive 	ifTrue: [ ^self ].
	self isAbstract 	ifTrue: [ ^self ].


	anStream := self wholeTreeConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab; nextPutAll: 'MMClassRootNodeConfigIfc     aRoot', self upperInitialName, 
			'RNC = new MMClassRootNodeConfig( theCtxt.getMMFactory("',
			self typePrefix, '").getClassForType( theCtxt, "', 
			self upperInitialName, '", "', self allContainerPackageNames, '"), a', self upperInitialName, 'NMgr, null);'; cr.
		anStream tab; tab; nextPutAll: 'gConfig.addClassRootNodeConfig( aRoot', self upperInitialName, 'RNC);';cr; cr.
	]!

generateTrx

	| aTemplateFileName aTemplateStream aChunk aText aKey anExpansion |

	aTemplateFileName := self templateFileNameFor: 'trx'.
	aTemplateFileName isNil ifTrue: [ ^self].

[
	aTemplateStream := aTemplateFileName asFilename readStream.

	[ 
		aChunk := self nextChunkFromTemplate: aTemplateStream.
		aChunk isNil
	]
		whileFalse:
	[
		aText := aChunk first.
		aKey := aChunk at: 2.
		aText isNil ifFalse: [ 
			self trxOutStream nextPutAll: aText].
		aKey isNil ifFalse: [ 
			aKey = 'AttributesTrxDeclarations'
				ifTrue: [ self generateTrxAttributeDeclarations] ifFalse: [
			aKey = 'RelationshipsTrxDeclarations'
				ifTrue: [ self generateTrxRelationshipDeclarations]
				ifFalse: [
			
			anExpansion := self expand: aKey.
			anExpansion isNil ifFalse: [ 
				self trxOutStream nextPutAll: anExpansion]]]].
	]
]
	valueNowOrOnUnwindDo:
[
	aTemplateStream isNil ifFalse: [ aTemplateStream close].
]!

generateTrxAttributeDeclarations

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributesToGenerate do: [:aAttribute | aAttribute generateTrxDeclarationForType: self]!

generateTrxRelationshipDeclarations

	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationshipsToGenerate do: [:aRelationship | aRelationship generateTrxDeclarationForType: self]! !

!CODEType publicMethodsFor: 'generate-streams'!

baseOutStream	
	baseOutStream isNil ifTrue: [ self openBaseOutStream].
	^baseOutStream!

chooserOutStream	
	chooserOutStream isNil ifTrue: [ self openChooserOutStream].
	^chooserOutStream!

custOutStream	
	custOutStream isNil ifTrue: [ self openCustOutStream].
	^custOutStream!

deleteActionOutStream	
	deleteActionOutStream isNil ifTrue: [ self openDeleteActionOutStream].
	^deleteActionOutStream!

ifcOutStream	
	ifcOutStream isNil ifTrue: [ self openIfcOutStream].
	^ifcOutStream!

implOutStream	
	implOutStream isNil ifTrue: [ self openImplOutStream].
	^implOutStream!

initBaseOutFileName
	baseOutFileName := (self expand: 'PrefixedClassName'), 'Base.java'.!

initChooserOutFileName
	chooserOutFileName := (self expand: 'PrefixedClassName'), 'ChooserTreeConfigFactory.java'.!

initCustOutFileName
	custOutFileName := (self expand: 'PrefixedClassName'), 'Cust.java'.!

initDeleteActionOutFileName
	deleteActionOutFileName :=  (self expand: 'TypePrefix'),  (self expand: 'TypeName') , '_delete.java'.!

initIfcOutFileName
	ifcOutFileName := (self expand: 'PrefixedClassName'), 'Ifc.java'.!

initImplOutFileName
	implOutFileName := (self expand: 'PrefixedClassName'), 'Impl.java'.!

initMetaOutFileName
	metaOutFileName := (self expand: 'PrefixedClassName'), 'Meta.java'.!

initNmgrOutFileName
	nmgrOutFileName := (self expand: 'PrefixedClassName'), 'NMgr.java'.!

initPrivOutFileName
	privOutFileName := (self expand: 'PrefixedClassName'), 'Priv.java'.!

initPubOutFileName
	pubOutFileName := (self expand: 'PrefixedClassName'), 'Pub.java'.!

initTrxOutFileName
	trxOutFileName := (self expand: 'PrefixedClassName'), 'Trx.java'.!

metamodelOutStream 

	^self model isNil ifTrue: [ nil] ifFalse: [	self model  metamodelOutStream]!

metaOutStream	
	metaOutStream isNil ifTrue: [ self openMetaOutStream].
	^metaOutStream!

nmgrOutStream	
	nmgrOutStream isNil ifTrue: [ self openNmgrOutStream].
	^nmgrOutStream!

openBaseOutStream
	| aFileName aPath |

	aFileName := self baseOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'base'),
		(String with: Filename separator), aFileName.
	baseOutStream := aPath asFilename writeStream.!

openChooserOutStream
	| aFileName aPath |

	aFileName := self chooserOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'customconfigs'),
		(String with: Filename separator), aFileName.
	chooserOutStream := aPath asFilename writeStream.!

openCustOutStream
	| aFileName aPath |

	aFileName := self custOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'cust'),
		 (String with: Filename separator), aFileName.
	custOutStream := aPath asFilename writeStream.!

openDeleteActionOutStream
	| aFileName aPath |

	aFileName := self deleteActionOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'custommgrs'),
		(String with: Filename separator), aFileName.
	deleteActionOutStream := aPath asFilename writeStream.!

openIfcOutStream
	| aFileName aPath |

	aFileName := self ifcOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath :=(self module outputDirectoryWithPackageAndFolder: 'ifc'),
		 (String with: Filename separator), aFileName.
	ifcOutStream := aPath asFilename writeStream.!

openImplOutStream
	| aFileName aPath |

	aFileName := self implOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'impl'),
		 (String with: Filename separator), aFileName.
	implOutStream := aPath asFilename writeStream.!

openMetaOutStream
	| aFileName aPath |

	aFileName := self metaOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'meta'),
		(String with: Filename separator), aFileName.
	metaOutStream := aPath asFilename writeStream.!

openNmgrOutStream
	| aFileName aPath |

	aFileName := self nmgrOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'custommgrs'),
		(String with: Filename separator), aFileName.
	nmgrOutStream := aPath asFilename writeStream.!

openPrivOutStream
	| aFileName aPath |

	aFileName := self privOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'priv'),
		 (String with: Filename separator), aFileName.
	privOutStream := aPath asFilename writeStream.!

openPubOutStream
	| aFileName aPath |

	aFileName := self pubOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath := (self module outputDirectoryWithPackageAndFolder: 'pub'),
		 (String with: Filename separator), aFileName.
	pubOutStream := aPath asFilename writeStream.!

openTrxOutStream
	| aFileName aPath |

	aFileName := self trxOutFileName.
	aFileName isNil ifTrue: [ ^nil].
	aPath :=(self module outputDirectoryWithPackageAndFolder: 'trx'),
		 (String with: Filename separator), aFileName.
	trxOutStream := aPath asFilename writeStream.!

privOutStream	
	privOutStream isNil ifTrue: [ self openPrivOutStream].
	^privOutStream!

prjOutStream
	^self model isNil ifTrue: [ nil] ifFalse: [ self model prjOutStream]!

pubOutStream	
	pubOutStream isNil ifTrue: [ self openPubOutStream].
	^pubOutStream!

trxOutStream	
	trxOutStream isNil ifTrue: [ self openTrxOutStream].
	^trxOutStream!

wholeTraversalConfigOutStream
	^self model isNil ifTrue: [ nil] ifFalse: [ self model wholeTraversalConfigOutStream]!

wholeTreeConfigOutStream
	^self model isNil ifTrue: [ nil] ifFalse: [ self model wholeTreeConfigOutStream]! !

!CODEType publicMethodsFor: 'generate-support'!

asAttributeTypeFullyQualifiedName
	
	| aName aModel aNativeName |
	self isEnumeration ifTrue: [ ^'java.lang.String'].

	aName := self name.
	aModel := self model.
	aModel isNil ifFalse: [ 
		aNativeName := aModel nativeAttributeName: aName.
		aNativeName isNil ifFalse: [^aNativeName].
	].

	self isPrimitive ifTrue: [ 
		Transcript show: 'WARN : Please define native mapping for ', aName; cr. 
		self error: 'WARN : Please define native mapping for ', aName; cr].

	
	aName := self expand:  'FullIfcPrefixedClassName'.
	^aName!

asOperationTypeFullyQualifiedName
	
	| aName aModel aNativeName |
	self isEnumeration ifTrue: [ ^'java.lang.String'].

	aName := self name.
	aModel := self model.
	aModel isNil ifFalse: [ 
		aNativeName := aModel nativeOperationName: aName.
		aNativeName isNil ifFalse: [^aNativeName].
	].

	self isPrimitive ifTrue: [ 
		Transcript show: 'WARN : Please define native mapping for ', aName; cr. 
		self error: 'WARN : Please define native mapping for ', aName; cr].

	
	aName := self expand:  'FullIfcPrefixedClassName'.
	^aName!

expand: theKey
	expansionInitialized == true ifFalse: [ self initializeExpansions].

	^self expansions at: theKey ifAbsent: [ self model expand: theKey]!

initBaseOutPrjNdx
	baseOutPrjNdx := 0!

initializeExpansions
	
	| aPrefixedSuperClassName aStream aString aFullPrivPrefixedClassName aFullIfcPrefixedClassName |
	self expansion: 'PackageName' value: self model package.
	self expansion: 'FrameworkPackageName' value: self model frameworkPackage.
	self expansion: 'BrowserFrameworkPackageName' value: self model browserFrameworkPackage.
	self expansion: 'FullPackageName' value: self module fullPackageName.
	self expansion: 'TypeName' value: self upperInitialName.

	self expansion: 'FullPanelsFactoryPrefixedClassName' value: 
		(self model expand: 'FullPackageName'), '.browser.custommgrs.' , self model typePrefix, 'MMElement_PFac'.
	self expansion: 'FullPrefixedWholeTreeConfigFactory' value: (self model expand: 'FullPrefixedWholeTreeConfigFactory').
	self expansion: 'FullPrefixedChooserTreeConfigFactory' value: 
		(self module fullPackageName , '.customconfigs.', 
			self model typePrefix , self upperInitialName, 'ChooserTreeConfigFactory').
	self expansion: 'TypePrefix' value: self model typePrefix.


	self expansion: 'AllTypePackageNames' value: self allContainerPackageNames.



	self expansion: 'FullPrefixedNMgrName' value: 
		(self module fullPackageName , '.custommgrs.', self model typePrefix , self upperInitialName, 'NMgr').

	aPrefixedSuperClassName :=  self superTypes isEmpty
		ifTrue: [ self model expand: 'PrefixedRootClassName']
		ifFalse: [ self superTypes first expand: 'FullPrefixedClassName'].

	self expansion: 'PrefixedSuperClassName' value: aPrefixedSuperClassName.
	self expansion: 'PrefixedClassName' value: self model typePrefix , self upperInitialName.
	self expansion: 'FullBasePrefixedClassName' value: ( self module fullPackageName), '.base.', (self model typePrefix , self upperInitialName) , 'Base'.
	aFullIfcPrefixedClassName :=  ( self module fullPackageName), '.ifc.', (self model typePrefix , self upperInitialName),'Ifc'.
	self expansion: 'FullIfcPrefixedClassName' value: aFullIfcPrefixedClassName.

	aFullPrivPrefixedClassName := self module fullPackageName, '.priv.', (self model typePrefix , self upperInitialName) , 'Priv'.	
self expansion: 'FullPrivPrefixedClassName' value: aFullPrivPrefixedClassName.
	self expansion: 'FullTrxPrefixedClassName' value: ( self module fullPackageName), '.trx.', (self model typePrefix , self upperInitialName) , 'Trx'.
	self expansion: 'FullImplPrefixedClassName' value: ( self module fullPackageName), '.impl.', (self model typePrefix , self upperInitialName) , 'Impl'.
	self expansion: 'FullCustPrefixedClassName' value: ( self module fullPackageName), '.cust.', (self model typePrefix , self upperInitialName) , 'Cust'.
	self expansion: 'FullPubPrefixedClassName' value: ( self module fullPackageName), '.pub.', (self model typePrefix , self upperInitialName) , 'Pub'.
	self expansion: 'FullMetaPrefixedClassName' value: ( self module fullPackageName), '.meta.', (self model typePrefix , self upperInitialName) , 'Meta'.


 	self expansion: 'BaseExtendsClause' value: (
		self superTypes isEmpty
			ifTrue: [ ' extends ' , self model defaultSuperTypeFullImplClassName]
			ifFalse: [' extends ' ,  (self superTypesAsArray first expand: 'FullImplPrefixedClassName')]).


 	self expansion: 'IfcExtendsClause' value: (
		self superTypes isEmpty 
			ifTrue: [ ' extends ' , self model defaultSuperTypeFullIfcClassName] 
			ifFalse: [
				aStream := WriteStream on: (String new: 64).
				self superTypes	do: [:aType | 
					aStream nextPutAll: '    ', (aType expand: 'FullIfcPrefixedClassName').	
					aType == self superTypes last ifFalse: [ aStream nextPutAll: ','; cr]].
				aString := aStream contents.	
				'  extends ' ,  aString]).

 	self expansion: 'TrxExtendsClause' value: (
		self superTypes isEmpty 
			ifTrue: [ ' extends ' , self model defaultSuperTypeFullTrxClassName , ', '] 
			ifFalse: [ ' extends ' ,  (self superTypes first expand: 'FullTrxPrefixedClassName') , ', ' , ( 
		self superTypesSize > 1 
			ifFalse: [ '']
			ifTrue: [
				aStream := WriteStream on: (String new: 64).
				aStream cr.
				(self superTypes	copyFrom: 2 to: self superTypesSize) do: [:aType | 
					aStream nextPutAll: '    ', (aType expand: 'FullTrxPrefixedClassName').	
					aStream nextPutAll: ','; cr].
				aStream contents])]).

 	self expansion: 'PrivExtendsClause' value: (
		self superTypes isEmpty ifTrue: [ ' extends ' , self model defaultSuperTypeFullPrivClassName , ', '] ifFalse: [ ' extends ' ,  (self superTypes first expand: 'FullPrivPrefixedClassName') , ', ', ( 
		self superTypesSize > 1 
			ifFalse: [ '']
			ifTrue: [
				aStream := WriteStream on: (String new: 64).
				aStream cr.
				(self superTypes	copyFrom: 2 to: self superTypesSize) do: [:aType | 
					aStream nextPutAll: '    ', (aType expand: 'FullPrivPrefixedClassName').	
					aStream nextPutAll: ','; cr].
				aStream contents])]).

 	self expansion: 'PubExtendsClause' value: (
		self superTypes isEmpty ifTrue: [ ' extends ' , self model defaultSuperTypeFullPubClassName , ', '] ifFalse: [ ' extends ' ,  (self superTypes first expand: 'FullPubPrefixedClassName') , ', ', ( 
		self superTypesSize > 1 
			ifFalse: [ '']
			ifTrue: [
				aStream := WriteStream on: (String new: 64).
				aStream cr.
				(self superTypes	copyFrom: 2 to: self superTypesSize) do: [:aType | 
					aStream nextPutAll: '    ', (aType expand: 'FullPubPrefixedClassName').	
					aStream nextPutAll: ','; cr].
				aStream contents])]).

 	self expansion: 'BaseImplementsClause' value: '  implements ',
		(self isEnumeration ifFalse: [  self isGenerationStyleDynamicReduced ifTrue: [aFullIfcPrefixedClassName] ifFalse: [ aFullPrivPrefixedClassName]] ifTrue: [ aFullIfcPrefixedClassName ]).


 

 	self expansion: 'SerialVersionUIDBase' value: ( self serialVersionUIDPrefix , self serialVersionTypeIndex, '0003').

 	self expansion: 'SerialVersionUIDImpl' value: ( self serialVersionUIDPrefix , self serialVersionTypeIndex, '0007').

 	self expansion: 'SerialVersionUIDCust' value: ( self serialVersionUIDPrefix , self serialVersionTypeIndex, '0009').

	self expansion: 'FullPrefixedM3ModelName' value: (self model expand: 'FullPrefixedM3ModelName').

	self expansion: 'MetaModelFullIfcPrefixedClassName' value: self metaModelFullIfcPrefixedClassName.
	self expansion: 'MetaModelFullImplPrefixedClassName' value: self metaModelFullImplPrefixedClassName.
	self expansion: 'MetaModuleFullIfcPrefixedClassName' value: self metaModuleFullIfcPrefixedClassName.
	self expansion: 'MetaModuleFullImplPrefixedClassName' value: self metaModuleFullImplPrefixedClassName.
	self expansion: 'MetaTypeFullIfcPrefixedClassName' value: self metaTypeFullIfcPrefixedClassName.
	self expansion: 'MetaTypeFullPubPrefixedClassName' value: self metaTypeFullPubPrefixedClassName.
	self expansion: 'MetaTypeFullImplPrefixedClassName' value: self metaTypeFullImplPrefixedClassName.
	self expansion: 'MetaAttributeFullIfcPrefixedClassName' value: self metaAttributeFullIfcPrefixedClassName.
	self expansion: 'MetaAttributeFullImplPrefixedClassName' value: self metaAttributeFullImplPrefixedClassName.
	self expansion: 'MetaRelationshipFullIfcPrefixedClassName' value: self metaRelationshipFullIfcPrefixedClassName.
	self expansion: 'MetaRelationshipFullImplPrefixedClassName' value: self metaRelationshipFullImplPrefixedClassName.
	self expansion: 'MMElementWithM3FullIfcPrefixedClassName' value: self mmElementWithM3FullIfcPrefixedClassName.
	self expansion: 'M3ModelName' value: self model typePrefix.

	expansionInitialized := true!

initIfcOutPrjNdx
	ifcOutPrjNdx :=  0!

initImplOutPrjNdx
	implOutPrjNdx :=  0!

initPrivOutPrjNdx
	privOutPrjNdx :=  0!

initTrxOutPrjNdx
	trxOutPrjNdx := 0!

isGenerationStyleDynamic
	^self model isGenerationStyleDynamic!

isGenerationStyleDynamicReduced
	^self model isGenerationStyleDynamicReduced!

metaAttributeFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaAttributeFullIfcPrefixedClassName!

metaAttributeFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaAttributeFullImplPrefixedClassName!

metaHolderClassName 

	^self expand: 'FullMetaPrefixedClassName'!

metaModelFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModelFullIfcPrefixedClassName!

metaModelFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModelFullImplPrefixedClassName!

metaModuleFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModuleFullIfcPrefixedClassName!

metaModuleFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaModuleFullImplPrefixedClassName!

metaRelationshipFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaRelationshipFullIfcPrefixedClassName!

metaRelationshipFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaRelationshipFullImplPrefixedClassName!

metaTypeFullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaTypeFullIfcPrefixedClassName!

metaTypeFullImplPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaTypeFullImplPrefixedClassName!

metaTypeFullPubPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel metaTypeFullPubPrefixedClassName!

mmElementWithM3FullIfcPrefixedClassName
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].
	^aModel mmElementWithM3FullIfcPrefixedClassName!

projectNodeBaseDeclarationName
	| aModel aProjectToOutputDirectoryPath aFullPrefixedClassName aFullPrefixedPathName |
	aModel := self model.
	aProjectToOutputDirectoryPath := aModel projectToOutputDirectoryPath.
	aFullPrefixedClassName := self expand: 'FullBasePrefixedClassName'.
	aFullPrefixedPathName := (aFullPrefixedClassName copyReplaceAll: '.' with: (String with: Filename separator)),
		'.java'.
	^'.', (String with: Filename separator), aProjectToOutputDirectoryPath , (String with: Filename separator),
		aFullPrefixedPathName!

projectNodeIfcDeclarationName
	| aModel aProjectToOutputDirectoryPath aFullPrefixedClassName aFullPrefixedPathName |
	aModel := self model.
	aProjectToOutputDirectoryPath := aModel projectToOutputDirectoryPath.
	aFullPrefixedClassName := self expand: 'FullIfcPrefixedClassName'.
	aFullPrefixedPathName := (aFullPrefixedClassName copyReplaceAll: '.' with: (String with: Filename separator)),
		'.java'.
	^'.', (String with: Filename separator), aProjectToOutputDirectoryPath , (String with: Filename separator),
		aFullPrefixedPathName!

projectNodeImplDeclarationName
	| aModel aProjectToOutputDirectoryPath aFullPrefixedClassName aFullPrefixedPathName |
	aModel := self model.
	aProjectToOutputDirectoryPath := aModel projectToOutputDirectoryPath.
	aFullPrefixedClassName := self expand: 'FullImplPrefixedClassName'.
	aFullPrefixedPathName := (aFullPrefixedClassName copyReplaceAll: '.' with: (String with: Filename separator)),
		'.java'.
	^'.', (String with: Filename separator), aProjectToOutputDirectoryPath , (String with: Filename separator),
		aFullPrefixedPathName!

projectNodePrivDeclarationName
	| aModel aProjectToOutputDirectoryPath aFullPrefixedClassName aFullPrefixedPathName |
	aModel := self model.
	aProjectToOutputDirectoryPath := aModel projectToOutputDirectoryPath.
	aFullPrefixedClassName := self expand: 'FullPrivPrefixedClassName'.
	aFullPrefixedPathName := (aFullPrefixedClassName copyReplaceAll: '.' with: (String with: Filename separator)),
		'.java'.
	^'.', (String with: Filename separator), aProjectToOutputDirectoryPath , (String with: Filename separator),
		aFullPrefixedPathName!

projectNodeTrxDeclarationName
	| aModel aProjectToOutputDirectoryPath aFullPrefixedClassName aFullPrefixedPathName |
	aModel := self model.
	aProjectToOutputDirectoryPath := aModel projectToOutputDirectoryPath.
	aFullPrefixedClassName := self expand: 'FullTrxPrefixedClassName'.
	aFullPrefixedPathName := (aFullPrefixedClassName copyReplaceAll: '.' with: (String with: Filename separator)),
		'.java'.
	^'.', (String with: Filename separator), aProjectToOutputDirectoryPath , (String with: Filename separator),
		aFullPrefixedPathName!

serialVersionTypeIndex
	| aString  aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^'0000'].
	aString := '0000', (aModel typeIndex: self) printString.	
	aString isNil ifTrue: [ ^'0000'].
	aString isEmpty ifTrue: [ ^'0000'].
	aString := aString copyFrom: aString size - 4 + 1 to: aString size.
	^aString!

serialVersionUIDPrefix
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^0].
	^aModel serialVersionUIDPrefix!

templateFileNameFor: theAspect
	
	| aTemplateDirectory aFileName |
	aTemplateDirectory := self model templatesDirectory.
	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'type', (String with: Filename separator) ,
		theAspect, (String with: Filename separator) ,
		( ((self toUpperInitial: theAspect) = 'Base' and: [ self isEnumeration]) ifTrue: [ 'Enumeration'] ifFalse: [ '']), 
		 'Type', (self toUpperInitial: theAspect), '.java'.
	^aFileName!

templateFileNameForChooser
	
	| aTemplateDirectory aFileName |
	aTemplateDirectory := self model templatesDirectory.
	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'type', (String with: Filename separator) ,
		'customconfigs', (String with: Filename separator) ,
		 'ChooserTreeConfigFactory.java'.
	^aFileName!

templateFileNameForDeleteAction
	
	| aTemplateDirectory aFileName |
	aTemplateDirectory := self model templatesDirectory.
	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'type', (String with: Filename separator) ,
		'custommgrs', (String with: Filename separator) ,
		 'DeleteAction.java'.
	^aFileName!

templateFileNameForNMgr
	
	| aTemplateDirectory aFileName |
	aTemplateDirectory := self model templatesDirectory.
	aFileName := aTemplateDirectory , (String with: Filename separator), 
		'type', (String with: Filename separator) ,
		'custommgrs', (String with: Filename separator) ,
		 'NMgr.java'.
	^aFileName!

typeIndex
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^0].
	^aModel typeIndex: self! !

!CODEType publicMethodsFor: 'generate-traversals'!

generateTraversalAttributeCfgsStaticDeclarations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributes do: [:anAttribute | anAttribute generateTraversalAttributeCfgsStaticDeclarations]!

generateTraversalAttributeCfgsStaticInstantiations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributes do: [:anAttribute | anAttribute generateTraversalAttributeCfgsStaticInstantiations]!

generateTraversalBranchCfgsStaticDeclarations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateTraversalBranchCfgsStaticDeclarations]!

generateTraversalBranchCfgsStaticInitializations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateTraversalBranchCfgsStaticInitializations]!

generateTraversalBranchCfgsStaticInstantiations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateTraversalBranchCfgsStaticInstantiations]!

generateTraversalBranchMgrsStaticDeclarations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateTraversalBranchMgrsStaticDeclarations]!

generateTraversalBranchMgrsStaticInstantiations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateTraversalBranchMgrsStaticInstantiations]!

generateTraversalFieldMgrsStaticDeclarations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributes do: [:anAttribute | anAttribute generateTraversalFieldMgrsStaticDeclarations]!

generateTraversalFieldMgrsStaticInstantiations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self attributes do: [:anAttribute | anAttribute generateTraversalFieldMgrsStaticInstantiations]!

generateTraversalNodeCfgsStaticDeclarations
	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; nextPutAll: 'public M3NodeConfigIfc a', self upperInitialName, 'NC, ';
			nextPutAll: 'a', self upperInitialName, 'NCTerm;'; cr.
	]

"public static M3NodeConfigIfc     aEnumeratedValueNC, aEnumeratedValueNCTerm;"!

generateTraversalNodeCfgsStaticInitializations
	| anStream someRels |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	someRels := self allRelationships.
	someRels do: [:aRelationship | 
		aRelationship  generateTraversalNodeCfgsStaticInitializationsForType: self].

	someRels isEmpty ifFalse: [
		anStream := self wholeTraversalConfigOutStream.
		anStream isNil ifFalse: [ anStream  cr]]!

generateTraversalNodeCfgsStaticInstantiations
	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 
			'NC =  (M3NodeConfigIfc)  theCtxt.getMMFactory("M3").createMMElementOfType( theCtxt, "NodeConfig", "traversal",',
			'"', self upperInitialName, 'NC");';cr.
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 'NC.setMetaType( theCtxt, ((com.yourml.repostory.m3model.core.pub.M3ModelPub) theM3Model).getM3TypeInPackagesNamed( theCtxt, "', self upperInitialName ,'", "', self allContainerPackageNames ,'"));'; cr.

		anStream tab; tab;  nextPutAll: 'addNodeConfigs( theCtxt, a', self upperInitialName, 'NC);';cr. 
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 'RTNC.setNodeConfig( theCtxt, a', self upperInitialName, 'NC);'; cr; cr.

		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 
			'NCTerm =  (M3NodeConfigIfc)  theCtxt.getMMFactory("M3").createMMElementOfType( theCtxt, "NodeConfig", "traversal",',
			'"', self upperInitialName, 'NCTerm");';cr.
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 'NCTerm.setMetaType( theCtxt, ((com.yourml.repostory.m3model.core.pub.M3ModelPub) theM3Model).getM3TypeInPackagesNamed( theCtxt, "', self upperInitialName ,'", "', self allContainerPackageNames ,'"));'; cr.

		anStream tab; tab;  nextPutAll: 'addNodeConfigs( theCtxt, a', self upperInitialName, 'NCTerm);';cr. 
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 'NCTerm.setIsTerminal( theCtxt, true);';cr; cr. 
	]

"		aEnumeratedValueNC = theCtxt.getMMFactory('M3').createMMElementOfType( theCtxt, 'NodeConfig', 'traversal', 'EnumeratedValueNC');
	aEnumeratedValueNC.setMetaType( theCtxt, theCtxt.getMMFactory('Kit').getM3Type( theCtxt, 'EnumeratedValue', 'core.model.structural'));
	gConfig.addNodeConfigs( theCtxt, aEnumeratedValueNC);
	aEnumeratedValueRTNC.setNodeConfig( theCtxt,  aEnumeratedValueNC);
"!

generateTraversalNodeMgrsStaticDeclarations
	| anStream aM3NodeMgrIfcName |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	aM3NodeMgrIfcName := self model generatingReplicationTraversalConfig ifTrue: [ 'M3ReplicateNodeMgrIfc'] ifFalse: [ 'M3NodeMgrIfc'].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; nextPutAll: 'public ', aM3NodeMgrIfcName, ' a', self upperInitialName, 'NMgr;'; cr.
	]

"public static M3NodeMgrIfc     aEnumeratedValueNMgr;"!

generateTraversalNodeMgrsStaticInstantiations
	| anStream aMgrTypeName aMgrPackageNames aM3NodeMgrIfcName |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	aMgrTypeName := self model generatingReplicationTraversalConfig ifTrue: [ 'ReplicateNodeMgr'] ifFalse: [ 'NodeMgr'].
	aMgrPackageNames := self model generatingReplicationTraversalConfig ifTrue: [ 'replication'] ifFalse: [ 'traversal'].
	aM3NodeMgrIfcName := self model generatingReplicationTraversalConfig ifTrue: [ 'M3ReplicateNodeMgrIfc'] ifFalse: [ 'M3NodeMgrIfc'].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 
			'NMgr =   (', aM3NodeMgrIfcName, ') theCtxt.getMMFactory("M3").createMMElementOfType( theCtxt, "', aMgrTypeName, '", "', aMgrPackageNames, '",',
			'"', self upperInitialName, 'NMgr");';cr.
		anStream tab; tab;  nextPutAll: 'addNodeMgrs( theCtxt, a', self upperInitialName, 'NMgr);';cr. 
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 'NC.setMetaNodeMgr( theCtxt, a', 
			self upperInitialName,  'NMgr);'; cr; cr.
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 'NCTerm.setMetaNodeMgr( theCtxt, a', 
			self upperInitialName,  'NMgr);'; cr; cr.

	]

"		aEnumeratedValueNMgr = theCtxt.getMMFactory('M3').createMMElementOfType( theCtxt, 'NodeMgr', 'traversal', 'EnumeratedValueNMgr');
	aEnumeratedValueNC.setMetaNodeMgr( theCtxt,  aEnumeratedValueNMgr);
"!

generateTraversalRelatedTypeNodeCfgsStaticDeclarations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateTraversalRelatedTypeNodeCfgsStaticDeclarations]!

generateTraversalRelatedTypeNodeCfgsStaticDeclarationsForRelationship: theRelationship

	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].
	self isAbstract ifTrue: [ ^self ].

	anStream := theRelationship wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; nextPutAll: 'public M3RelatedTypeNodeConfigIfc a', (theRelationship expand: 'TypeAndRelationshipName'), '_', self upperInitialName , 'RelTNC;'; cr.
	]

"		public static M3RelatedTypeNodeConfigIfc  aAbstractEnumeratedType_enumeratedValues_EnumeratedValueRelTNC;
"!

generateTraversalRelatedTypeNodeCfgsStaticInitializationsForRelationship: theRelationship

	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].
	self isAbstract ifTrue: [ ^self ].


	anStream := theRelationship wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab;  nextPutAll: 'a', (theRelationship expand: 'TypeAndRelationshipName'),'BC.addTypeNodeConfigs( theCtxt, a', (theRelationship expand: 'TypeAndRelationshipName'), '_', self upperInitialName , 'RelTNC);'; cr.
	]

"		aAbstractEnumeratedType_enumeratedValuesBMgr.addRelatedTypeNodeConfigs( theCtxt, aAbstractEnumeratedType_enumeratedValues_EnumeratedValueRelTNC);
"!

generateTraversalRelatedTypeNodeCfgsStaticInstantiations

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].

	self relationships do: [:aRelationship | aRelationship generateTraversalRelatedTypeNodeCfgsStaticInstantiations]!

generateTraversalRelatedTypeNodeCfgsStaticInstantiationsForRelationship: theRelationship

	| anStream aPostfix |

	self skip ifTrue: [ ^self].
	self isEnumeration ifTrue: [ ^self ].
	self isPrimitive ifTrue: [ ^self ].
	self isAbstract ifTrue: [ ^self ].

	aPostfix := theRelationship isAggregation ifTrue: [ ''] ifFalse: [ 'Term'].

	anStream := theRelationship wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab;  nextPutAll: 'a', (theRelationship expand: 'TypeAndRelationshipName'), '_', self upperInitialName , 'RelTNC  =  (M3RelatedTypeNodeConfigIfc)  theCtxt.getMMFactory("M3").createMMElementOfType( theCtxt, "RelatedTypeNodeConfig", "traversal",',
			'"', (theRelationship expand: 'TypeAndRelationshipName'), '_', self upperInitialName , 'RelTNC");';cr.
		anStream tab; tab;  nextPutAll: 'a', (theRelationship expand: 'TypeAndRelationshipName'), '_', self upperInitialName , 'RelTNC.setMetaType( theCtxt, ((com.yourml.repostory.m3model.core.pub.M3ModelPub) theM3Model).getM3TypeInPackagesNamed( theCtxt, "', self upperInitialName ,'", "', self allContainerPackageNames ,'"));'; cr.

		anStream tab; tab;  nextPutAll: 'a', (theRelationship expand: 'TypeAndRelationshipName'), '_', self upperInitialName , 'RelTNC.setNodeConfig( theCtxt, a',self upperInitialName ,'NC', aPostfix, ');'; cr; cr.


	]

"		aAbstractEnumeratedType_enumeratedValues_EnumeratedValueRelTNC = theCtxt.getMMFactory('M3').createMMElementOfType( theCtxt, 'RelatedTypeNodeConfig', 'traversal', 'AbstractEnumeratedType_enumeratedValues_EnumeratedValueRelTNC');
	aAbstractEnumeratedType_enumeratedValues_EnumeratedValueRelTNC.setMetaType( theCtxt, theCtxt.getMMFactory('Kit').getM3Type( theCtxt, 'EnumeratedValue', 'core.model.structural'));
	aAbstractEnumeratedType_enumeratedValuesBMgr.addRelatedTypeNodeConfigs( theCtxt, aAbstractEnumeratedType_enumeratedValues_EnumeratedValueRelTNC);
	aAbstractEnumeratedType_enumeratedValues_EnumeratedValueRelTNC.setNodeConfig( theCtxt, aEnumeratedValueNC);
"!

generateTraversalRootTypeNodeCfgsStaticDeclarations
	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; nextPutAll: 'public M3RootTypeNodeConfigIfc a', self upperInitialName, 'RTNC;'; cr.
	]

"public static M3RootTypeNodeConfigIfc     aEnumeratedValueRTNC;"!

generateTraversalRootTypeNodeCfgsStaticInstantiations
	| anStream |

	self skip ifTrue: [ ^self].
	self isEnumeration 	ifTrue: [ ^self].
	self isPrimitive 		ifTrue: [ ^self].
	self isAbstract ifTrue: [ ^self].

	anStream := self wholeTraversalConfigOutStream.
	anStream isNil ifFalse: [
		anStream tab; tab; nextPutAll: 'a', self upperInitialName, 
			'RTNC = (M3RootTypeNodeConfigIfc) theCtxt.getMMFactory("M3").createMMElementOfType( theCtxt, "RootTypeNodeConfig", "traversal",',
			'"', self upperInitialName, 'RTNC");';cr.
		anStream tab; tab;  nextPutAll: 'a', self upperInitialName, 'RTNC.setMetaType( theCtxt, ((com.yourml.repostory.m3model.core.pub.M3ModelPub) theM3Model).getM3TypeInPackagesNamed( theCtxt, "', self upperInitialName ,'", "', self allContainerPackageNames ,'"));'; cr.
		anStream tab; tab;  nextPutAll: 'addRootTypeNodeConfigs( theCtxt, a', self upperInitialName, 'RTNC);'; cr; cr
	]


"		aEnumeratedValueRTNC = theCtxt.getMMFactory('M3').createMMElementOfType( theCtxt, 'RootTypeNodeConfig', 'traversal', 'EnumeratedValueRTNC');
		aAliasProjectionRTNC.setMetaType( theCtxt, ((com.yourml.repostory.m3model.core.pub.M3ModelPub) ((com.dosmil_e.m3.support.MMCtxtWithM3Ifc) theCtxt).getM3Model('Kit')).getM3TypeInPackagesNamed( theCtxt, 'AliasProjection', 'core.projection.define'));
	gConfig.addRootTypeNodeConfigs( theCtxt, aEnumeratedValueRTNC);
"! !

!CODEType publicMethodsFor: 'initialize-release'!

initIsAbstract
	isAbstract := false!

initIsEnumeration
	isEnumeration := false!

initIsExclussion
	isExclussion := false!

initIsHomeIDProvider
	isHomeIDProvider := false!

initIsHomeRooted
	isHomeRooted := false!

initIsJustUsed
	isJustUsed := true!

initIsPrimitive
	isPrimitive := false!

initIsUse
	isUse := false!

initIsVirtual
	isVirtual := false!

initSkip
	skip := false!

observersRelease
	observers isNil ifTrue: [ ^self].
	observers do: [:anObserver | anObserver release].
	observers := nil!

release
	self changed: #objectDisconnectedOfTree.

	self relatedWithRelease.
	self typeOfValuesRelease.
	self typeOfArgumentsRelease.
	self typeOfReturnsRelease.
	self superTypesRelease.
	self subTypesRelease.
	self relationshipsRelease.
	self attributesRelease.
	self operationsRelease.
	self moduleRelease.
	self observersRelease.
	self typesRelease.

	effectiveAttributesCache := nil.
	effectiveRelationshipsCache := nil.
	effectiveStructuralFeaturesCache := nil.
	effectiveOperationsCache := nil.
	effectiveFeaturesCache := nil.
	effectiveIDAttributeCache  := nil.
	effectiveNameAttributeCache := nil.

	memberInstanceTypesCache := nil.

	super release! !

!CODEType publicMethodsFor: 'integrity'!

integrityReportOn: theReport justFirst: theJustFirst

	| someTypes someAttributes someRelationships someOperations |

	theReport isNil  ifTrue: [ ^self].

	(theJustFirst == true and: [ theReport isEmpty not]) ifTrue:  [ ^self].

	someTypes := self types.
	someTypes do: [:aType | | aSuperType aReportEntry |
		aSuperType := aType module.
		self == aSuperType ifFalse: [ 
			aReportEntry := theReport at: aType ifAbsent: [ nil].
			aReportEntry ifTrue: [ 
				aReportEntry := OrderedCollection new: 2.
				theReport at: aType put: aReportEntry
			].
			aReportEntry add: #module.
			theJustFirst == true ifTrue: [ ^self].
		]
	].

	someAttributes:= self attributes.
	someAttributes do: [:aAttribute |
		aAttribute integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].

	someRelationships:= self relationships.
	someRelationships do: [:aRelationship |
		aRelationship integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].
	someOperations:= self operations.
	someOperations do: [:aOperation |
		aOperation integrityReportOn: theReport justFirst: theJustFirst.
		(theJustFirst and: [ theReport isEmpty not]) ifTrue:  [ ^self].
	].! !

!CODEType publicMethodsFor: 'parse'!

attributeFromLineStream: theLineStream andStream: theStream
	
	| anExistingAttribute aNewAttribute aAttributeName aValueType |

	theLineStream isNil ifTrue: [ ^self].
	theLineStream atEnd ifTrue: [ ^self].
	
	aValueType := self nextTypeTokenFrom: theLineStream.
	aValueType isEmpty ifTrue: [ ^self].

	theLineStream atEnd ifTrue: [ ^self].
	aAttributeName := self nextTokenFrom: theLineStream.
	aAttributeName isEmpty ifTrue: [ ^self].
	
	anExistingAttribute := self attributeNamed: aAttributeName.
	anExistingAttribute isNil
		ifFalse: [ anExistingAttribute fromLineStream: theLineStream andStream: theStream valueType: aValueType]
		ifTrue: [  
self logTranscript ifTrue: [ Transcript show: (String with: Character tab); show: ' + A '; show: aAttributeName; cr].

			aNewAttribute := CODEAttribute new.
			aNewAttribute name: aAttributeName.
			self attributesAdd: aNewAttribute.
			aNewAttribute fromLineStream: theLineStream andStream: theStream valueType: aValueType
		]!

featuresFromLine: theLine andStream: theStream
	
	| aStream  |
	theLine isNil ifTrue: [ ^self].
	theLine isEmpty ifTrue: [ ^self].
	(theLine first == $/ or: [ theLine first == $#]) ifTrue: [ ^self].
self logTranscript ifTrue: [ Transcript show: (String with: Character tab); show: ' features ';  cr].

	aStream := ReadStream on: theLine.
	[ aStream atEnd] whileFalse: [ | aWord  |
		aWord := aStream upTo: Character space.
		aWord isEmpty ifFalse: [ 
			aWord = '}' ifTrue: [ ^self].
			aWord = 'attribute' ifTrue: [  self attributeFromLineStream: aStream andStream: theStream] ifFalse: [ 
			aWord = 'relationship' ifTrue: [  self relationshipFromLineStream: aStream andStream: theStream] ifFalse: [ 
			]]			
		]
	]!

featuresFromStream: theStream

	theStream isNil ifTrue: [ ^nil].
	theStream atEnd ifTrue: [ ^nil].
	self model isNil ifTrue: [ ^nil].

	[ theStream atEnd] whileFalse: [ |  aLine aTrimmedLine |
		aLine := theStream upTo: Character cr.
		aTrimmedLine := aLine trimSeparators.
		aTrimmedLine isEmpty ifFalse: [ 
			aTrimmedLine first = $} ifTrue: [ ^self].
			self featuresFromLine: aTrimmedLine andStream: theStream	
		]	
	]!

findTypeNamed: theTypeName
	
	| anExistingType anSpacedTypeName someNames |
	theTypeName isNil ifTrue: [ ^self].
	theTypeName isEmpty ifTrue: [ ^self].

	(theTypeName findString: '::' startingAt: 1 ) > 0 
		ifFalse: [  
			anExistingType := self types detect: [:aType | aType name = theTypeName] ifNone: [ nil].
			anExistingType isNil ifFalse: [ ^anExistingType].
			someNames := Array with: theTypeName
		]
		ifTrue: [ 
			anSpacedTypeName := theTypeName copyReplaceAll: '::' with: ' '.
			someNames := anSpacedTypeName asArrayOfSubstrings
		].
	
	^self findTypeNamedArray: someNames!

findTypeNamedArray: theNames
	
	| aName aModule otherNames aSuperModule aType |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ 
		aType := self typeNamed: aName.
		aType isNil ifFalse: [ ^aType].
	].

	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ 
		aSuperModule := self superModule.
		aSuperModule isNil ifTrue: [ ^nil].
		^aSuperModule findTypeNamedArray: theNames].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames!

fromLineStream: theLineStream andStream: theStream

	theLineStream isNil ifTrue: [ ^nil].
	theLineStream atEnd ifTrue: [ ^nil].
self logTranscript ifTrue: [ Transcript  show: ' >> ';  show: self name; cr].

	[ theLineStream atEnd] whileFalse: [ 	| aWord |
		aWord := self nextTokenFrom: theLineStream.
		aWord isNil ifTrue: [ ^nil].
		aWord = ';' ifTrue: [ ^nil].
		aWord = ':' 
			ifTrue: [ self superTypeFromLineStream: theLineStream andStream: theStream]
			ifFalse: [ 
				aWord = '{' 
					ifTrue: [ self featuresFromStream: theStream]
					ifFalse: [ 
						aWord = '}' ifTrue: [ ^self]
					]	
			]	

	]!

relationshipFromLineStream: theLineStream andStream: theStream
	
	| anExistingRelationship aNewRelationship aRelationshipName anIsDerived |

	theLineStream isNil ifTrue: [ ^self].
	theLineStream atEnd ifTrue: [ ^self].
	
	aRelationshipName := self nextTokenFrom: theLineStream.
	aRelationshipName isEmpty ifTrue: [ ^self].
	
	aRelationshipName = '/' ifTrue: [ 	
		anIsDerived := true.
		aRelationshipName := self nextTokenFrom: theLineStream.
	].	

	anExistingRelationship := self relationshipNamed: aRelationshipName.
	anExistingRelationship isNil
		ifFalse: [ anExistingRelationship fromLineStream: theLineStream andStream: theStream]
		ifTrue: [  
self logTranscript ifTrue: [ Transcript show: (String with: Character tab); show: ' + R '; show: aRelationshipName; cr].
			aNewRelationship := CODERelationship new.
			aNewRelationship name: aRelationshipName.
			anIsDerived == true ifTrue: [ 
				aNewRelationship derived: true].
			self relationshipsAdd: aNewRelationship.
			aNewRelationship fromLineStream: theLineStream andStream: theStream
		]!

superTypeFromLineStream: theLineStream andStream: theStream

	| aWord aSuperType |
	theLineStream isNil ifTrue: [ ^nil].
	theLineStream atEnd ifTrue: [ ^nil].
	self model isNil ifTrue: [ ^nil].

  [ theLineStream atEnd] whileFalse: [ 

	aWord := self nextTokenFrom: theLineStream stopAt: '{'.
	aWord isNil ifTrue: [ ^nil].
	aWord isEmpty ifTrue: [ ^self].
	aWord = '{' ifTrue: [ ^self].
	aWord = ','  ifFalse: [ 
	aSuperType := self module findTypeNamed: aWord.
	aSuperType isNil ifFalse: [ 
self logTranscript ifTrue: [ Transcript show: (String with: Character tab); show: ' super '; show: aWord; cr].
"Transcript show: (String with: Character tab); show: self name, ' super '; show: aWord; cr."
		aSuperType subTypesAdd: self.
	]
   ]
  ]!

typeFromLineStream: theLineStream andStream: theStream
	
	| aTypeName   anExistingType aNewType anErrorName |

	theLineStream isNil ifTrue: [ ^self].
	theLineStream atEnd ifTrue: [ ^self].
	
	aTypeName := self nextTokenFrom: theLineStream.
	aTypeName isEmpty ifTrue: [ ^self].
	
	anExistingType := self typeNamed: aTypeName.
	anExistingType isNil
		ifFalse: [ 
			self model errorLineKind isNil ifFalse: [ 
				anErrorName := self model errorLineName.
				anErrorName = 'Enumeration' ifTrue: [ anExistingType isEnumeration: true].
				anErrorName = 'primitive' ifTrue: [ anExistingType isPrimitive: true].
			].
			self model foundIsAbstract ifTrue: [ 
				 anExistingType isAbstract: true].

			anExistingType fromLineStream: theLineStream andStream: theStream]
		ifTrue: [  
self logTranscript ifTrue: [ Transcript show: '+ T '; show: aTypeName; cr].
					
			aNewType := CODEType new.
			aNewType name: aTypeName.
			self typesAdd: aNewType.
			self model errorLineKind isNil ifFalse: [ 
				anErrorName := self model errorLineName.
				anErrorName = 'Enumeration' ifTrue: [ aNewType isEnumeration: true].
				anErrorName = 'primitive' ifTrue: [ aNewType isPrimitive: true].
			].
			aNewType fromLineStream: theLineStream andStream: theStream
		].!

typeNamedArray: theNames
	
	| aName aModule otherNames |
	theNames isNil ifTrue: [ ^self].
	theNames isEmpty ifTrue: [ ^self].

	aName :=  theNames first.
	aName isNil ifTrue: [ ^nil].
	theNames size == 1 ifTrue: [ ^self typeNamed: aName].
	aModule := self moduleNamed: aName.
	aModule isNil ifTrue: [ ^nil].

	otherNames := theNames copyFrom: 2 to: theNames size.
	^aModule typeNamedArray: otherNames! !

!CODEType publicMethodsFor: 'persistence-code'!

allQualifiedNamesInto: theStream

	| aModule aSep |
	theStream isNil ifTrue: [ ^self].

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	aModule isNil  ifFalse: [  aModule allModuleNamesInto: theStream].

	theStream 
		nextPutAll: (self pcForV: self class qualifiedNameTypeStepSymbol); nextPutAll: aSep;
		 nextPutAll: (self pcForV: self name); nextPutAll: aSep.!

asReferenceArray

	| someModuleNames aModule |

	aModule := self module.
	someModuleNames := aModule isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aModule allModuleNamesArray].

	^(Array with: self class refToTypeKindSymbol with: self name), someModuleNames!

asReferenceAsCodeString

	| aModule aStream |

	aStream := WriteStream on: (OrderedCollection new: 8).

	aModule := self module.

	aStream nextPut: self class refToTypeKindSymbol;  
		nextPut: self name.

	aModule isNil  ifFalse: [ aModule allModuleNamesInto: aStream].!

asReferenceAsCodeStringArray

	| someModuleNames aModule |

	aModule := self module.
	someModuleNames := aModule isNil 
		 ifTrue: [ Array new] 
		ifFalse: [ aModule allModuleNamesArray].
	someModuleNames isEmpty ifFalse: [ someModuleNames := someModuleNames copyFrom: 2 to: someModuleNames size].

	^(Array with: self class refToTypeKindSymbol with: self name), someModuleNames!

asReferenceAsCodeStringNOCROn: theStream

	| aSep aModule |

	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
	aModule := self module.

	theStream nextPutAll: ' ( ';  nextPutAll: (self pcForV: self class refToTypeKindSymbol);  
		nextPutAll: aSep; nextPutAll: (self pcForV: self name); nextPutAll: aSep.

	aModule isNil 
		 ifTrue: [ theStream nextPutAll: (self pcForV: nil)] 
		ifFalse: [ aModule allModuleNamesInto: theStream].
 
	theStream  nextPutAll: ' ) '.!

asReferenceAsCodeStringOn: theStream indent: theIS

	theStream isNil ifTrue: [ ^self]. 

	theStream nextPutAll: theIS.
	self asReferenceAsCodeStringNOCROn: theStream. 
	theStream cr.!

attributesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self attributesPrivate isNil not and: [ self attributesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class attributesPersistenceSymbol); cr
			].
			self attributesPrivate do:  [:anAttrib |
				anAttrib persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

firstPersistenceIndexType
	^self numberPersistenceEntriesElement +
		self numberPersistenceEntriesCommentedElement  +
		self numberPersistenceEntriesParametrizedElement  +
		self numberPersistenceEntriesAspectuatedElement  +
		1!

initAttributesFromValues: theValues 
	
	| someAttributes |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someAttributes := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someAttributes isNil ifFalse: [ 
		self attributesPrivate addAll: someAttributes.
		someAttributes do: [:aC | aC typePrivate: self]]!

initFromValues: theValues 
	
	| aFPI |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	super initFromValues: theValues.

	aFPI := self firstPersistenceIndexType.

	self forzeIsAbstract:	 					(theValues size < aFPI ifTrue: [nil] ifFalse: [ theValues at: aFPI]).
	self forzeIsEnumeration:	 				(theValues size < (aFPI + 1) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 1)]).
	self forzeIsPrimitive:						(theValues size < (aFPI + 2) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 2)]).
	self forzeStoreClassName: 				(theValues size < (aFPI + 3) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 3)]). 
	self forzeStoreMethodSelector: 			(theValues size < (aFPI + 4) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 4)]). 
	self forzeReengineredClassName:		(theValues size < (aFPI + 5) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 5)]). 
	self forzeIsExclussion:	 				(theValues size < (aFPI + 6) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 6)]).
	self forzeIsVirtual:						(theValues size < (aFPI + 7) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 7)]).
	self forzeIsHomeRooted:					(theValues size < (aFPI + 8) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 8)]).
	self forzeIsHomeIDProvider:				(theValues size < (aFPI + 9) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 9)]).
	self forzePrimitiveInitializationString:		(theValues size < (aFPI + 10) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 10)]).



	theValues size < (aFPI + 11) ifFalse: [  self initReferencedSuperTypesFromValues: (theValues at: (aFPI + 11)) ].
	theValues size < (aFPI + 12) ifFalse: [ self initAttributesFromValues: (theValues at: (aFPI + 12))].
	theValues size < (aFPI + 13) ifFalse: [ self initRelationshipsFromValues: (theValues at: (aFPI + 13)) ].
	theValues size < (aFPI + 14) ifFalse: [ self initOperationsFromValues: (theValues at: (aFPI + 14)) ].
	theValues size < (aFPI + 15) ifFalse: [ self initTypesFromValues: (theValues at: (aFPI + 15)) ].

	self forzeIsUse:	 						(theValues size < (aFPI + 16) ifTrue: [nil] ifFalse: [ theValues at: (aFPI + 16)]).!

initOperationsFromValues: theValues 
	
	| someOperations |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someOperations := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someOperations isNil ifFalse: [ 
		self operationsPrivate addAll: someOperations.
		someOperations do: [:aC | aC typePrivate: self]]!

initReferencedSuperTypesFromValues: theValues 
	
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^nil].

	theValues first = self class superTypesPersistenceSymbol ifFalse: [ ^nil].

	superTypesRefsTmpValues := theValues.!

initRelationshipsFromValues: theValues 
	
	| someRelationships |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someRelationships := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someRelationships isNil ifFalse: [ 
		self relationshipsPrivate addAll: someRelationships.
		someRelationships do: [:aR | aR typePrivate: self]]!

initTypesFromValues: theValues
	
	| someTypes |
	(theValues isNil or: [ theValues isEmpty]) ifTrue: [ ^self].

	someTypes := CODEElement newElementsCollectionFromPersistenceAsCode: theValues.
	someTypes isNil ifFalse: [ 
		self typesPrivate addAll: someTypes.
		someTypes do: [:aC | aC modulePrivate: self]]!

inner: theIsInner persistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| aSep aNewStream aNewChunk |

	aSep := self separatorForPersistenceAsCode.
		
	aNewStream :=  nil.
	aNewChunk := nil.

	theIsInner
		ifTrue: [ 
			self mustStore 
				ifFalse: [ 
					theStream isNil ifFalse: [ 
						theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self kind);  
							nextPutAll: aSep; nextPutAll: self name printString; cr].
					self localValuesPersistenceAsCodeStringChunks: theCollection 
						on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.
					theStream isNil ifFalse: [ theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr]
				]
				ifTrue: [ 
					self persistenceRefToMethodAsCodeStringOn: theStream indent: theIS.
					theDoSubChunks ifTrue: [ 

						(self mustStoreWithFilter: theFilter) ifTrue: [ 
							aNewStream := WriteStream on: (String new: self subPartsSize * 256).
							aNewChunk := Array with: self with: aNewStream.
							theCollection add: aNewChunk
						].
						self inner: false persistenceAsCodeStringChunks: theCollection 
							on: aNewStream filter: theFilter indent: self indentStringForPersistenceAsCode 
							doSubChunks: theDoSubChunks
					]
				]
		]
		ifFalse: [ 
			theStream isNil ifFalse: [ 
				theStream nextPutAll: theIS; nextPutAll: '#( ';  nextPutAll: (self pcForV: self kind);  
					nextPutAll: aSep; nextPutAll: self name printString; cr].
			self localValuesPersistenceAsCodeStringChunks: theCollection 
				on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks.
			theStream isNil ifFalse: [ theStream	nextPutAll: theIS; nextPutAll: ' )' ; cr; cr]
		]!

localValuesPersistenceAsCodeStringChunks: theCollection on: theStream filter: theFilter indent: theIS doSubChunks: theDoSubChunks

	| anIS aSep |
	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isAbstract ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isEnumeration ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isPrimitive ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self storeClassName );  nextPutAll: aSep; 
		nextPutAll: (self pcForV:  self storeMethodSelector ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self reengineredClassName );  cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self  isExclussion ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isVirtual ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeRooted ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeIDProvider );cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self primitiveInitializationString ); cr.


	self referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS.
	self attributesPersistenceAsCodeStringOn: theStream indent: theIS.
	self relationshipsPersistenceAsCodeStringOn: theStream indent: theIS.
	self operationsPersistenceAsCodeStringOn: theStream indent: theIS.

	(self typesPrivate isNil not and: [ self typesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	   	  		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class typesPersistenceSymbol); cr
			].
			self typesPrivate do:  [:aType |
				aType inner: true persistenceAsCodeStringChunks: theCollection on: theStream 
					filter: theFilter indent: anIS , self indentStringForPersistenceAsCode doSubChunks: theDoSubChunks
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
	].

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isUse ); cr!

localValuesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

self halt: 'This method should not be invoked on CODEType, but rather #localValuesPersistenceAsCodeStringChunks:on:filter:indent:doSubChunks:'.

self shouldNotImplement.

	theStream isNil ifTrue: [ ^self]. 

	self isNotPersistentMetaInfo ifTrue: [ ^self].

	super localValuesPersistenceAsCodeStringOn: theStream indent: theIS.

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isAbstract ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isEnumeration ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isPrimitive ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self storeClassName );  nextPutAll: aSep; 
		nextPutAll: (self pcForV:  self storeMethodSelector ); cr;
		nextPutAll: anIS;  nextPutAll: (self pcForV:  self reengineredClassName );  cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self  isExclussion ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isVirtual ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeRooted ); nextPutAll: aSep;  
		nextPutAll: (self pcForV:  self  isHomeIDProvider );cr;
		nextPutAll: anIS; nextPutAll: (self pcForV:  self primitiveInitializationString ); cr.


	self referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS.
	self attributesPersistenceAsCodeStringOn: theStream indent: theIS.
	self relationshipsPersistenceAsCodeStringOn: theStream indent: theIS.
	self operationsPersistenceAsCodeStringOn: theStream indent: theIS.

	theStream 
		nextPutAll: anIS;  
		nextPutAll: (self pcForV:  self  isUse ); cr!

mustStore

	^self storeMethodSelector isNil not and: [ 
		self storeMethodSelector isEmpty not and: [ 
			self storeClassName isNil not and: [ 
				self storeClassName isEmpty not]]]!

numberPersistenceEntriesType
	^17!

operationsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self operationsPrivate isNil not and: [ self operationsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class operationsPersistenceSymbol); cr
			].
			self operationsPrivate do:  [:anAttrib |
				anAttrib persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

persistenceAsCodeString

	| aCollection |

	aCollection := self persistenceAsCodeStringChunksFilter: true doSubChunks: false.
	(aCollection isNil or: [ aCollection isEmpty]) ifTrue: [ ^nil].

	^aCollection first at: 2!

persistenceRefToMethodAsCodeStringOn: theStream indent: theIS

	| aSep |
	theStream isNil ifTrue: [ ^self]. 

	aSep := self separatorForPersistenceAsCode.
		
	theStream nextPutAll: theIS; nextPutAll: '( ';  nextPutAll: (self pcForV: self class refToTypeMethodKind);  
		nextPutAll: aSep; nextPutAll: self name printString;  
		nextPutAll: aSep; nextPutAll: (self pcForV: self storeMethodSelector); nextPutAll: aSep; nextPutAll: (self pcForV: self storeClassName);  
		nextPutAll: ' )' ; cr; cr.!

ph2InitFromSolver: theSolver
	super ph2InitFromSolver: theSolver.

(self module name = 'CategoryPage' and: [ self name = 'Body']) ifTrue: [ self halt: 'Body in CategoryPage'].

	self ph2InitReferencedSuperTypesValuesFromSolver: theSolver.
	self attributesPrivate do: [:aType | aType ph2InitFromSolver: theSolver].	
	self relationshipsPrivate do: [:aType | aType ph2InitFromSolver: theSolver].
	self typesPrivate do: [:aType | aType ph2InitFromSolver: theSolver].!

ph2InitReferencedSuperTypesValuesFromSolver: theSolver
	
	| someTypes |

	(superTypesRefsTmpValues isNil or: [ superTypesRefsTmpValues isEmpty]) ifTrue: [ ^self].

	someTypes := 
		CODEElement resolveOrNewReferencedTypesCollectionFromPersistenceAsCode: superTypesRefsTmpValues  solver: theSolver.
	self superTypesPrivate  addAll: someTypes.
	someTypes do: [:aC | aC subTypesPrivate add: self].

	superTypesRefsTmpValues := nil!

referencedSuperTypesPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.

	(self superTypesPrivate isNil not and: [ self superTypesPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS; nextPutAll: (self pcForV: nil); cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
	    	 			nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class superTypesPersistenceSymbol); cr
			].
			self superTypesPrivate do:  [:aType |
				aType asReferenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

relationshipsPersistenceAsCodeStringOn: theStream indent: theIS

	| anIS aSep |

	anIS := theIS , self indentStringForPersistenceAsCode.
	aSep := self separatorForPersistenceAsCode.


	(self relationshipsPrivate isNil not and: [ self relationshipsPrivate isEmpty not]) 
		ifFalse: [  theStream isNil ifFalse: [  theStream nextPutAll: anIS;  nextPutAll: (self pcForV: nil) ; cr]]
		ifTrue:  [ 
			theStream isNil ifFalse: [ 
				theStream 
		     		nextPutAll: anIS;  nextPutAll: '('; nextPutAll: (self pcForV: self  class relationshipsPersistenceSymbol); cr
			].
			self relationshipsPrivate do:  [:aRel |
				aRel persistenceAsCodeStringOn: theStream indent: anIS , self indentStringForPersistenceAsCode
			].
			theStream isNil ifFalse: [  theStream  nextPutAll: anIS; nextPutAll: ' )' ; cr].
		].!

resolveOrNewReferencedAspectName: theName elementNames: theElementNames
	| anElementName someElementNames anAttributeName anAttribute aRelationshipName aRelationship |
	theName isNil ifTrue: [ ^nil].
 
	(theElementNames isNil or: [ theElementNames isEmpty]) ifTrue: [
		^self resolveOrNewReferencedAspectName: theName
	].

	anElementName := theElementNames first.

	anElementName = self class qualifiedNameAttributeStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		anAttributeName := theElementNames at: 2. 
		anAttribute := self attributeNamed: anAttributeName.
		anAttribute isNil ifTrue: [ ^nil].
		someElementNames := theElementNames copyFrom: 2 to: theElementNames size.
		anAttribute resolveOrNewReferencedAspectName: theName elementNames: someElementNames	
	].

	anElementName = self class qualifiedNameRelationshipStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		aRelationshipName := theElementNames at: 2. 
		aRelationship := self typeNamed: aRelationshipName.
		aRelationship isNil ifTrue: [ ^nil].
		theElementNames size < 3 ifTrue: [ ^aRelationship].
		someElementNames := theElementNames copyFrom: 3 to: theElementNames size.
		aRelationship resolveOrNewReferencedAspectName: theName elementNames: someElementNames	
	].

	^nil!

resolveOrNewReferencedAttributeNamed: theName

	| anAttribute |

	theName isNil ifTrue: [ ^nil].

	anAttribute := self resolveReferencedAttributeNamed: theName.
	anAttribute isNil ifFalse: [ ^anAttribute].

	anAttribute := self preferredAttributeClass new name: theName.
	self attributesAdd: anAttribute.
	^anAttribute!

resolveOrNewReferencedElementName: theName elementNames: theElementNames
	| anElementName anAttributeName anAttribute aRelationshipName aRelationship |
	theName isNil ifTrue: [ ^nil].
 
	(theElementNames isNil or: [ theElementNames isEmpty]) ifTrue: [
		^self
	].

	anElementName := theElementNames first.

	anElementName = self class qualifiedNameAttributeStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		anAttributeName := theElementNames at: 2. 
		anAttribute := self attributeNamed: anAttributeName.
		^anAttribute	
	].

	anElementName = self class qualifiedNameRelationshipStepSymbol ifTrue: [  
		theElementNames size < 2 ifTrue: [ ^nil].
		aRelationshipName := theElementNames at: 2. 
		aRelationship := self typeNamed: aRelationshipName.
		^aRelationship
	].

	^nil!

resolveOrNewReferencedOperationNamed: theName

	| anOperation |

	theName isNil ifTrue: [ ^nil].

	anOperation := self resolveReferencedOperationNamed: theName.
	anOperation isNil ifFalse: [ ^anOperation].

	anOperation := self preferredOperationClass new name: theName.
	self attributesAdd: anOperation.
	^anOperation!

resolveOrNewReferencedRelationshipNamed: theName

	| aRel |

	theName isNil ifTrue: [ ^nil].

	aRel := self resolveReferencedRelationshipNamed: theName.
	aRel isNil ifFalse: [ ^aRel].

	aRel := self preferredRelationshipClass new name: theName.
	self relationshipsAdd: aRel.
	^aRel!

resolveOrNewReferencedRelationshipNamed: theName forInverseType: theType

	| aRel |

	theName isNil ifTrue: [ ^nil].

	aRel := self resolveReferencedRelationshipNamed: theName forInverseType: theType.
	aRel isNil ifFalse: [ ^aRel].

	aRel := self preferredRelationshipClass new name: theName.
	self relationshipsAdd: aRel.
	^aRel!

resolveOrNewReferencedTypeName: theName
	| aType |

	theName isNil ifTrue: [ ^nil].

	aType := self typeNamed: theName.
	aType isNil ifFalse: [ ^aType].

	aType := self preferredTypeClass new name: theName.
	self typesAdd: aType.
	^aType!

resolveReferencedAttributeNamed: theName
	| anAttribute |

	theName isNil ifTrue: [ ^nil].

	anAttribute := self attributeNamed: theName.
	^anAttribute!

resolveReferencedOperationNamed: theName
	| anOperation |

	theName isNil ifTrue: [ ^nil].

	anOperation := self operationNamed: theName.
	^anOperation!

resolveReferencedRelationshipNamed: theName
	| aRelationship |

	theName isNil ifTrue: [ ^nil].

	aRelationship := self relationshipNamed: theName.
	^aRelationship!

resolveReferencedRelationshipNamed: theName forInverseType: theType
	| aRefToTypeValues anExistingRelationship someRelationshipsSameName |

	theName isNil ifTrue: [ ^nil].

	someRelationshipsSameName := OrderedCollection new: 8.
	self relationships do: [:aRel | 
		aRel name = theName ifTrue: [ someRelationshipsSameName add: aRel]
	].

	someRelationshipsSameName isEmpty ifTrue:  [ ^nil].
	someRelationshipsSameName size = 1 ifTrue: [ ^someRelationshipsSameName first].


	aRefToTypeValues := theType asReferenceAsCodeStringArray.
	anExistingRelationship := someRelationshipsSameName detect: [:aRel |  | aRelRefToTypeValues |
		aRelRefToTypeValues := aRel referencedInverseRefToTypeValues.
		aRelRefToTypeValues = aRefToTypeValues] ifNone: [ nil].
	anExistingRelationship isNil ifTrue: [ self halt].

	^anExistingRelationship!

resolveReferencedTypeName: theName
	| aType |

	theName isNil ifTrue: [ ^nil].

	aType := self typeNamed: theName.
	^aType! !

!CODEType publicMethodsFor: 'primitive types'!

isIDCompatible
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isIDCompatible!

isPrimitiveBoolean
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isPrimitiveBoolean!

isPrimitiveDate
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isPrimitiveDate!

isPrimitiveInteger
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isPrimitiveInteger!

isPrimitiveNumber
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isPrimitiveNumber!

isPrimitiveString
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isPrimitiveString!

isPrimitiveSymbol
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isPrimitiveSymbol!

isPrimitiveText
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isPrimitiveText!

isPrimitiveTime
	| aBroker |
	aBroker := self primitiveBroker.
	aBroker isNil ifTrue: [ ^false].
	^aBroker isPrimitiveTime!

primitiveBroker

	| aNonVirtualType |

	primitiveBroker isNil ifFalse: [ ^primitiveBroker].

	aNonVirtualType := self nonVirtualType.
	aNonVirtualType isNil ifTrue: [ ^nil].

	aNonVirtualType isPrimitive ifFalse: [ ^nil].

	aNonVirtualType == self ifFalse:  [ ^aNonVirtualType primitiveBroker].

	primitiveBroker := self preferredSystemPrimitiveBrokerClass primitiveBrokerForType: self.
	^primitiveBroker!

resetPrimitiveBroker

	primitiveBroker := nil! !

!CODEType publicMethodsFor: 'semantic checking'!

checkAttributesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkAttributesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkBaseOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkBaseOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkCustOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkDeleteActionOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIfcOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIfcOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkImplOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkImplOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsAbstract: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsEnumeration: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsExclussion: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsHomeIDProvider: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsHomeRooted: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsPrimitive: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsUse: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkIsVirtual: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkMetaOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkModel: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkModule: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOperationsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkOperationsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkPrivOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkPrivOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkPubOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRelatedWithAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRelatedWithRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRelationshipsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkRelationshipsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSkip: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSubTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSubTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSuperTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkSuperTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTrxOutFileName: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTrxOutPrjNdx: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypeOfArgumentsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypeOfArgumentsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypeOfReturnsAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypeOfReturnsRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypeOfValuesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypeOfValuesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesAdd: aValue
	"Generated by ISF/AD. Do not modify"
	^true!

checkTypesRemove: aValue
	"Generated by ISF/AD. Do not modify"
	^true! !

!CODEType publicMethodsFor: 'semantic links'!

attributesCandidates
	"Generated by ISF/AD. Do not modify"
	^self attributes asArray!

attributesCreate
	^CODEAttribute new name: 'newAttribute'!

attributesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self attributesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self attributesAdd: anObject.!

attributesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self attributesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self attributesCreate class
		ifUnchanged: [^self].
	self attributesAdd: anObject!

attributesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

baseOutFileNameCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self baseOutFileName!

baseOutFileNameCreate
	"Generated by ISF/AD. Do not modify"
	^''!

baseOutFileNameLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self baseOutFileName: self baseOutFileNameCreate.!

baseOutFileNameLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self baseOutFileNameCandidates
		initially: self baseOutFileName
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self baseOutFileName: anObject.!

baseOutFileNameLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self baseOutFileNameCandidates
		initially: self baseOutFileName
		label: 'Select Or Create ...'
		class: self baseOutFileNameCreate class
		ifUnchanged: [^self].
	self baseOutFileName: anObject!

baseOutFileNameScope
	"Generated by ISF/AD. Do not modify"
	^nil!

ifcOutFileNameCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self ifcOutFileName!

ifcOutFileNameCreate
	"Generated by ISF/AD. Do not modify"
	^''!

ifcOutFileNameLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self ifcOutFileName: self ifcOutFileNameCreate.!

ifcOutFileNameLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self ifcOutFileNameCandidates
		initially: self ifcOutFileName
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self ifcOutFileName: anObject.!

ifcOutFileNameLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self ifcOutFileNameCandidates
		initially: self ifcOutFileName
		label: 'Select Or Create ...'
		class: self ifcOutFileNameCreate class
		ifUnchanged: [^self].
	self ifcOutFileName: anObject!

ifcOutFileNameScope
	"Generated by ISF/AD. Do not modify"
	^nil!

implOutFileNameCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self implOutFileName!

implOutFileNameCreate
	"Generated by ISF/AD. Do not modify"
	^''!

implOutFileNameLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self implOutFileName: self implOutFileNameCreate.!

implOutFileNameLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self implOutFileNameCandidates
		initially: self implOutFileName
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self implOutFileName: anObject.!

implOutFileNameLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self implOutFileNameCandidates
		initially: self implOutFileName
		label: 'Select Or Create ...'
		class: self implOutFileNameCreate class
		ifUnchanged: [^self].
	self implOutFileName: anObject!

implOutFileNameScope
	"Generated by ISF/AD. Do not modify"
	^nil!

moduleCandidates
	"Generated by ISF/AD. Do not modify"
	^self module isNil
		ifTrue: [Array new]
		ifFalse: [Array with: self module]!

moduleCreate
	"Generated by ISF/AD. Do not modify"
	^CODEModule new!

moduleLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self moduleCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [self module: anObject]!

moduleLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self moduleCandidates
		initially: self module
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self module: anObject.!

moduleLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self moduleCandidates
		initially: self module
		label: 'Select Or Create ...'
		class: self moduleCreate class
		ifUnchanged: [^self].
	self module: anObject!

moduleScope
	"Generated by ISF/AD. Do not modify"
	^nil!

operationsCandidates
	"Generated by ISF/AD. Do not modify"
	^self operations asArray!

operationsCreate
	^CODEOperation new name: 'newOperation'!

operationsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self operationsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self operationsAdd: anObject.!

operationsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self operationsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self operationsCreate class
		ifUnchanged: [^self].
	self operationsAdd: anObject!

operationsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

privOutFileNameCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self privOutFileName!

privOutFileNameCreate
	"Generated by ISF/AD. Do not modify"
	^''!

privOutFileNameLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self privOutFileName: self privOutFileNameCreate.!

privOutFileNameLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self privOutFileNameCandidates
		initially: self privOutFileName
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self privOutFileName: anObject.!

privOutFileNameLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self privOutFileNameCandidates
		initially: self privOutFileName
		label: 'Select Or Create ...'
		class: self privOutFileNameCreate class
		ifUnchanged: [^self].
	self privOutFileName: anObject!

privOutFileNameScope
	"Generated by ISF/AD. Do not modify"
	^nil!

relatedWithCandidates
	"Generated by ISF/AD. Do not modify"
	^self relatedWith asArray!

relatedWithCreate
	"Generated by ISF/AD. Do not modify"
	^CODERelationship new!

relatedWithLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self relatedWithCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self relatedWithAdd: anObject]!

relatedWithLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self relatedWithCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self relatedWithAdd: anObject.!

relatedWithLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self relatedWithCandidates
		initially: nil
		label: 'Select Or Create'
		class: self relatedWithCreate class
		ifUnchanged: [^self].
	self relatedWithAdd: anObject!

relatedWithScope
	"Generated by ISF/AD. Do not modify"
	^nil!

relationshipsCandidates
	"Generated by ISF/AD. Do not modify"
	^self relationships asArray!

relationshipsCreate
	"Generated by ISF/AD. Do not modify"
	^CODERelationship new!

relationshipsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self relationshipsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self relationshipsAdd: anObject.!

relationshipsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self relationshipsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self relationshipsCreate class
		ifUnchanged: [^self].
	self relationshipsAdd: anObject!

relationshipsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

subTypesCandidates
	"Generated by ISF/AD. Do not modify"
	^self subTypes asArray!

subTypesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

subTypesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self subTypesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self subTypesAdd: anObject]!

subTypesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self subTypesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self subTypesAdd: anObject.!

subTypesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self subTypesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self subTypesCreate class
		ifUnchanged: [^self].
	self subTypesAdd: anObject!

subTypesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

superTypeScope
	"Generated by ISF/AD. Do not modify"
	^nil!

superTypesCreate
	"Generated by ISF/AD. Do not modify"
	^CODEType new!

superTypesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self superTypesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self superTypesAdd: anObject.!

superTypesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self superTypesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self superTypesCreate class
		ifUnchanged: [^self].
	self superTypesAdd: anObject!

superTypesScope
	"Generated by ISF/AD. Do not modify"
	^nil!

trxOutFileNameCandidates
	"Generated by ISF/AD. Do not modify"
	^Array with: self trxOutFileName!

trxOutFileNameCreate
	"Generated by ISF/AD. Do not modify"
	^''!

trxOutFileNameLinkCreate
	"Generated by ISF/AD. Do not modify"

	^self trxOutFileName: self trxOutFileNameCreate.!

trxOutFileNameLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self trxOutFileNameCandidates
		initially: self trxOutFileName
		withLabel: 'Select ...'
		ifUnchanged: [^self].
	self trxOutFileName: anObject.!

trxOutFileNameLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self trxOutFileNameCandidates
		initially: self trxOutFileName
		label: 'Select Or Create ...'
		class: self trxOutFileNameCreate class
		ifUnchanged: [^self].
	self trxOutFileName: anObject!

trxOutFileNameScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typeOfArgumentsCandidates
	"Generated by ISF/AD. Do not modify"
	^self typeOfArguments asArray!

typeOfArgumentsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEOperation new!

typeOfArgumentsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typeOfArgumentsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self typeOfArgumentsAdd: anObject]!

typeOfArgumentsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typeOfArgumentsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self typeOfArgumentsAdd: anObject.!

typeOfArgumentsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typeOfArgumentsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self typeOfArgumentsCreate class
		ifUnchanged: [^self].
	self typeOfArgumentsAdd: anObject!

typeOfArgumentsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typeOfReturnsCandidates
	"Generated by ISF/AD. Do not modify"
	^self typeOfReturns asArray!

typeOfReturnsCreate
	"Generated by ISF/AD. Do not modify"
	^CODEOperation new!

typeOfReturnsLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typeOfReturnsCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self typeOfReturnsAdd: anObject]!

typeOfReturnsLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typeOfReturnsCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self typeOfReturnsAdd: anObject.!

typeOfReturnsLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typeOfReturnsCandidates
		initially: nil
		label: 'Select Or Create'
		class: self typeOfReturnsCreate class
		ifUnchanged: [^self].
	self typeOfReturnsAdd: anObject!

typeOfReturnsScope
	"Generated by ISF/AD. Do not modify"
	^nil!

typesCandidates
	"Generated by ISF/AD. Do not modify"
	^self types asArray!

typesCreate
	^self preferredTypeClass new!

typesLinkCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := self typesCreate.
	(RTProfiledStringRequestor new requestNameFor: anObject)
		ifTrue: [^self typesAdd: anObject]!

typesLinkSelect
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		selectIn: self typesCandidates
		initially: nil
		withLabel: 'Select...'
		ifUnchanged: [^self].
	self typesAdd: anObject.!

typesLinkSelectOrCreate
	"Generated by ISF/AD. Do not modify"
	| anObject |

	anObject := RTObjectServer new
		chooseOrNewIn: self typesCandidates
		initially: nil
		label: 'Select Or Create'
		class: self typesCreate class
		ifUnchanged: [^self].
	self typesAdd: anObject!

typesScope
	"Generated by ISF/AD. Do not modify"
	^nil! !

!CODEType publicMethodsFor: 'semantic links-custom'!

attributeBaseLinkCreate


	| anAttributeName aNewAttribute |
	anAttributeName := Dialog request: 'Please, enter name for new Attribute' initialAnswer: ''.
	(anAttributeName isNil or: [ anAttributeName isEmpty]) ifTrue: [ ^self].

	aNewAttribute := self preferredAttributeClass new name: anAttributeName.
	aNewAttribute type: self.
	aNewAttribute minMult: self class minMultOptional.
	aNewAttribute maxMult: self class maxMultOne.

	self attributesAdd: aNewAttribute.

	^aNewAttribute!

attributeCopyAllLinkCreate

	| aNewAttribute aModel aNLSItem aNLSSolver aNewNLSItem someTypes aSelectedType someAttributes |

	someTypes := (self model allTypes reject: [:aType | aType == self]) asSortedCollection: [:aType :otherType |
		(Object errorSignal
			handle: [:anException | anException returnWith: aType name]
			do: [ aType nlsName , ' 	(', aType name, ')' ]) <
		(Object errorSignal
			handle: [:anException | anException returnWith: otherType name]
			do: [ otherType nlsName , ' 	(', otherType name, ')' ])
	].

	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No candidate Types to copy Attributes from'.
		^nil
	].


	aSelectedType := Dialog 
		choose: ('Please, select a Type to COPY Attributes from') withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName , ' 	(', aType name, ')' ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].
	
	someAttributes := aSelectedType attributes.
	someAttributes do: [:anAttribute |

		aNewAttribute := self preferredAttributeClass new name: anAttribute name copy.
		aNewAttribute type: self.
		aNewAttribute valueType: anAttribute valueType.
		aNewAttribute initTerminalMetaAttributesFrom: anAttribute.

		aModel := self model.
		aModel isNil ifFalse: [ 
			aNLSSolver := aModel nlsSolver.
			aNLSSolver isNil ifFalse: [ 
				aNLSItem := aNLSSolver nlsResolverItemApp: anAttribute nlsAppName 
					group: anAttribute nameNLSGroupName item: anAttribute nameNLSItemName.
				aNLSItem isNil ifFalse: [
					aNewNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: aNewAttribute nlsAppName 
						group: aNewAttribute nameNLSGroupName item: aNewAttribute nameNLSItemName.
					aNewNLSItem isNil ifTrue: [ 
						aNewNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: aNewAttribute nlsAppName group: aNewAttribute nameNLSGroupName
							item: aNewAttribute nameNLSItemName translation: aNewAttribute nameNLSItemName.
					].
					(aNewNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
						aNewNLSItem usedItemTranslationsAdd: aNLSItem.
						aNewNLSItem changed: #itemTranslations
					]
				]
			]
		].
		aNewAttribute changed: #name.
	].!

attributeCopyOneLinkCreate

	| someCandidateAttributes aSelectedAttribute aNewAttribute aModel aNLSItem aNLSSolver aNewNLSItem aSelectedAttributeValueType |

	someCandidateAttributes := self allEffectiveAttributes.

	(someCandidateAttributes isNil or: [ someCandidateAttributes isEmpty]) ifTrue: [ 
		Dialog warn: 'No candidate Attributes to Copy in Element'.
		^nil
	].


	someCandidateAttributes := someCandidateAttributes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedAttribute := Dialog 
		choose: ('Please, select a Attribute to refine') withCRs
		fromList: (someCandidateAttributes collect: [:aAttribute | 
			Object errorSignal
				handle: [:anException | anException returnWith: aAttribute name]
				do: [ aAttribute nlsName , ' 	(', aAttribute name, ')' ]]) 
		values: someCandidateAttributes 
		lines: (((someCandidateAttributes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedAttribute isNil ifTrue: [ ^nil].
	
	aSelectedAttributeValueType := aSelectedAttribute valueType.
	aSelectedAttributeValueType isNil ifTrue: [ 
		Dialog warn: 'Selected Attribute has no valueType (ERROR)'.
		^nil
	].


	aNewAttribute := self preferredAttributeClass new name: aSelectedAttribute name copy.
	aNewAttribute type: self.
	aNewAttribute valueType: aSelectedAttribute valueType.
	aNewAttribute initTerminalMetaAttributesFrom: aSelectedAttribute.



	aModel := self model.
	aModel isNil ifFalse: [ 
		aNLSSolver := aModel nlsSolver.
		aNLSSolver isNil ifFalse: [ 
			aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedAttribute nlsAppName 
				group: aSelectedAttribute nameNLSGroupName item: aSelectedAttribute nameNLSItemName.
			aNLSItem isNil ifFalse: [
				aNewNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: aNewAttribute nlsAppName 
					group: aNewAttribute nameNLSGroupName item: aNewAttribute nameNLSItemName.
				aNewNLSItem isNil ifTrue: [ 
					aNewNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: aNewAttribute nlsAppName group: aNewAttribute nameNLSGroupName
						item: aNewAttribute nameNLSItemName translation: aNewAttribute nameNLSItemName.
				].
				(aNewNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
					aNewNLSItem usedItemTranslationsAdd: aNLSItem.
					aNewNLSItem changed: #itemTranslations
				]
			]
		]
	].
	aNewAttribute changed: #name.

	^aNewAttribute!

attributeRefinementLinkCreate

	| someTypes aSelectedType   someOwnAttributes someAttributesToAvoid someCandidateAttributes aSelectedAttribute aNewAttribute aModel aNLSItem aNLSSolver aNewNLSItem aSelectedAttributeValueType |

	someOwnAttributes := self attributesPrivate.
	someAttributesToAvoid := IdentitySet new: (someOwnAttributes size * 1.5) floor.
	someAttributesToAvoid addAll: someOwnAttributes.

	someOwnAttributes do: [:anExistingAttribute | 
		anExistingAttribute isRefinement ifTrue: [ 
			someAttributesToAvoid addAll: anExistingAttribute allRefinedAttributes
		]
	].

	someCandidateAttributes := self allEffectiveAttributes reject: [:anExistingAttribute | someAttributesToAvoid includes: anExistingAttribute].

	(someCandidateAttributes isNil or: [ someCandidateAttributes isEmpty]) ifTrue: [ 
		Dialog warn: 'No candidate Attributes to Refine in Model'.
		^nil
	].


	someCandidateAttributes := someCandidateAttributes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedAttribute := Dialog 
		choose: ('Please, select a Attribute to refine') withCRs
		fromList: (someCandidateAttributes collect: [:aAttribute | 
			Object errorSignal
				handle: [:anException | anException returnWith: aAttribute name]
				do: [ aAttribute nlsName , ' 	(', aAttribute name, ')' ]]) 
		values: someCandidateAttributes 
		lines: (((someCandidateAttributes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedAttribute isNil ifTrue: [ ^nil].
	
	aSelectedAttributeValueType := aSelectedAttribute valueType.
	aSelectedAttributeValueType isNil ifTrue: [ 
		Dialog warn: 'Selected Attribute has no valueType (ERROR)'.
		^nil
	].

	
	someTypes := aSelectedAttributeValueType withAllSubtypes.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types to refine Attribute (ERROR) \' withCRs, 
			aSelectedAttribute nlsName.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedType := Dialog 
		choose: ('  Please, select a Type to as ValueType of the new Refined Attribute  \', 
		'\as refinement of attribute  \' , aSelectedAttribute nlsName) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName , ' 	(', aType name, ')' ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	aNewAttribute := self preferredAttributeRefinementClass new name: aSelectedAttribute name copy.
	aNewAttribute type: self.
	aNewAttribute valueType: aSelectedType.
	aNewAttribute refinedAttributesAdd: aSelectedAttribute.
	aNewAttribute initTerminalMetaAttributesFrom: aSelectedAttribute.
	



	aModel := self model.
	aModel isNil ifFalse: [ 
		aNLSSolver := aModel nlsSolver.
		aNLSSolver isNil ifFalse: [ 
			aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedAttribute nlsAppName 
				group: aSelectedAttribute nameNLSGroupName item: aSelectedAttribute nameNLSItemName.
			aNLSItem isNil ifFalse: [
				aNewNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: aNewAttribute nlsAppName 
					group: aNewAttribute nameNLSGroupName item: aNewAttribute nameNLSItemName.
				aNewNLSItem isNil ifTrue: [ 
					aNewNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: aNewAttribute nlsAppName group: aNewAttribute nameNLSGroupName
						item: aNewAttribute nameNLSItemName translation: aNewAttribute nameNLSItemName.
				].
				(aNewNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
					aNewNLSItem usedItemTranslationsAdd: aNLSItem.
					aNewNLSItem changed: #itemTranslations
				]
			]
		]
	].
	aNewAttribute changed: #name.

	^aNewAttribute!

attributesLinkCreate

	| aAttributeKind |

	aAttributeKind := Dialog
		choose: 'Please choose between a new Attribute,\or REFINEMENT of existing Attribute\or a Copy of a existing Attribute in this Type\or copies of ALL Attributes in another Type\or Cancel' withCRs
		labels: (Array with: 'new Attribute' with: 'REFINEMENT' with: 'COPY ONE from THIS type' with: 'COPY ALL from OTHER Type' with: 'Cancel')
		values: #(#newAttribute #REFINEMENT #COPYONE #COPYALL #cancel)
		default: #newAttribute.

	aAttributeKind =  #newAttribute  ifTrue: [ ^self attributeBaseLinkCreate].
	aAttributeKind =  #REFINEMENT  ifTrue: [ ^self attributeRefinementLinkCreate].
	aAttributeKind =  #COPYONE  ifTrue: [ ^self attributeCopyOneLinkCreate].
	aAttributeKind =  #COPYALL  ifTrue: [ ^self attributeCopyAllLinkCreate].
	^self!

operationBaseLinkCreate


	| anOperationName aNewOperation |
	anOperationName := Dialog request: 'Please, enter name for new Operation' initialAnswer: ''.
	(anOperationName isNil or: [ anOperationName isEmpty]) ifTrue: [ ^self].

	aNewOperation := self preferredOperationClass new name: anOperationName.
	aNewOperation type: self.
	aNewOperation minMult: self class minMultOptional.
	aNewOperation maxMult: self class maxMultOne.

	self operationsAdd: aNewOperation.

	^aNewOperation!

operationRefinementLinkCreate

	| someTypes aSelectedType   someOwnOperations someOperationsToAvoid someCandidateOperations aSelectedOperation aNewOperation aModel aNLSItem aNLSSolver aNewNLSItem aSelectedOperationReturnType |

	someOwnOperations := self operationsPrivate.
	someOperationsToAvoid := IdentitySet new: (someOwnOperations size * 1.5) floor.
	someOperationsToAvoid addAll: someOwnOperations.

	someOwnOperations do: [:anExistingOp | 
		anExistingOp isRefinement ifTrue: [ 
			someOperationsToAvoid addAll: anExistingOp refinedOperations
		]
	].

	someCandidateOperations := self allOperations reject: [:anExistingOp | someOperationsToAvoid includes: anExistingOp].

	(someCandidateOperations isNil or: [ someCandidateOperations isEmpty]) ifTrue: [ 
		Dialog warn: 'No candidate Operations to Refine in Model'.
		^nil
	].


	someCandidateOperations := someCandidateOperations asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedOperation := Dialog 
		choose: ('Please, select a Operation to refine') withCRs
		fromList: (someCandidateOperations collect: [:aOperation | 
			Object errorSignal
				handle: [:anException | anException returnWith: aOperation name]
				do: [ aOperation nlsName , ' 	(', aOperation name, ')' ]]) 
		values: someCandidateOperations 
		lines: (((someCandidateOperations size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedOperation isNil ifTrue: [ ^nil].
	
	aSelectedOperationReturnType := aSelectedOperation returnType.
	aSelectedOperationReturnType isNil ifTrue: [ 
		Dialog warn: 'Selected Operation has no returnType (ERROR)'.
		^nil
	].

	
	someTypes := aSelectedOperationReturnType withAllSubtypes.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types to refine Operation (ERROR) \' withCRs, 
			aSelectedOperation nlsName.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedType := Dialog 
		choose: ('  Please, select a Type as ReturnType of the new Refined Operation  \', 
		'\as refinement of operation  \' , aSelectedOperation nlsName) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName , ' 	(', aType name, ')' ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	aNewOperation := self preferredOperationRefinementClass new name: aSelectedOperation name copy.
	aNewOperation type: self.
	aNewOperation returnType: aSelectedType.
	aNewOperation initTerminalMetaOperationsFrom: aSelectedOperation.
	
	aNewOperation refinedOperationsAdd: aSelectedOperation.


	aModel := self model.
	aModel isNil ifFalse: [ 
		aNLSSolver := aModel nlsSolver.
		aNLSSolver isNil ifFalse: [ 
			aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedOperation nlsAppName 
				group: aSelectedOperation nameNLSGroupName item: aSelectedOperation nameNLSItemName.
			aNLSItem isNil ifFalse: [
				aNewNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: aNewOperation nlsAppName 
					group: aNewOperation nameNLSGroupName item: aNewOperation nameNLSItemName.
				aNewNLSItem isNil ifTrue: [ 
					aNewNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: aNewOperation nlsAppName group: aNewOperation nameNLSGroupName
						item: aNewOperation nameNLSItemName translation: aNewOperation nameNLSItemName.
				].
				(aNewNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
					aNewNLSItem usedItemTranslationsAdd: aNLSItem.
					aNewNLSItem changed: #itemTranslations
				]
			]
		]
	].
	aNewOperation changed: #name.

	^aNewOperation!

operationsLinkCreate

	| aOperationKind |

	aOperationKind := Dialog
		choose: 'Please choose between a new Operation,\or REFINEMENT of existing Operation\or Cancel' withCRs
		labels: (Array with: 'new Operation' with: 'REFINEMENT' with: 'Cancel')
		values: #(#newOperation #REFINEMENT #cancel)
		default: #newOperation.

	aOperationKind =  #newOperation  ifTrue: [ ^self operationBaseLinkCreate].
	aOperationKind =  #REFINEMENT  ifTrue: [ ^self operationRefinementLinkCreate].
	^self!

pluralRelationshipNameForTypeName: theName
	| aName aLast aPluralPostfix |
	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^theName].

	aName := self singularRelationshipNameForTypeName: theName.

	aLast := aName last.
	aPluralPostfix := 's'.

	^aName , aPluralPostfix!

relatedTypeCandidates
	
	| aModel |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].

	^aModel allTypes!

relationshipBaseLinkCreate

	| someTypes aSelectedType aRelationship otherRelationship aRelationshipName otherRelationshipName |

	someTypes := self relatedTypeCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model'.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedType := Dialog 
		choose: ('			Please, select a Type to relate with Type			\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ') ', aType allContainerNamespaceNames ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	aRelationshipName := self pluralRelationshipNameForTypeName: aSelectedType name.
	aRelationship := self preferredRelationshipClass new name: aRelationshipName.
	aRelationship type: self.
	aRelationship relatedType: aSelectedType.
	aRelationship minMult: self class minMultOptional.
	aRelationship maxMult: self class maxMultMany.
	aRelationship relationshipKind: self class aggregatesRelationshipKind.

	otherRelationshipName := self singularRelationshipNameForTypeName: self name.
	otherRelationship := self preferredRelationshipClass new name: otherRelationshipName.
	otherRelationship type: aSelectedType.
	otherRelationship relatedType: self.
	otherRelationship minMult: self class minMultRequired.
	otherRelationship maxMult: self class maxMultRequired.
	otherRelationship relationshipKind: self class isAggregatedRelationshipKind.
	otherRelationship isInitializationPropagationAllowed: false.
	otherRelationship isInitializationPropagationOnConnectAllowed: false.
	otherRelationship isChangeable: false.
 
	aRelationship inverse: otherRelationship.

	^aRelationship!

relationshipRefinementLinkCreate

	| someTypes aSelectedType   someOwnRelationships someRelationshipsToAvoid someCandidateRelationships aSelectedRelationship aSelectedRelationshipInverse aSelectedRelationshipRelatedType aNewRelationship otherNewRelationship aModel aNLSSolver aNLSItem aNewNLSItem |

	someOwnRelationships := self relationshipsPrivate.
	someRelationshipsToAvoid := IdentitySet new: (someOwnRelationships size * 1.5) floor.
	someRelationshipsToAvoid addAll: someOwnRelationships.

	someOwnRelationships do: [:anExistingRel | 
		anExistingRel isRefinement ifTrue: [ 
			someRelationshipsToAvoid addAll: anExistingRel refinedRelationships
		]
	].

	someCandidateRelationships := self allEffectiveRelationships reject: [:anExistingRel | someRelationshipsToAvoid includes: anExistingRel].

	(someCandidateRelationships isNil or: [ someCandidateRelationships isEmpty]) ifTrue: [ 
		Dialog warn: 'No candidate Relationships to Refine in Model'.
		^nil
	].


	someCandidateRelationships := someCandidateRelationships asSortedCollection: [:a :b | a name < b name].

	aSelectedRelationship := Dialog 
		choose: ('Please, select a Relationship to refine, to relate with Type\			', self nlsName , ' (' , self name, ')') withCRs
		fromList: (someCandidateRelationships collect: [:aRelationship | 
			Object errorSignal
				handle: [:anException | anException returnWith: aRelationship name]
				do: [ aRelationship nlsName , ' 	(', aRelationship name , ')' ]]) 
		values: someCandidateRelationships 
		lines: (((someCandidateRelationships size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedRelationship isNil ifTrue: [ ^nil].
	
	aSelectedRelationshipInverse := aSelectedRelationship inverse.
	aSelectedRelationshipInverse isNil ifTrue: [ 
		Dialog warn: 'Selected relationship as no inverse (ERROR)'.
		^nil
	].

	aSelectedRelationshipRelatedType := aSelectedRelationship relatedType.
	aSelectedRelationshipRelatedType isNil ifTrue: [ 
		Dialog warn: 'Selected relationship as no relatedType (ERROR)'.
		^nil
	].

	
	someTypes := aSelectedRelationshipRelatedType withAllSubtypes.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types to refine relationship  \' withCRs, 
			aSelectedRelationship displayNameWithTypeAndRelatedType.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedType := Dialog 
		choose: ('  Please, select a Type to relate with Type  \',  self nlsName, ' 	(', self name, ')', 
		'\as refinement of relationship  \' , aSelectedRelationship nlsName , ' 	(',  aSelectedRelationship name, ')') withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ') ', aType allContainerNamespaceNames ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	aNewRelationship := self preferredRelationshipRefinementClass new name: aSelectedRelationship name copy.
	aNewRelationship type: self.
	aNewRelationship relatedType: aSelectedType.
	

	otherNewRelationship := self preferredRelationshipRefinementClass new name: aSelectedRelationshipInverse name copy.
	otherNewRelationship type: aSelectedType.
	otherNewRelationship relatedType: self.

	aNewRelationship inverse: otherNewRelationship.

	aNewRelationship refinedRelationshipsAdd: aSelectedRelationship.
	otherNewRelationship refinedRelationshipsAdd: aSelectedRelationshipInverse.

	aNewRelationship initTerminalMetaAttributesFrom: aSelectedRelationship.
	otherNewRelationship initTerminalMetaAttributesFrom: aSelectedRelationshipInverse.




	aModel := self model.
	aModel isNil ifFalse: [ 
		aNLSSolver := aModel nlsSolver.
		aNLSSolver isNil ifFalse: [ 
			aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedRelationship nlsAppName 
				group: aSelectedRelationship nameNLSGroupName item: aSelectedRelationship nameNLSItemName.
			aNLSItem isNil ifFalse: [
				aNewNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: aNewRelationship nlsAppName 
					group: aNewRelationship nameNLSGroupName item: aNewRelationship nameNLSItemName.
				aNewNLSItem isNil ifTrue: [ 
					aNewNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: aNewRelationship nlsAppName group: aNewRelationship nameNLSGroupName
						item: aNewRelationship nameNLSItemName translation: aNewRelationship nameNLSItemName.
				].
				(aNewNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
					aNewNLSItem usedItemTranslationsAdd: aNLSItem.
					aNewNLSItem changed: #itemTranslations
				]
			]
		]
	].



	aModel := self model.
	aModel isNil ifFalse: [ 
		aNLSSolver := aModel nlsSolver.
		aNLSSolver isNil ifFalse: [ 
			aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedRelationshipInverse nlsAppName 
				group: aSelectedRelationshipInverse nameNLSGroupName item: aSelectedRelationshipInverse nameNLSItemName.
			aNLSItem isNil ifFalse: [
				aNewNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: otherNewRelationship nlsAppName 
					group: otherNewRelationship nameNLSGroupName item: otherNewRelationship nameNLSItemName.
				aNewNLSItem isNil ifTrue: [ 
					aNewNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: otherNewRelationship nlsAppName group: otherNewRelationship nameNLSGroupName
						item: otherNewRelationship nameNLSItemName translation: otherNewRelationship nameNLSItemName.
				].
				(aNewNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
					aNewNLSItem usedItemTranslationsAdd: aNLSItem.
					aNewNLSItem changed: #itemTranslations
				]
			]
		]
	].

	aNewRelationship changed: #name.
	otherNewRelationship changed: #name.

	^aNewRelationship!

relationshipsLinkCreate

	| aRelationshipKind |

	aRelationshipKind := Dialog
		choose: 'Please choose between a new Relationship,\or REFINEMENT of existing Relationship\or Cancel' withCRs
		labels: (Array with: 'new Relationship' with: 'REFINEMENT' with: 'Cancel')
		values: #(#newRelationship #REFINEMENT #cancel)
		default: #newRelationship.

	aRelationshipKind =  #newRelationship  ifTrue: [ ^self relationshipBaseLinkCreate].
	aRelationshipKind =  #REFINEMENT  ifTrue: [ ^self relationshipRefinementLinkCreate].
	^self!

singularRelationshipNameForTypeName: theName
	| aName |
	(theName isNil or: [ theName isEmpty]) ifTrue: [ ^theName].

	aName := theName size = 1 
		ifTrue: [ theName asLowercase]
		ifFalse: [ (String with: theName first asLowercase) , (theName copyFrom: 2 to: theName size)].

	^aName!

superTypesCandidates
	
	| aModel someSubTypes someTypes someCandidateTypes someSuperTypes |
	aModel := self model.
	aModel isNil ifTrue: [ ^nil].

	someSubTypes := self withAllSubtypes.
	someTypes := aModel allTypes.
	someSuperTypes := self withAllSuperTypes.
	someTypes removeAll: someSuperTypes.

	someCandidateTypes := OrderedCollection new: someTypes size - someSubTypes size - 1.
	someTypes do: [:aType |
		((aType == self) not and: [ (someSubTypes includes: aType) not])  ifTrue: [ 
			someCandidateTypes add: aType
		]
	].
	^someCandidateTypes!

superTypesLinkCreate

	| someTypes aSelectedType aModel aNLSSolver aNLSItem aThisNLSItem |

	someTypes := self superTypesCandidates.
	(someTypes isNil or: [ someTypes isEmpty]) ifTrue: [ 
		Dialog warn: 'No Types in Model candidate as SuperType of Type\' withCRs, self name.
		^nil
	].

	someTypes := someTypes asSortedCollection: [:a :b | a nlsName < b nlsName].

	aSelectedType := Dialog 
		choose: ('							Please, select a Type as SuperType of Type							\			', self name) withCRs
		fromList: (someTypes collect: [:aType | 
			Object errorSignal
				handle: [:anException | anException returnWith: aType name]
				do: [ aType nlsName, ' 	(', aType name, ') ', aType allContainerNamespaceNames ]]) 
		values: someTypes 
		lines: (((someTypes size + 1) max: 5) min: 18)
		cancel: [nil].
	aSelectedType isNil ifTrue: [ ^nil].

	self superTypesAdd: aSelectedType.


	(Dialog confirm: 'Do you want to use the SuperType ItemTranslation?' initialAnswer: true) ifTrue: [ 

		aModel := self model.
		aModel isNil ifFalse: [ 
			aNLSSolver := aModel nlsSolver.
			aNLSSolver isNil ifFalse: [ 
				aNLSItem := aNLSSolver nlsResolverItemApp: aSelectedType nlsAppName 
					group: aSelectedType nameNLSGroupName item: aSelectedType nameNLSItemName.
				aNLSItem isNil ifFalse: [
					aThisNLSItem := aNLSSolver nlsLocalResolverItemAppNoDefault: self nlsAppName 
						group: self nameNLSGroupName item: self nameNLSItemName.
					aThisNLSItem isNil ifTrue: [ 
						aThisNLSItem := aNLSSolver nlsLocalResolverItemOrCreateApp: self nlsAppName group: self nameNLSGroupName
							item: self nameNLSItemName translation: self name
					].
					(aThisNLSItem usedItemTranslationsIncludes: aNLSItem) ifFalse: [ 
						aThisNLSItem usedItemTranslationsAdd: aNLSItem.
						self changed: #itemTranslations
					]
				]
			]
		]
	].

	self changed: #name.

	^aSelectedType! !

!CODEType publicMethodsFor: 'testing'!

isType
	^true! !

!CODEType publicMethodsFor: 'updating refinements'!

removeRefinementAttributesFromMissingSuperTypes

	| someOwnAttributes someAttributesToAvoid someAllAttributes someCandidateAttributes  |
	someOwnAttributes := self attributes.
	someAttributesToAvoid := IdentitySet new: (someOwnAttributes size * 1.5) floor.
	someAttributesToAvoid addAll: someOwnAttributes.

	someOwnAttributes do: [:anAttribute | 
		anAttribute isRefinement ifTrue: [ 
			someAttributesToAvoid addAll: anAttribute allRefinedAttributes
		]
	].

	someAllAttributes := self allEffectiveAttributes.
	someCandidateAttributes := IdentitySet new: (someAllAttributes size * 1.5) floor.
	someAllAttributes do: [:anAttribute | 
		(someAttributesToAvoid includes: anAttribute) ifFalse: [ 
			someCandidateAttributes add: anAttribute
		]
	].

	someOwnAttributes copy do: [:anAttribute |  | someBaseAttributes |
		anAttribute isRefinement ifTrue: [ 
			someBaseAttributes := anAttribute refinedAttributes.
			(someBaseAttributes isNil or: [ someBaseAttributes isEmpty or: [ (someCandidateAttributes includes: anAttribute) not]]) ifTrue: [ 
				anAttribute release
			]
		]
	].!

removeRefinementFeaturesFromMissingSuperTypes

	self removeRefinementRelationshipsFromMissingSuperTypes.
	self removeRefinementAttributesFromMissingSuperTypes!

removeRefinementRelationshipsFromMissingSuperTypes

	| someOwnRelationships someRelationshipsToAvoid someAllRelationships someCandidateRelationships  |
	someOwnRelationships := self relationships.
	someRelationshipsToAvoid := IdentitySet new: (someOwnRelationships size * 1.5) floor.
	someRelationshipsToAvoid addAll: someOwnRelationships.

	someOwnRelationships do: [:aRelationship | 
		aRelationship isRefinement ifTrue: [ 
			someRelationshipsToAvoid addAll: aRelationship allRefinedRelationships
		]
	].

	someAllRelationships := self allEffectiveRelationships.
	someCandidateRelationships := IdentitySet new: (someAllRelationships size * 1.5) floor.
	someAllRelationships do: [:aRelationship | 
		(someRelationshipsToAvoid includes: aRelationship) ifFalse: [ 
			someCandidateRelationships add: aRelationship
		]
	].

	someOwnRelationships copy do: [:aRelationship |  | someBaseRelationships |
		aRelationship isRefinement ifTrue: [ 
			someBaseRelationships := aRelationship refinedRelationships.
			(someBaseRelationships isNil or: [ someBaseRelationships isEmpty or: [ (someCandidateRelationships includes: aRelationship) not]]) ifTrue: [ 				aRelationship release
			]
		]
	].!

updateRefinedFeatures

	self updateRefinedFeaturesHere.
	self subTypes do: [:aType | aType updateRefinedFeatures]!

updateRefinedFeaturesHere

	| someAllFeatures someOwnAttributes someOwnRelationships someOwnFeatures someInheritedFeaturesPropagatingUse    |

	someAllFeatures := self allEffectiveStructuralFeatures.
	someOwnAttributes := self attributes.
	someOwnRelationships := self relationships.

	someOwnFeatures := IdentitySet new: ((someOwnAttributes size + someOwnRelationships size) * 1.5) floor.
	someOwnFeatures addAll: someOwnAttributes ; addAll: someOwnRelationships.

	someInheritedFeaturesPropagatingUse := someAllFeatures select: [:aFeature |
		((someOwnFeatures includes: aFeature) not and: [ aFeature isRefinementRequired and: [  aFeature isPropagateUse not]])
	].

	someInheritedFeaturesPropagatingUse isEmpty ifTrue: [ ^self].
	
	someInheritedFeaturesPropagatingUse do: [:aFeature |  
		| aValueType aRefinedAttribute  aRelatedType aRefinedRelationship anInverse aRefinedInverseRelationship |

		aFeature isAttribute ifTrue: [
			aValueType := aFeature valueType.
			aValueType isNil ifFalse: [ 
				aRefinedAttribute := self preferredAttributeRefinementClass new name: aFeature name.
				aRefinedAttribute type: self.
				aRefinedAttribute valueType: aValueType.
				aRefinedAttribute forzeIsPropagateUse: false.
				aRefinedAttribute forzeIsJustUsed: false.
				aRefinedAttribute forzeIsRefinementRequired: true.

				aRefinedAttribute refinedAttributesAdd: aFeature.

				aRefinedAttribute initTerminalMetaAttributesFrom: aFeature.
			]
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [
			anInverse := aFeature inverse.
			anInverse isNil ifFalse: [ 
				aRelatedType := aFeature relatedType.
				aRelatedType isNil ifFalse: [ 
					aRefinedRelationship := self preferredRelationshipRefinementClass new name: aFeature name.
					aRefinedRelationship type: self.
					aRefinedRelationship relatedType: aRelatedType.
					aRefinedRelationship forzeIsPropagateUse: false.
					aRefinedRelationship forzeIsJustUsed: false.
					aRefinedRelationship forzeIsRefinementRequired: true.

					aRefinedInverseRelationship := self preferredRelationshipRefinementClass new name: anInverse name.
					aRefinedInverseRelationship type: aRelatedType.
					aRefinedInverseRelationship relatedType: self.
					aRefinedInverseRelationship forzeIsPropagateUse: false.
					aRefinedInverseRelationship forzeIsJustUsed: false.
					aRefinedInverseRelationship forzeIsRefinementRequired: anInverse isRefinementRequired.

					aRefinedRelationship inverse: aRefinedInverseRelationship.
				
					aRefinedRelationship refinedRelationshipsAdd: aFeature.
					aRefinedInverseRelationship refinedRelationshipsAdd: anInverse.

					aRefinedRelationship initTerminalMetaAttributesFrom: aFeature.
					aRefinedInverseRelationship initTerminalMetaAttributesFrom: anInverse.

				]
			]
		] ifFalse: [ 
		]]
	].! !

!CODEType publicMethodsFor: 'updating uses'!

updateUses

	self updateUsesHere.
	self subTypes do: [:aType | aType updateUses]!

updateUsesHere

	| someAllFeatures someOwnAttributes someOwnRelationships someOwnFeatures someInheritedFeaturesPropagatingUse    |

	self isUse ifFalse: [ ^self].

	someAllFeatures := self allEffectiveStructuralFeatures.
	someOwnAttributes := self attributes.
	someOwnRelationships := self relationships.

	someOwnFeatures := IdentitySet new: ((someOwnAttributes size + someOwnRelationships size) * 1.5) floor.
	someOwnFeatures addAll: someOwnAttributes ; addAll: someOwnRelationships.

	someInheritedFeaturesPropagatingUse := someAllFeatures select: [:aFeature |
		((someOwnFeatures includes: aFeature) not and: [ aFeature isPropagateUse and: [ aFeature isRefinementRequired not]])
	].

	someInheritedFeaturesPropagatingUse isEmpty ifTrue: [ ^self].
	
	someInheritedFeaturesPropagatingUse do: [:aFeature |  
		| someLocalTypes aValueType aRefinedValueType aRefinedAttribute 
		 aRelatedType aRefinedRelatedType aRefinedRelationship anInverse aRefinedInverseRelationship |

		someLocalTypes := self types.
		aFeature isAttribute ifTrue: [
			aValueType := aFeature valueType.
			aValueType isNil ifFalse: [ 
				aRefinedValueType := someLocalTypes detect: [:aLocalType |
					aLocalType superTypesIncludes: aValueType ] ifNone: [ nil].
				aRefinedValueType isNil ifTrue: [ 
					aRefinedValueType := self preferredTypeClass new name: aValueType name.
					self typesAdd: aRefinedValueType.
					aRefinedValueType isUse: true.
					aRefinedValueType forzeIsJustUsed: true.
					aRefinedValueType superTypesAdd: aValueType
				].
				aRefinedAttribute := self preferredAttributeRefinementClass new name: aFeature name.
				aRefinedAttribute type: self.
				aRefinedAttribute valueType: aRefinedValueType.
				aRefinedAttribute forzeIsPropagateUse: true.
				aRefinedAttribute forzeIsJustUsed: true.
				aRefinedAttribute forzeIsRefinementRequired: false.

				aRefinedAttribute refinedAttributesAdd: aFeature.

				aRefinedAttribute initTerminalMetaAttributesFrom: aFeature.
			]
		] ifFalse: [ 
		aFeature isRelationship ifTrue: [
			anInverse := aFeature inverse.
			anInverse isNil ifFalse: [ 
				aRelatedType := aFeature relatedType.
				aRelatedType isNil ifFalse: [ 
					aRefinedRelatedType := someLocalTypes detect: [:aLocalType |
						aLocalType superTypesIncludes: aRelatedType ] ifNone: [ nil].
					aRefinedRelatedType isNil ifTrue: [ 
						aRefinedRelatedType := self preferredTypeClass new name: aRelatedType name.
						self typesAdd: aRefinedRelatedType.
						aRefinedRelatedType isUse: true.
						aRefinedRelatedType forzeIsJustUsed: true.
						aRefinedRelatedType superTypesAdd: aRelatedType
					].
					aRefinedRelationship := self preferredRelationshipRefinementClass new name: aFeature name.
					aRefinedRelationship type: self.
					aRefinedRelationship relatedType: aRefinedRelatedType.
					aRefinedRelationship forzeIsPropagateUse: true.
					aRefinedRelationship forzeIsJustUsed: true.
					aRefinedRelationship forzeIsRefinementRequired: false.

					aRefinedInverseRelationship := self preferredRelationshipRefinementClass new name: anInverse name.
					aRefinedInverseRelationship type: aRefinedRelatedType.
					aRefinedInverseRelationship relatedType: self.
					aRefinedInverseRelationship forzeIsPropagateUse: false.
					aRefinedInverseRelationship forzeIsJustUsed: true.
					aRefinedInverseRelationship forzeIsRefinementRequired: false.

					aRefinedRelationship inverse: aRefinedInverseRelationship.
				
					aRefinedRelationship refinedRelationshipsAdd: aFeature.
					aRefinedInverseRelationship refinedRelationshipsAdd: anInverse.

					aRefinedRelationship initTerminalMetaAttributesFrom: aFeature.
					aRefinedInverseRelationship initTerminalMetaAttributesFrom: anInverse.

				]
			]
		] ifFalse: [ 
		]]
	].! !

!CODEType publicMethodsFor: 'utilities'!

import2lettersISO639

"

'AA Afar
AB Abkhazian
AF Afrikaans
AM Amharic
AR Arabic
AS Assamese
AY Aymara
AZ Azerbaijani
BA Bashkir
BE Byelorussian
BG Bulgarian
BH Bihari
BI Bislama
BN Bengali Bangla
BO Tibetan
BR Breton
CA Catalan
CO Corsican
CS Czech
CY Welsh
DA Danish
DE German
DZ Bhutani
EL Greek
EN English American
EO Esperanto
ES Spanish
ET Estonian
EU Basque
FA Persian
FI Finnish
FJ Fiji
FO Faeroese
FR French
FY Frisian
GA Irish
GD Gaelic Scots Gaelic
GL Galician
GN Guarani
GU Gujarati
HA Hausa
HI Hindi
HR Croatian
HU Hungarian
HY Armenian
IA Interlingua
IE Interlingue
IK Inupiak
IN Indonesian
IS Icelandic
IT Italian
IW Hebrew
JA Japanese
JI Yiddish
JW Javanese
KA Georgian
KK Kazakh
KL Greenlandic
KM Cambodian
KN Kannada
KO Korean
KS Kashmiri
KU Kurdish
KY Kirghiz
LA Latin
LN Lingala
LO Laothian
LT Lithuanian
LV Latvian Lettish
MG Malagasy
MI Maori
MK Macedonian
ML Malayalam
MN Mongolian
MO Moldavian
MR Marathi
MS Malay
MT Maltese
MY Burmese
NA Nauru
NE Nepali
NL Dutch
NO Norwegian
OC Occitan
OM Oromo Afan
OR Oriya
PA Punjabi
PL Polish
PS Pashto Pushto
PT Portuguese
QU Quechua
RM Rhaeto-Romance
RN Kirundi
RO Romanian
RU Russian
RW Kinyarwanda
SA Sanskrit
SD Sindhi
SG Sangro
SH Serbo-Croatian
SI Singhalese
SK Slovak
SL Slovenian
SM Samoan
SN Shona
SO Somali
SQ Albanian
SR Serbian
SS Siswati
ST Sesotho
SU Sudanese
SV Swedish
SW Swahili
TA Tamil
TE Tegulu
TG Tajik
TH Thai
TI Tigrinya
TK Turkmen
TL Tagalog
TN Setswana
TO Tonga
TR Turkish
TS Tsonga
TT Tatar
TW Twi
UK Ukrainian
UR Urdu
UZ Uzbek
VI Vietnamese
VO Volapuk
WO Wolof
XH Xhosa
YO Yoruba
ZH Chinese
ZU Zulu
'
"!

import3lettersISO639

"

'abk      ab    Abkhazian
ace            Achinese
ach            Acoli
ada            Adangme
aar      aa    Afar
afh            Afrihili
afr      af    Afrikaans
afa            Afro-Asiatic (Other)
aka            Akan
akk            Akkadian
alb/sqi  sq    Albanian
ale            Aleut
alg            Algonquian languages
tut            Altaic (Other)
amh      am    Amharic
apa            Apache languages
ara      ar    Arabic
arc            Aramaic
arp            Arapaho
arn            Araucanian
arw            Arawak
arm/hye  hy    Armenian
art            Artificial (Other)
asm      as    Assamese
ath            Athapascan languages
map            Austronesian (Other)
ava            Avaric
ave            Avestan
awa            Awadhi
aym      ay    Aymara
aze      az    Azerbaijani
nah            Aztec
ban            Balinese
bat            Baltic (Other)
bal            Baluchi
bam            Bambara
bai            Bamileke languages
bad            Banda
bnt            Bantu (Other)
bas            Basa
bak      ba    Bashkir
baq/eus  eu    Basque
bej            Beja
bem            Bemba
ben      bn    Bengali
ber            Berber (Other)
bho            Bhojpuri
bih      bh    Bihari
bik            Bikol
bin            Bini
bis      bi    Bislama
bra            Braj
bre      be    Breton
bug            Buginese
bul      bg    Bulgarian
bua            Buriat
bur/mya  my    Burmese
bel      be    Byelorussian
cad            Caddo
car            Carib
cat      ca    Catalan
cau            Caucasian (Other)
ceb            Cebuano
cel            Celtic (Other)
cai            Central American Indian (Other)
chg            Chagatai
cha            Chamorro
che            Chechen
chr            Cherokee
chy            Cheyenne
chb            Chibcha
chi/zho  zh    Chinese
chn            Chinook jargon
cho            Choctaw
chu            Church Slavic
chv            Chuvash
cop            Coptic
cor            Cornish
cos      co    Corsican
cre            Cree
mus            Creek
crp            Creoles and Pidgins (Other)
cpe            Creoles and Pidgins, English-based (Other)
cpf            Creoles and Pidgins, French-based (Other)
cpp            Creoles and Pidgins, Portuguese-based (Other)
cus            Cushitic (Other)
		 hr    Croatian
ces/cze  cs    Czech
dak            Dakota
dan      da    Danish
del            Delaware
din            Dinka
div            Divehi
doi            Dogri
dra            Dravidian (Other)
dua            Duala
dut/nla  nl    Dutch
dum            Dutch, Middle (ca. 1050-1350)
dyu            Dyula
dzo      dz    Dzongkha
efi            Efik
egy            Egyptian (Ancient)
eka            Ekajuk
elx            Elamite
eng      en    English
enm            English, Middle (ca. 1100-1500)
ang            English, Old (ca. 450-1100)
esk            Eskimo (Other)
epo      eo    Esperanto
est      et    Estonian
ewe            Ewe
ewo            Ewondo
fan            Fang
fat            Fanti
fao      fo    Faroese
fij      fj    Fijian
fin      fi    Finnish
fiu            Finno-Ugrian (Other)
fon            Fon
fra/fre  fr    French
frm            French, Middle (ca. 1400-1600)
fro            French, Old (842- ca. 1400)
fry      fy    Frisian
ful            Fulah
gaa            Ga
gae/gdh  Gaelic (Scots)
glg      gl    Gallegan
lug            Ganda
gay            Gayo
gez            Geez
geo/kat  ka    Georgian
deu/ger  de    German
gmh            German, Middle High (ca. 1050-1500)
goh            German, Old High (ca. 750-1050)
gem            Germanic (Other)
gil            Gilbertese
gon            Gondi
got            Gothic
grb            Grebo
grc            Greek, Ancient (to 1453)
ell/gre  el    Greek, Modern (1453-)
kal      kl    Greenlandic
grn      gn    Guarani
guj      gu    Gujarati
hai            Haida
hau      ha    Hausa
haw            Hawaiian
heb      he    Hebrew
her            Herero
hil            Hiligaynon
him            Himachali
hin      hi    Hindi
hmo            Hiri Motu
hun      hu    Hungarian
hup            Hupa
iba            Iban
ice/isl  is    Icelandic
ibo            Igbo
ijo            Ijo
ilo            Iloko
inc            Indic (Other)
ine            Indo-European (Other)
ind      id    Indonesian
ina      ia    Interlingua (International Auxiliary language Association)
ine      -     Interlingue
iku      iu    Inuktitut
ipk      ik    Inupiak
ira            Iranian (Other)
gai/iri  ga    Irish
sga            Irish, Old (to 900)
mga            Irish, Middle (900 - 1200)
iro            Iroquoian languages
ita      it    Italian
jpn      ja    Japanese
jav/jaw  jv/jw Javanese
jrb            Judeo-Arabic
jpr            Judeo-Persian
kab            Kabyle
kac            Kachin
kam            Kamba
kan      kn    Kannada
kau            Kanuri
kaa            Kara-Kalpak
kar            Karen
kas      ks    Kashmiri
kaw            Kawi
kaz      kk    Kazakh
kha            Khasi
khm      km    Khmer
khi            Khoisan (Other)
kho            Khotanese
kik            Kikuyu
kin      rw    Kinyarwanda
kir      ky    Kirghiz
kom            Komi
kon            Kongo
kok            Konkani
kor      ko    Korean
kpe            Kpelle
kro            Kru
kua            Kuanyama
kum            Kumyk
kur      ku    Kurdish
kru            Kurukh
kus            Kusaie
kut            Kutenai
lad            Ladino
lah            Lahnda
lam            Lamba
oci      oc    Langue d'Oc (post 1500)
lao      lo    Lao
lat      la    Latin
lav      lv    Latvian
ltz            Letzeburgesch
lez            Lezghian
lin      ln    Lingala
lit      lt    Lithuanian
loz            Lozi
lub            Luba-Katanga
lui            Luiseno
lun            Lunda
luo            Luo (Kenya and Tanzania)
mac/mak  mk    Macedonian
mad            Madurese
mag            Magahi
mai            Maithili
mak            Makasar
mlg      mg    Malagasy
may/msa  ms    Malay
mal            Malayalam
mlt      ml    Maltese
man            Mandingo
mni            Manipuri
mno            Manobo languages
max            Manx
mao/mri  mi    Maori
mar      mr    Marathi
chm            Mari
mah            Marshall
mwr            Marwari
mas            Masai
myn            Mayan languages
men            Mende
mic            Micmac
min            Minangkabau
mis            Miscellaneous (Other)
moh            Mohawk
mol      mo    Moldavian
mkh            Mon-Kmer (Other)
lol            Mongo
mon      mn    Mongolian
mos            Mossi
mul            Multiple languages
mun            Munda languages
nau      na    Nauru
nav            Navajo
nde            Ndebele, North
nbl            Ndebele, South
ndo            Ndongo
nep      ne    Nepali
new            Newari
nic            Niger-Kordofanian (Other)
ssa            Nilo-Saharan (Other)
niu            Niuean
non            Norse, Old
nai            North American Indian (Other)
nor      no    Norwegian
nno            Norwegian (Nynorsk)
nub            Nubian languages
nym            Nyamwezi
nya            Nyanja
nyn            Nyankole
nyo            Nyoro
nzi            Nzima
oji            Ojibwa
ori      or    Oriya
orm      om    Oromo
osa            Osage
oss            Ossetic
oto            Otomian languages
pal            Pahlavi
pau            Palauan
pli            Pali
pam            Pampanga
pag            Pangasinan
pan      pa    Panjabi
pap            Papiamento
paa            Papuan-Australian (Other)
fas/per  fa    Persian
peo            Persian, Old (ca 600 - 400 B.C.)
phn            Phoenician
pol      pl    Polish
pon            Ponape
por      pt    Portuguese
pra            Prakrit languages
pro            Provencal, Old (to 1500)
pus      ps    Pushto
que      qu    Quechua
roh      rm    Rhaeto-Romance
raj            Rajasthani
rar            Rarotongan
roa            Romance (Other)
ron/rum  ro    Romanian
rom            Romany
run      rn    Rundi
rus      ru    Russian
sal            Salishan languages
sam            Samaritan Aramaic
smi            Sami languages
smo      sm    Samoan
sad            Sandawe
sag      sg    Sango
san      sa    Sanskrit
srd            Sardinian
sco            Scots
sel            Selkup
sem            Semitic (Other)
		 sr    Serbian
scr      sh    Serbo-Croatian
srr            Serer
shn            Shan
sna      sn    Shona
sid            Sidamo
bla            Siksika
snd      sd    Sindhi
sin      si    Singhalese
sit      -     Sino-Tibetan (Other)
sio            Siouan languages
sla            Slavic (Other)
ssw      ss    Siswant
slk/slo  sk    Slovak
slv      sl    Slovenian
sog            Sogdian
som      so    Somali
son            Songhai
wen            Sorbian languages
nso            Sotho, Northern
sot      st    Sotho, Southern
sai            South American Indian (Other)
esl/spa  es    Spanish
suk            Sukuma
sux            Sumerian
sun      su    Sudanese
sus            Susu
swa      sw    Swahili
ssw            Swazi
sve/swe  sv    Swedish
syr            Syriac
tgl      tl    Tagalog
tah            Tahitian
tgk      tg    Tajik
tmh            Tamashek
tam      ta    Tamil
tat      tt    Tatar
tel      te    Telugu
ter            Tereno
tha      th    Thai
bod/tib  bo    Tibetan
tig            Tigre
tir      ti    Tigrinya
tem            Timne
tiv            Tivi
tli            Tlingit
tog      to    Tonga (Nyasa)
ton            Tonga (Tonga Islands)
tru            Truk
tsi            Tsimshian
tso      ts    Tsonga
tsn      tn    Tswana
tum            Tumbuka
tur      tr    Turkish
ota            Turkish, Ottoman (1500 - 1928)
tuk      tk    Turkmen
tyv            Tuvinian
twi      tw    Twi
uga            Ugaritic
uig      ug    Uighur
ukr      uk    Ukrainian
umb            Umbundu
und            Undetermined
urd      ur    Urdu
uzb      uz    Uzbek
vai            Vai
ven            Venda
vie      vi    Vietnamese
vol      vo    Volapk
vot            Votic
wak            Wakashan languages
wal            Walamo
war            Waray
was            Washo
cym/wel  cy    Welsh
wol      wo    Wolof
xho      xh    Xhosa
sah            Yakut
yao            Yao
yap            Yap
yid      yi    Yiddish
yor      yo    Yoruba
zap            Zapotec
zen            Zenaga
zha      za    Zhuang
zul      zu    Zulu
zun            Zuni
'
"!

importAnnotationTypesAndBasicDescriptions

"
'RELIABILITY OF ANNOTATION
	DE01	validated by the Record Component author	The author has created or viewed the annotation mapping personally to verify its accuracy with respect to the elementary healthcare record entry being annotated
	DE02	validated by a generic mapping process	The clinical data set (of which this Record Component is an instance) has previously been mapped to Basic Descriptors
	DE03	applied retrospectively to legacy data	
	DE04	annotation not applied	Not clinically appropriate for this Record Component, or omitted by local agreement because other shared nomenclatures exist.
	DE05	annotation not reliable	For clinical or technical reasons a failure of mapping to (some or all) basic descriptors has occurred: the annotation is absent or incomplete
Safety Annotation Types - strongly recommended for use with all Data Item and Cluster OCC instancesNOTE: 	only one Basic Descriptor may be chosen for each of these Annotation Types		LIFE CYCLE is intended for use with healthcare activities and actions		POTENTIALITY is intended for use with clinical states and conditions
SUBJECT OF INFORMATION
	DS00	patient	pregnant woman
	DS01	relative of patient	mother, father, sibling
	DS02	foetus or neonate	(in the mothers record)
	DS03	mother	(in the new-borns record)
	DS04	donor	includes transplanted body component, e.g. blood product
	DS05	other entity	person in contact at school, insect causing injury
LIFE CYCLE
	DY00	done	normally concluded
	DY01	in process	includes initiated, suspended
	DY02	planned or being planned	includes needed, under consideration, scheduled, ordered
	DY03	exceptionally not done	rejected, cancelled, aborted, interrupted, not done
POTENTIALITY
	DP00	actual	
	DP01	goal	
	DP02	predicted	
	DP03	at risk	
PROCESS STATUS 
	DG00	new	order of laboratory test, new diagnosis
	DG01	ongoing	under therapy for, presently affected by, current medications
	DG02	former	performed in previous episodes, recovered, previous examinations
NEGATION
	DN00	affirmative	
	DN01	negated	
CERTAINTY
	DC00	certain	(reasonable evidence)
	DC01	uncertain	
Primary Clinical Context - recommended for use with all Cluster OCC and most Data Item instancesNOTES: 	only one Basic Descriptor may be chosen for each of these Annotation Types
FOCUS	
	DF01	clinical situation	(see below)
	DF02	- patho-physiological condition or state	actual or potential state, including disease, symptom, function (including pregnancy)
	DF03	- - allergy state	states with the related reactions and tests
	DF04	- events and accidents	actual or potential clinical situations, not directly related to health, but having healthcare consequences or risks
	DF05	- lifestyle features	habits (drinking, smoking, non-therapeutic drugs); travel, employ, education, residence, marital status
	DF06	- healthcare activity	(see below)
	DF07	- - acquiring information	history taking
	DF08	- - observation of property by physical examination	observing a sign, a property of either body part or function
	DF09	- - observation of property by investigation	performing and reporting a laboratory test (order, result)
	DF10	- - recording of images and signals	performing and reporting an imaging procedure, a signal recording 
	DF11	- - decision-making activity	applying a protocol, interpreting data, making a plan
	DF12	- - therapeutic activity	therapy related to an illness (e.g. surgical operation), or prevention
	DF13	- - - physical actions	operations, physiotherapy, wound dressing
	DF14	- - - drug-related activity	prescription /  dispensing by HC professional, assumption by patient
	DF15	- - - preventive activity	cancer screening
	DF16	- - - - immunisation activity	vaccination
	DF17	- - - information activity	informing, advising, educating
	DF18	- - administrative activity	hospital admission / discharge, visit for health-related certifications, referral
KNOWING MODE
	DK01	observation or action by author	Objective, physical examination
	DK02	assessment or opinion by author	Assessment
	DK03	reported by other professional	Objective, laboratory result 
	DK04	reported by patient	Subjective
	DK05	reported by patients representative	Subjective, family member
	DK06	reported by another party	Subjective
Secondary Clinical Context  to be used when  relevantNOTE: 	only one Basic Descriptor may be chosen for the Annotation Types RELEVANCE and URGENCY		more than one Basic  Descriptor may be chosen from each of the other Annotation Types.		SYSTEM Basic Descriptors refer to chapters from the ICPC [34] classification
ROLE	
	DD01	diagnosis	
	DD02	problem	
	DD03	reason for contact	
	DD04	alert	
RELEVANCE 
	DW01	primary	main
	DW02	secondary	
URGENCY	
	DU01	emergency	
	DU02	routine	
ASSOCIATE TOPIC	
	DT01	device	prosthesis, instrument
	DT02	medicinal product	drug
	DT03	method	challenge, measurement method
	DT04	ongoing patient state	cardiopathic, diabetic, pregnant, carrier of prosthesis
	DT05	body component	body part, body region, body system
SYSTEM	
	DB01	body in general	(A)
	DB02	blood	(B) includes blood forming
	DB03	digestive	(D)
	DB04	eye	(F)
	DB05	ear	(H)
	DB06	circulatory	(K)
	DB07	musculoskeletal	(L)
	DB08	neurological	(N)
	DB09	psychological	(P)
	DB10	respiratory	(R)
	DB11	skin	(S)
	DB12	metabolic	(T) includes endocrine, nutritional
	DB13	urinary	(U)
	DB14	pregnancy	(W) includes childbearing and family planning
	DB15	genital	includes (X)-female and (Y)-male
	DB16	social	(Z)'

"!

importEnumsAsListOfCodeAndName: theSource

	| someLines |
	(theSource isNil or: [ theSource isEmpty]) ifTrue: [ ^self].
	someLines := theSource asArrayBrokenOn: Character cr.
	someLines isEmpty ifTrue: [ ^self].

	someLines do: [:aLine |  | anIndex aValue aName aCapitalizedName aStream anAttribute |
		aLine isEmpty ifFalse: [ 
			anIndex := aLine indexOf: Character space.
			anIndex  < 2 ifFalse: [ 
				aValue := aLine copyFrom: 1 to: anIndex - 1.
				aName := aLine copyFrom: anIndex + 1 to: aLine size.
				aStream := WriteStream on: (String new: aName size).
				(aName copyReplacing: $- withObject: Character space)
					asArrayOfSubstrings do: [:aSubstr | aStream nextPutAll: aSubstr capitalized].
				aCapitalizedName := aStream contents.
				anAttribute := self preferredAttributeClass new name: aCapitalizedName.
				anAttribute valueTypeName: aValue.
				self attributesAdd: anAttribute
			]
		]
	]



"
'00 unspecified
11 next of kin
12 relative
13 parent
14 father
15 mother
16 grand-parent
17 other ancestor
18 child
19 other descendant
20 sibling
29 other consanguineous relative
31 partner
32 husband
33 wife
34 domestic partner
39 other relative-in-law
59 family in general
61 friend
62 employer
63 tutor
64 guardian
65 prison officer
81 person in contact at home
82 person in contact at school
83 person in contact at work
84 person in contact during travel
85 neighbour
90 representative of patient
99 other person in contact'

"!

importLinkTypeEnumsAsCategorizedListOfCodeAndName: theSource

	| someLines |
	(theSource isNil or: [ theSource isEmpty]) ifTrue: [ ^self].
	someLines := theSource asArrayBrokenOn: Character cr.
	someLines isEmpty ifTrue: [ ^self].

	someLines do: [:aLine |  | anIndex aValue aName aCapitalizedName aStream anAttribute |
		aLine isEmpty ifFalse: [ 
			anIndex := aLine indexOf: Character space.
			anIndex  < 2 ifFalse: [ 
				aValue := aLine copyFrom: 1 to: anIndex - 1.
				aName := aLine copyFrom: anIndex + 1 to: aLine size.
				aStream := WriteStream on: (String new: aName size).
				(aName copyReplacing: $- withObject: Character space)
					asArrayOfSubstrings do: [:aSubstr | aStream nextPutAll: aSubstr capitalized].
				aCapitalizedName := aStream contents.
				anAttribute := self preferredAttributeClass new name: aCapitalizedName.
				anAttribute valueTypeName: aValue.
				self attributesAdd: anAttribute
			]
		]
	]



"
'  generic links
DTL01	is related to /is related to	clinical situation, document	is related to 	clinical situation, document
DTL02	other local link	(for other links that cannot be mapped to the other entries in this table)
   documenting and reporting links (including meta-comments about clinical statements)
DTL03	produces /is produced by	healthcare activity 	produces	result, report
DTL04	is documented by /documents	healthcare activity 	is documented by	note
DTL05	is reported within /reports about	property	is reported within	report
DTL06	describes /is described by	property	describes 	region of interest
DTL07	is identified within /incorporates	region of interest	is identified within	study product
DTL08	is derived from /is source for	property	is derived from 	study product  
DTL09	is compared to /is reference for	clinical situation, document	is compared to 	clinical situation, document
DTL10	is recorded against /is recorded against	family history of x 	is recorded against 	no evidence of x
DTL11	supersedes /is superseded by	clinical state, problem 	supersedes 	clinical state, problem
   organisational links 
DTL12	is framework for /is framed in	contact 	is framework for 	clinical situation, document
DTL13	has phase /is phase of	healthcare activity 	has phase	sub-activity
DTL14	is next phase with respect to /has next phase	healthcare activity	is next phase	sibling activity 
   clinical links (i.e. based on clinical judgement)
DTL15	is associate to /is associate to	condition  	is associate to	condition
DTL16	is assigned to /is setting for	clinical situation   	is assigned to 	problem
DTL17	is interpretation of/ is interpreted as	condition  	is interpretation of 	findings, report
DTL18	has progress /is progress of 	condition   	has progress	condition 
DTL19	has cause /is cause of 	condition  	has cause 	condition
DTL20	co-exists with /co-exists with	condition  	co-exists with 	condition
DTL21	is evidence for /has evidence	finding  	is evidence for 	diagnosis
DTL22	triggers /is triggered by	presence of prosthesis	triggers	risk state
DTL23	has goal /is goal of	healthcare activity	has goal	achievable clinical situation 
DTL24	has motivation /is motivation for	healthcare activity	has motivation 	current clinical situation
DTL25	has consequence /is consequence of	healthcare activity, event	has consequence 	clinical situation (outcome)
   circumstantial links 
DTL26	has topic /is topic for	informing	has topic 	Record Component
DTL27	is directed to /receives	informing 	is directed to 	person
DTL28	provides information about /has information source	person 	provides information about	Record Component
DTL29	has circumstances /is circumstance for	support activity 	has circumstance 	home circumstances 
   view management links 
DTL30	add to view	in a message, to add a Record Component to a previously specified view
DTL31	remove from view	in a message, to remove a Record Component from a previously specified view

'

"!

importLinkTypeEnumsAsCategorizedListOfCodeAndName: theSource typePrefix: thePrefix typePostfix: thePostfix


	| someLines aGroup aType |
	(theSource isNil or: [ theSource isEmpty]) ifTrue: [ ^self].
	someLines := theSource asArrayBrokenOn: Character cr.
	someLines isEmpty ifTrue: [ ^self].
	
	aGroup := OrderedCollection new: 32.
	aType := nil.
	someLines do: [:aLine |    | aTypeName aNewType   |
		aLine first = Character space 
			ifFalse: [ aGroup add: aLine]
			ifTrue: [  	
				(aGroup isEmpty not and: [ aType isNil not]) ifTrue: [ 
					aType importLinkTypeEnumsAsListOfCodeAndName: aGroup.
					aGroup := OrderedCollection new: 32.
					aType := nil
				].
				aTypeName := thePrefix, (self class capitalize: aLine trimBlanks), thePostfix.
				aNewType := self preferredTypeClass new name: aTypeName.
				self module typesAdd: aNewType.
				self superTypesAdd: aNewType.
				aType := aNewType.
				
				]
	].
	(aGroup isEmpty not and: [ aType isNil not]) ifTrue: [ 
		aType importLinkTypeEnumsAsListOfCodeAndName: aGroup
	].





"
'  generic links
DTL01	is related to /is related to	clinical situation, document	is related to 	clinical situation, document
DTL02	other local link	(for other links that cannot be mapped to the other entries in this table)
   documenting and reporting links (including meta-comments about clinical statements)
DTL03	produces /is produced by	healthcare activity 	produces	result, report
DTL04	is documented by /documents	healthcare activity 	is documented by	note
DTL05	is reported within /reports about	property	is reported within	report
DTL06	describes /is described by	property	describes 	region of interest
DTL07	is identified within /incorporates	region of interest	is identified within	study product
DTL08	is derived from /is source for	property	is derived from 	study product  
DTL09	is compared to /is reference for	clinical situation, document	is compared to 	clinical situation, document
DTL10	is recorded against /is recorded against	family history of x 	is recorded against 	no evidence of x
DTL11	supersedes /is superseded by	clinical state, problem 	supersedes 	clinical state, problem
   organisational links 
DTL12	is framework for /is framed in	contact 	is framework for 	clinical situation, document
DTL13	has phase /is phase of	healthcare activity 	has phase	sub-activity
DTL14	is next phase with respect to /has next phase	healthcare activity	is next phase	sibling activity 
   clinical links (i.e. based on clinical judgement)
DTL15	is associate to /is associate to	condition  	is associate to	condition
DTL16	is assigned to /is setting for	clinical situation   	is assigned to 	problem
DTL17	is interpretation of/ is interpreted as	condition  	is interpretation of 	findings, report
DTL18	has progress /is progress of 	condition   	has progress	condition 
DTL19	has cause /is cause of 	condition  	has cause 	condition
DTL20	co-exists with /co-exists with	condition  	co-exists with 	condition
DTL21	is evidence for /has evidence	finding  	is evidence for 	diagnosis
DTL22	triggers /is triggered by	presence of prosthesis	triggers	risk state
DTL23	has goal /is goal of	healthcare activity	has goal	achievable clinical situation 
DTL24	has motivation /is motivation for	healthcare activity	has motivation 	current clinical situation
DTL25	has consequence /is consequence of	healthcare activity, event	has consequence 	clinical situation (outcome)
   circumstantial links 
DTL26	has topic /is topic for	informing	has topic 	Record Component
DTL27	is directed to /receives	informing 	is directed to 	person
DTL28	provides information about /has information source	person 	provides information about	Record Component
DTL29	has circumstances /is circumstance for	support activity 	has circumstance 	home circumstances 
   view management links 
DTL30	add to view	in a message, to add a Record Component to a previously specified view
DTL31	remove from view	in a message, to remove a Record Component from a previously specified view

'

"!

importLinkTypeEnumsAsListOfCodeAndName: theLines

	(theLines isNil or: [ theLines isEmpty]) ifTrue: [ ^self].

	theLines do: [:aLine |  | aLineStream  aValue aLinkOne aLinkTwo aExamplePart1 aExamplePart2 aExamplePart3 anAttribute  aComment aComment2 |
		aLine isEmpty ifFalse: [ 
			aLineStream := ReadStream on: aLine.
			aValue := nil.
			aLinkOne := nil.
			aLinkTwo := nil.
			aExamplePart1 := nil.
			aExamplePart2 := nil.
			aExamplePart3 := nil.
			aLineStream atEnd ifFalse: [  aValue :=  (aLineStream upTo: Character tab) trimBlanks].
			aLineStream atEnd ifFalse: [  aLinkOne := self class capitalize:(aLineStream upTo: $/) trimBlanks].
			aLineStream atEnd ifFalse: [  aLinkTwo := self class capitalize: (aLineStream upTo: Character tab) trimBlanks].
			aLineStream atEnd ifFalse: [  aExamplePart1 := (aLineStream upTo: Character tab) trimBlanks].
			aLineStream atEnd ifFalse: [  aExamplePart2 := self class capitalize: (aLineStream upTo: Character tab) trimBlanks].
			aLineStream atEnd ifFalse: [  aExamplePart3 := (aLineStream upToEnd) trimBlanks].
			(aValue isNil not and: [ aLinkOne isNil not and: [ aLinkTwo isNil not and: [ 
				aExamplePart1 isNil not and: [  aExamplePart2 isNil not and: [  aExamplePart3 isNil not ]]]]]) ifTrue: [ 
				anAttribute := self preferredAttributeClass new name: aLinkOne.
				anAttribute valueTypeName: aValue.
				self attributesAdd: anAttribute.
				aComment := self preferredCommentClass new name: 'ReverseLink'.
				aComment text:  aLinkTwo.
				anAttribute commentsAdd: aComment.
				aComment2 := self preferredCommentClass new name: 'Example'.
				aComment2 text:  (aExamplePart1 , '/',  aExamplePart2 , '/', aExamplePart3) withCRs.
				anAttribute commentsAdd: aComment2.

			]
		]
	]



"self importLinkTypeEnumsAsCategorizedListOfCodeAndName:   

'   generic links
DTL01	is related to /is related to	clinical situation, document	is related to 	clinical situation, document
DTL02	other local link	(for other links that cannot be mapped to the other entries in this table)
   documenting and reporting links (including meta-comments about clinical statements)
DTL03	produces /is produced by	healthcare activity 	produces	result, report
DTL04	is documented by /documents	healthcare activity 	is documented by	note
DTL05	is reported within /reports about	property	is reported within	report
DTL06	describes /is described by	property	describes 	region of interest
DTL07	is identified within /incorporates	region of interest	is identified within	study product
DTL08	is derived from /is source for	property	is derived from 	study product  
DTL09	is compared to /is reference for	clinical situation, document	is compared to 	clinical situation, document
DTL10	is recorded against /is recorded against	family history of x 	is recorded against 	no evidence of x
DTL11	supersedes /is superseded by	clinical state, problem 	supersedes 	clinical state, problem
   organisational links 
DTL12	is framework for /is framed in	contact 	is framework for 	clinical situation, document
DTL13	has phase /is phase of	healthcare activity 	has phase	sub-activity
DTL14	is next phase with respect to /has next phase	healthcare activity	is next phase	sibling activity 
   clinical links (i.e. based on clinical judgement)
DTL15	is associate to /is associate to	condition  	is associate to	condition
DTL16	is assigned to /is setting for	clinical situation   	is assigned to 	problem
DTL17	is interpretation of/ is interpreted as	condition  	is interpretation of 	findings, report
DTL18	has progress /is progress of 	condition   	has progress	condition 
DTL19	has cause /is cause of 	condition  	has cause 	condition
DTL20	co-exists with /co-exists with	condition  	co-exists with 	condition
DTL21	is evidence for /has evidence	finding  	is evidence for 	diagnosis
DTL22	triggers /is triggered by	presence of prosthesis	triggers	risk state
DTL23	has goal /is goal of	healthcare activity	has goal	achievable clinical situation 
DTL24	has motivation /is motivation for	healthcare activity	has motivation 	current clinical situation
DTL25	has consequence /is consequence of	healthcare activity, event	has consequence 	clinical situation (outcome)
   circumstantial links 
DTL26	has topic /is topic for	informing	has topic 	Record Component
DTL27	is directed to /receives	informing 	is directed to 	person
DTL28	provides information about /has information source	person 	provides information about	Record Component
DTL29	has circumstances /is circumstance for	support activity 	has circumstance 	home circumstances 
   view management links 
DTL30	add to view	in a message, to add a Record Component to a previously specified view
DTL31	remove from view	in a message, to remove a Record Component from a previously specified view'
typePrefix: 'LinkItem_NameCategory' typePostfix: '_enum'"! !

!CODEType publicMethodsFor: 'utilities-build from configurations'!

buildAttributeFromParameterBoolean: theParameter type: theType
	| anAttribute |
	theParameter isNil ifTrue: [ ^self].
	
	theParameter type = METAParameterBoolean type ifFalse: [  ^self].

	anAttribute := self buildBasicAttributeFromParameter: theParameter  type: theType.
	anAttribute isNil ifTrue: [ ^self].


	^anAttribute!

buildAttributeFromParameterEnum: theParameter
	| anAttribute |
	theParameter isNil ifTrue: [ ^self].
	
	theParameter type = METAParameterEnum type ifFalse: [  ^self].

	anAttribute := self buildBasicAttributeFromParameter: theParameter.
	anAttribute isNil ifTrue: [ ^self].


	^anAttribute!

buildAttributeFromParameterNumber: theParameter type: theType
	| anAttribute |
	theParameter isNil ifTrue: [ ^self].
	
	theParameter type = METAParameterNumber type ifFalse: [  ^self].

	anAttribute := self buildBasicAttributeFromParameter: theParameter type: theType.
	anAttribute isNil ifTrue: [ ^self].


	^anAttribute!

buildAttributeFromParameterNumberBounded: theParameter type: theType
	| anAttribute |
	theParameter isNil ifTrue: [ ^self].
	
	theParameter type = METAParameterNumberBounded type ifFalse: [  ^self].

	anAttribute := self buildBasicAttributeFromParameter: theParameter type: theType.
	anAttribute isNil ifTrue: [ ^self].


	^anAttribute!

buildAttributeFromParameterString: theParameter type: theType
	| anAttribute |
	theParameter isNil ifTrue: [ ^self].
	
	theParameter type = METAParameterString type ifFalse: [  ^self].

	anAttribute := self buildBasicAttributeFromParameter: theParameter type: theType.
	anAttribute isNil ifTrue: [ ^self].


	^anAttribute!

buildAttributeFromParameterSymbol: theParameter type: theType
	| anAttribute |
	theParameter isNil ifTrue: [ ^self].
	
	theParameter type = METAParameterSymbol type ifFalse: [  ^self].

	anAttribute := self buildBasicAttributeFromParameter: theParameter type: theType.
	anAttribute isNil ifTrue: [ ^self].


	^anAttribute!

buildAttributesFromConfigurationParameters: theConfiguration primitiveTypesModuleNames: thePrimitiveTypesModuleNames
	| someParameters someSortedParameters aModel aPrimitiveTypesModule aStringType aBooleanType aSymbolType aNumberType |
	theConfiguration isNil ifTrue: [ ^self].
	thePrimitiveTypesModuleNames  isNil ifTrue: [ ^self].
	
	someParameters := theConfiguration parameters.
	someParameters isNil ifTrue: [ ^self].

	aModel := self model.
	aModel isNil ifTrue: [ ^self].

	aPrimitiveTypesModule := aModel resolveReferencedModuleNames: thePrimitiveTypesModuleNames.
	aPrimitiveTypesModule isNil ifTrue: [ ^self].

	aBooleanType := aPrimitiveTypesModule resolveReferencedTypeName:  'Boolean'.
	aStringType := aPrimitiveTypesModule resolveReferencedTypeName:  'String'.
	aSymbolType := aPrimitiveTypesModule resolveReferencedTypeName:  'Symbol'.
	aNumberType := aPrimitiveTypesModule resolveReferencedTypeName:  'Number'.

	
	someSortedParameters := someParameters asSortedCollection: [:aPar :otherPar | aPar name < otherPar name].

	someSortedParameters do: [:aParameter |  | aParameterType anAttribute |
		aParameterType := aParameter type.
		aParameterType isNil ifFalse: [ 
			anAttribute := aParameterType = METAParameterBoolean type ifTrue: [  
				self buildAttributeFromParameterBoolean: aParameter type: aBooleanType
			] ifFalse: [ 
			aParameterType = METAParameterSymbol type ifTrue: [  
				self buildAttributeFromParameterSymbol: aParameter type: aSymbolType
			] ifFalse: [ 
			aParameterType = METAParameterString type ifTrue: [  
				self buildAttributeFromParameterString: aParameter type: aStringType
			] ifFalse: [ 
			aParameterType = METAParameterNumber type ifTrue: [  
				self buildAttributeFromParameterNumber: aParameter type: aNumberType
			] ifFalse: [ 
			aParameterType = METAParameterNumberBounded type ifTrue: [  
				self buildAttributeFromParameterNumberBounded: aParameter type: aNumberType
			] ifFalse: [ 
			aParameterType = METAParameterEnum type ifTrue: [  
				self buildAttributeFromParameterEnum: aParameter
			] ifFalse: [ 
				nil
			] ] ] ] ] ].
		anAttribute isNil ifFalse: [ self attributesAdd: anAttribute]
		]
	]!

buildBasicAttributeFromParameter: theParameter type: theType
	| anAttribute aComment aDerivationBlock aVerificationBlock |
	theParameter isNil ifTrue: [ ^self].
	
	anAttribute := CODEAttribute new.
	anAttribute name: theParameter name.
	theType isNil ifFalse: [ 
		anAttribute valueType: theType
	].


	aComment := CODEComment new name: theParameter label.
	aComment text:  theParameter description.
	anAttribute commentsAdd: aComment.
	anAttribute isChangeable: theParameter isEditable == true.

	anAttribute minMult: #'1'.
	anAttribute maxMult: #'1'.

	anAttribute isInitializationPropagationAllowed: false.
	anAttribute isInitializationPropagationOnConnectAllowed: false.

	aDerivationBlock := theParameter originalDerivationBlock.
	(aDerivationBlock isNil not and: [ aDerivationBlock isEmpty not])
		ifTrue: [ 
			anAttribute initializationExpression: 'clonenot calc ' , aDerivationBlock.
			anAttribute computationKind: anAttribute class computationKindAlways.
		]
		ifFalse: [ 
			anAttribute initializationExpression: 'clonenot literal ' , theParameter storeDefaultValueString.
			anAttribute computationKind: anAttribute class computationKindInitialValue.
		].

	aVerificationBlock := theParameter originalVerificationBlock.
	(aVerificationBlock isNil not and: [ aVerificationBlock isEmpty not]) ifTrue: [
		anAttribute valueConstraint: aVerificationBlock
	].

	theParameter requiresOverride ifTrue: [ 
		anAttribute isAbstract: true
	].

	^anAttribute! !

CODEElement initializeAfterLoad!
CODEComment initializeAfterLoad!
CODECommentedElement initializeAfterLoad!
CODEParameter initializeAfterLoad!
CODEParametrizedElement initializeAfterLoad!
CODEAspect initializeAfterLoad!
CODEAspectuatedElement initializeAfterLoad!
CODEArgument initializeAfterLoad!
CODEArgumentRefinement initializeAfterLoad!
CODEComponent initializeAfterLoad!
CODEElementMap initializeAfterLoad!
CODEMapLogic initializeAfterLoad!
CODEModule initializeAfterLoad!
CODEMapsFolder initializeAfterLoad!
CODEModel initializeAfterLoad!
CODEMap initializeAfterLoad!
CODEOperation initializeAfterLoad!
CODEOperationRefinement initializeAfterLoad!
CODEPort initializeAfterLoad!
CODERootPort initializeAfterLoad!
CODESubPort initializeAfterLoad!
CODEFlowPort initializeAfterLoad!
CODEProtocolPort initializeAfterLoad!
CODESemanticPort initializeAfterLoad!
CODESemanticPortParameter initializeAfterLoad!
CODEStructuralFeature initializeAfterLoad!
CODEAttribute initializeAfterLoad!
CODEAttributeRefinement initializeAfterLoad!
CODERelationship initializeAfterLoad!
CODERelationshipRefinement initializeAfterLoad!
CODEType initializeAfterLoad!
CODEGenInstaller initializeAfterLoad!
CODEReengine initializeAfterLoad!
CODEcodeReengine initializeAfterLoad!
CODEgen initializeAfterLoad!

CODEgen loaded!
